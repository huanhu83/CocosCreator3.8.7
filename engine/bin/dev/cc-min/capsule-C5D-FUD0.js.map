{"version":3,"file":"capsule-C5D-FUD0.js","sources":["../../../cocos/primitive/define.ts","../../../cocos/primitive/box.ts","../../../cocos/primitive/cylinder.ts","../../../cocos/primitive/capsule.ts","../../../cocos/primitive/plane.ts"],"sourcesContent":["/*\r\n Copyright (c) 2020-2023 Xiamen Yaji Software Co., Ltd.\r\n\r\n https://www.cocos.com/\r\n\r\n Permission is hereby granted, free of charge, to any person obtaining a copy\r\n of this software and associated documentation files (the \"Software\"), to deal\r\n in the Software without restriction, including without limitation the rights to\r\n use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\r\n of the Software, and to permit persons to whom the Software is furnished to do so,\r\n subject to the following conditions:\r\n\r\n The above copyright notice and this permission notice shall be included in\r\n all copies or substantial portions of the Software.\r\n\r\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n THE SOFTWARE.\r\n*/\r\n\r\nimport { PrimitiveMode, Attribute } from '../gfx';\r\n\r\n/**\r\n * @en\r\n * The definition of the parameter for building a primitive geometry.\r\n * @zh\r\n * 几何体参数选项。\r\n */\r\nexport interface IGeometryOptions {\r\n    /**\r\n     * @en\r\n     * Whether to include normal. Default to true.\r\n     * @zh\r\n     * 是否包含法线。默认为true。\r\n     */\r\n    includeNormal: boolean;\r\n\r\n    /**\r\n     * @en\r\n     * Whether to include uv. Default to true.\r\n     * @zh\r\n     * 是否包含UV。默认为true。\r\n     */\r\n    includeUV: boolean;\r\n}\r\n\r\n/**\r\n * @en\r\n * Apply the options to default.\r\n * @zh\r\n * 应用默认的几何参数选项。\r\n */\r\nexport function applyDefaultGeometryOptions<GeometryOptions = IGeometryOptions> (\r\n    options?: RecursivePartial<IGeometryOptions>,\r\n): GeometryOptions {\r\n    options = options || {};\r\n    if (options.includeNormal === undefined) {\r\n        options.includeNormal = true;\r\n    }\r\n    if (options.includeUV === undefined) {\r\n        options.includeUV = true;\r\n    }\r\n    return options as GeometryOptions;\r\n}\r\n\r\n/**\r\n * @en\r\n * The definition of the geometry, this struct can build a mesh.\r\n * @zh\r\n * 几何体信息。\r\n */\r\nexport interface IGeometry {\r\n    /**\r\n     * @en\r\n     * Vertex positions.\r\n     * @zh\r\n     * 顶点位置。\r\n     */\r\n    positions: number[];\r\n\r\n    /**\r\n     * @en\r\n     * Vertex normals.\r\n     * @zh\r\n     * 顶点法线。\r\n     */\r\n    normals?: number[];\r\n\r\n    /**\r\n     * @en\r\n     * Texture coordinates.\r\n     * @zh\r\n     * 纹理坐标。\r\n     */\r\n    uvs?: number[];\r\n\r\n    /**\r\n     * @en\r\n     * Vertex Tangents.\r\n     * @zh\r\n     * 顶点切线。\r\n     */\r\n    tangents?: number[];\r\n\r\n    /**\r\n     * @en\r\n     * Vertex colors.\r\n     * @zh\r\n     * 顶点颜色。\r\n     */\r\n    colors?: number[];\r\n\r\n    /**\r\n     * @en\r\n     * specify vertex attributes, use (positions|normals|uvs|colors) as keys\r\n     * @zh\r\n     * 顶点属性。\r\n     */\r\n    attributes?: Attribute[];\r\n\r\n    customAttributes?: {\r\n        attr: Attribute,\r\n        values: number[],\r\n    }[];\r\n\r\n    /**\r\n     * @en\r\n     * Bounding sphere radius.\r\n     * @zh\r\n     * 包围球半径。\r\n     */\r\n    boundingRadius?: number;\r\n\r\n    /**\r\n     * @en\r\n     * Min position.\r\n     * @zh\r\n     * 最小位置。\r\n     */\r\n    minPos?: {\r\n        x: number;\r\n        y: number;\r\n        z: number;\r\n    };\r\n\r\n    /**\r\n     * @en\r\n     * Max position.\r\n     * @zh\r\n     * 最大位置。\r\n     */\r\n    maxPos?: {\r\n        x: number;\r\n        y: number;\r\n        z: number;\r\n    };\r\n\r\n    /**\r\n     * @en\r\n     * Geometry indices, if one needs indexed-draw.\r\n     * @zh\r\n     * 几何索引，当使用索引绘制时。\r\n     */\r\n    indices?: number[];\r\n\r\n    /**\r\n     * @en\r\n     * Topology of the geometry vertices. Default is TRIANGLE_LIST.\r\n     * @zh\r\n     * 几何顶点的拓扑图元。默认值是TRIANGLE_LIST。\r\n     */\r\n    primitiveMode?: PrimitiveMode;\r\n\r\n    /**\r\n     * @en\r\n     * whether rays casting from the back face of this geometry could collide with it\r\n     * @zh\r\n     * 是否是双面，用于判断来自于几何体背面的射线检测。\r\n     */\r\n    doubleSided?: boolean;\r\n}\r\n\r\n/**\r\n * @en\r\n * The definition of the dynamic geometry, this struct can build a dynamic mesh.\r\n * @zh\r\n * 几何体信息。\r\n */\r\nexport interface IDynamicGeometry {\r\n    /**\r\n     * @en\r\n     * Vertex positions: 3 float components.\r\n     * @zh\r\n     * 顶点位置：3个float分量。\r\n     */\r\n    positions: Float32Array;\r\n\r\n    /**\r\n     * @en\r\n     * Vertex normals: 3 float components.\r\n     * @zh\r\n     * 顶点法线：3个float分量。\r\n     */\r\n    normals?: Float32Array;\r\n\r\n    /**\r\n     * @en\r\n     * Texture coordinates: 2 float components.\r\n     * @zh\r\n     * 纹理坐标：2个float分量。\r\n     */\r\n    uvs?: Float32Array;\r\n\r\n    /**\r\n     * @en\r\n     * Vertex Tangents: 4 float components.\r\n     * @zh\r\n     * 顶点切线：4个float分量。\r\n     */\r\n    tangents?: Float32Array;\r\n\r\n    /**\r\n     * @en\r\n     * Vertex colors: 4 float components.\r\n     * @zh\r\n     * 顶点颜色：4个float分量。\r\n     */\r\n    colors?: Float32Array;\r\n\r\n    /**\r\n     * @en\r\n     * Custom attributes\r\n     * @zh\r\n     * 定制属性列表。\r\n     */\r\n    customAttributes?: {\r\n        attr: Attribute,\r\n        values: Float32Array,\r\n    }[];\r\n\r\n    /**\r\n     * @en\r\n     * Min position.\r\n     * @zh\r\n     * 最小位置。\r\n     */\r\n    minPos?: {\r\n        x: number;\r\n        y: number;\r\n        z: number;\r\n    };\r\n\r\n    /**\r\n     * @en\r\n     * Max position.\r\n     * @zh\r\n     * 最大位置。\r\n     */\r\n    maxPos?: {\r\n        x: number;\r\n        y: number;\r\n        z: number;\r\n    };\r\n\r\n    /**\r\n     * @en\r\n     * 16 bits Geometry indices, if one needs indexed-draw.\r\n     * @zh\r\n     * 16位几何索引，当使用索引绘制时。\r\n     */\r\n    indices16?: Uint16Array;\r\n\r\n    /**\r\n     * @en\r\n     * 32 bits Geometry indices, if one needs indexed-draw.\r\n     * @zh\r\n     * 32位几何索引，当使用索引绘制时。\r\n     */\r\n    indices32?: Uint32Array;\r\n\r\n    /**\r\n     * @en\r\n     * Topology of the geometry vertices. Default is TRIANGLE_LIST.\r\n     * @zh\r\n     * 几何顶点的拓扑图元。默认值是TRIANGLE_LIST。\r\n     */\r\n    primitiveMode?: PrimitiveMode;\r\n\r\n    /**\r\n     * @en\r\n     * whether rays casting from the back face of this geometry could collide with it\r\n     * @zh\r\n     * 是否是双面，用于判断来自于几何体背面的射线检测。\r\n     */\r\n    doubleSided?: boolean;\r\n}\r\n\r\nexport interface ICreateMeshOptions {\r\n    /**\r\n     * @en calculate mesh's aabb or not\r\n     * @zh 是否计算模型的包围盒。\r\n     */\r\n    calculateBounds?: boolean;\r\n}\r\n\r\nexport interface ICreateDynamicMeshOptions {\r\n    /**\r\n     * @en max sub mesh count\r\n     * @zh 最大子模型个数。\r\n     */\r\n    maxSubMeshes: number;\r\n\r\n    /**\r\n     * @en max sub mesh vertex count\r\n     * @zh 子模型最大顶点个数。\r\n     */\r\n    maxSubMeshVertices: number;\r\n\r\n    /**\r\n     * @en max sub mesh index count\r\n     * @zh 子模型最大索引个数。\r\n     */\r\n    maxSubMeshIndices: number;\r\n}\r\n","/*\r\n Copyright (c) 2020-2023 Xiamen Yaji Software Co., Ltd.\r\n\r\n https://www.cocos.com/\r\n\r\n Permission is hereby granted, free of charge, to any person obtaining a copy\r\n of this software and associated documentation files (the \"Software\"), to deal\r\n in the Software without restriction, including without limitation the rights to\r\n use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\r\n of the Software, and to permit persons to whom the Software is furnished to do so,\r\n subject to the following conditions:\r\n\r\n The above copyright notice and this permission notice shall be included in\r\n all copies or substantial portions of the Software.\r\n\r\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n THE SOFTWARE.\r\n*/\r\n\r\nimport { Vec3 } from '../core';\r\nimport { IGeometry, IGeometryOptions } from './define';\r\n\r\n/**\r\n * @en\r\n * The definition of the parameter for building a box.\r\n * @zh\r\n * 立方体参数选项。\r\n */\r\ninterface IBoxOptions extends RecursivePartial<IGeometryOptions> {\r\n    /**\r\n     * @en\r\n     * Box extent on X-axis.\r\n     * @zh\r\n     * 立方体宽度。\r\n     */\r\n    width?: number;\r\n\r\n    /**\r\n     * @en\r\n     * Box extent on Y-axis.\r\n     * @zh\r\n     * 立方体高度。\r\n     */\r\n    height?: number;\r\n\r\n    /**\r\n     * @en\r\n     * Box extent on Z-axis.\r\n     * @zh\r\n     * 立方体长度。\r\n     */\r\n    length?: number;\r\n\r\n    /**\r\n     * @en\r\n     * Segment count on X-axis.\r\n     * @zh\r\n     * 宽度线段数。\r\n     */\r\n    widthSegments?: number;\r\n\r\n    /**\r\n     * @en\r\n     * Segment count on Y-axis.\r\n     * @zh\r\n     * 高度线段数。\r\n     */\r\n    heightSegments?: number;\r\n\r\n    /**\r\n     * @en\r\n     * Segment count on Z-axis.\r\n     * @zh\r\n     * 长度线段数。\r\n     */\r\n    lengthSegments?: number;\r\n}\r\n\r\n/**\r\n * @en\r\n * This function generates a box with specified extents and centered at origin,\r\n * but may be repositioned through the `center` option.\r\n * @zh\r\n * 生成一个立方体，其大小是定义的范围且中心在原点。\r\n * @param options @zh 参数选项。@en The optional creation parameters of the box\r\n */\r\nexport default function box (options?: IBoxOptions): IGeometry {\r\n    options = options || {};\r\n    const ws = options.widthSegments || 1;\r\n    const hs = options.heightSegments || 1;\r\n    const ls = options.lengthSegments || 1;\r\n\r\n    const hw = (options.width || 1) / 2;\r\n    const hh = (options.height || 1) / 2;\r\n    const hl = (options.length || 1) / 2;\r\n\r\n    const corners = [\r\n        Vec3.set(c0, -hw, -hh, hl),\r\n        Vec3.set(c1, hw, -hh, hl),\r\n        Vec3.set(c2, hw, hh, hl),\r\n        Vec3.set(c3, -hw, hh, hl),\r\n        Vec3.set(c4, hw, -hh, -hl),\r\n        Vec3.set(c5, -hw, -hh, -hl),\r\n        Vec3.set(c6, -hw, hh, -hl),\r\n        Vec3.set(c7, hw, hh, -hl),\r\n    ];\r\n\r\n    const faceAxes = [\r\n        [2, 3, 1], // FRONT\r\n        [4, 5, 7], // BACK\r\n        [7, 6, 2], // TOP\r\n        [1, 0, 4], // BOTTOM\r\n        [1, 4, 2], // RIGHT\r\n        [5, 0, 6],  // LEFT\r\n    ];\r\n\r\n    const faceNormals = [\r\n        [0,  0,  1], // FRONT\r\n        [0,  0, -1], // BACK\r\n        [0,  1,  0], // TOP\r\n        [0, -1,  0], // BOTTOM\r\n        [1,  0,  0], // RIGHT\r\n        [-1,  0,  0],  // LEFT\r\n    ];\r\n\r\n    const faceTangents = [\r\n        [-1, 0,  0, 1], // FRONT\r\n        [-1, 0,  0, 1], // BACK\r\n        [-1, 0,  0, 1], // TOP\r\n        [-1, 0,  0, 1], // BOTTOM\r\n        [0, 0, -1, 1], // RIGHT\r\n        [0, 0,  1, 1], // LEFT\r\n    ];\r\n\r\n    const positions: number[] = [];\r\n    const normals: number[] = [];\r\n    const uvs: number[] = [];\r\n    const tangents: number[] = [];\r\n    const indices: number[] = [];\r\n    const minPos = new Vec3(-hw, -hh, -hl);\r\n    const maxPos = new Vec3(hw, hh, hl);\r\n    const boundingRadius = Math.sqrt(hw * hw + hh * hh + hl * hl);\r\n\r\n    function _buildPlane (side: number, uSegments: number, vSegments: number): void {\r\n        let u: number;\r\n        let v: number;\r\n        let ix: number;\r\n        let iy: number;\r\n        const offset = positions.length / 3;\r\n        const faceAxe = faceAxes[side];\r\n        const faceNormal = faceNormals[side];\r\n        const faceTangent = faceTangents[side];\r\n\r\n        for (iy = 0; iy <= vSegments; iy++) {\r\n            for (ix = 0; ix <= uSegments; ix++) {\r\n                u = ix / uSegments;\r\n                v = iy / vSegments;\r\n\r\n                Vec3.lerp(temp1, corners[faceAxe[0]], corners[faceAxe[1]], u);\r\n                Vec3.lerp(temp2, corners[faceAxe[0]], corners[faceAxe[2]], v);\r\n                Vec3.subtract(temp3, temp2, corners[faceAxe[0]]);\r\n                Vec3.add(r, temp1, temp3);\r\n\r\n                positions.push(r.x, r.y, r.z);\r\n                normals.push(faceNormal[0], faceNormal[1], faceNormal[2]);\r\n                uvs.push(u, v);\r\n                tangents.push(faceTangent[0], faceTangent[1], faceTangent[2], faceTangent[3]);\r\n\r\n                if ((ix < uSegments) && (iy < vSegments)) {\r\n                    const useg1 = uSegments + 1;\r\n                    const a = ix + iy * useg1;\r\n                    const b = ix + (iy + 1) * useg1;\r\n                    const c = (ix + 1) + (iy + 1) * useg1;\r\n                    const d = (ix + 1) + iy * useg1;\r\n\r\n                    indices.push(offset + a, offset + d, offset + b);\r\n                    indices.push(offset + b, offset + d, offset + c);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    _buildPlane(0, ws, hs); // FRONT\r\n    _buildPlane(4, ls, hs); // RIGHT\r\n    _buildPlane(1, ws, hs); // BACK\r\n    _buildPlane(5, ls, hs); // LEFT\r\n    _buildPlane(3, ws, ls); // BOTTOM\r\n    _buildPlane(2, ws, ls); // TOP\r\n\r\n    return {\r\n        positions,\r\n        normals,\r\n        uvs,\r\n        tangents,\r\n        indices,\r\n        minPos,\r\n        maxPos,\r\n        boundingRadius,\r\n    };\r\n}\r\n\r\nconst temp1 = new Vec3();\r\nconst temp2 = new Vec3();\r\nconst temp3 = new Vec3();\r\nconst r = new Vec3();\r\nconst c0 = new Vec3();\r\nconst c1 = new Vec3();\r\nconst c2 = new Vec3();\r\nconst c3 = new Vec3();\r\nconst c4 = new Vec3();\r\nconst c5 = new Vec3();\r\nconst c6 = new Vec3();\r\nconst c7 = new Vec3();\r\n","/*\r\n Copyright (c) 2020-2023 Xiamen Yaji Software Co., Ltd.\r\n\r\n https://www.cocos.com/\r\n\r\n Permission is hereby granted, free of charge, to any person obtaining a copy\r\n of this software and associated documentation files (the \"Software\"), to deal\r\n in the Software without restriction, including without limitation the rights to\r\n use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\r\n of the Software, and to permit persons to whom the Software is furnished to do so,\r\n subject to the following conditions:\r\n\r\n The above copyright notice and this permission notice shall be included in\r\n all copies or substantial portions of the Software.\r\n\r\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n THE SOFTWARE.\r\n*/\r\n\r\nimport { Vec3 } from '../core';\r\nimport { IGeometry, IGeometryOptions } from './define';\r\n\r\n/**\r\n * @en\r\n * The definition of the parameter for building a cylinder.\r\n * @zh\r\n * 圆柱参数选项。\r\n */\r\nexport interface ICylinderOptions extends IGeometryOptions {\r\n    radialSegments: number;\r\n    heightSegments: number;\r\n    capped: boolean;\r\n    arc: number;\r\n}\r\n\r\nconst temp1 = new Vec3(0, 0, 0);\r\nconst temp2 = new Vec3(0, 0, 0);\r\n\r\n/**\r\n * @en\r\n * Generate a cylinder with radiusTop radiusBottom 0.5, height 2 and centered at origin,\r\n * but may be repositioned through the `center` option.\r\n * @zh\r\n * 生成一个圆柱。\r\n * @param radiusTop @en Radius of top plane. @zh 顶部半径。\r\n * @param radiusBottom @en Radius of bottom plane.  @zh 底部半径。\r\n * @param height @en The cylinder height.  @zh 圆柱的高\r\n * @param opts @en The optional creation parameters of the cylinder.  @zh 圆柱参数选项。\r\n */\r\nexport default function cylinder (radiusTop = 0.5, radiusBottom = 0.5, height = 2, opts: RecursivePartial<ICylinderOptions> = {}): IGeometry {\r\n    const halfHeight = height * 0.5;\r\n    const radialSegments = opts.radialSegments || 32;\r\n    const heightSegments = opts.heightSegments || 1;\r\n    const capped = opts.capped !== undefined ? opts.capped : true;\r\n    const arc = opts.arc || 2.0 * Math.PI;\r\n\r\n    let cntCap = 0;\r\n    if (capped) {\r\n        if (radiusTop > 0) {\r\n            cntCap++;\r\n        }\r\n\r\n        if (radiusBottom > 0) {\r\n            cntCap++;\r\n        }\r\n    }\r\n\r\n    // calculate vertex count\r\n    let vertCount = (radialSegments + 1) * (heightSegments + 1);\r\n    if (capped) {\r\n        vertCount += ((radialSegments + 1) * cntCap) + (radialSegments * cntCap);\r\n    }\r\n\r\n    // calculate index count\r\n    let indexCount = radialSegments * heightSegments * 2 * 3;\r\n    if (capped) {\r\n        indexCount += radialSegments * cntCap * 3;\r\n    }\r\n\r\n    const indices = new Array(indexCount);\r\n    const positions = new Array(vertCount * 3);\r\n    const normals = new Array(vertCount * 3);\r\n    const uvs = new Array(vertCount * 2);\r\n    const maxRadius = Math.max(radiusTop, radiusBottom);\r\n    const minPos = new Vec3(-maxRadius, -halfHeight, -maxRadius);\r\n    const maxPos = new Vec3(maxRadius, halfHeight, maxRadius);\r\n    const boundingRadius = Math.sqrt(maxRadius * maxRadius + halfHeight * halfHeight);\r\n\r\n    let index = 0;\r\n    let indexOffset = 0;\r\n\r\n    generateTorso();\r\n\r\n    if (capped) {\r\n        if (radiusBottom > 0) {\r\n            generateCap(false);\r\n        }\r\n\r\n        if (radiusTop > 0) {\r\n            generateCap(true);\r\n        }\r\n    }\r\n\r\n    return {\r\n        positions,\r\n        normals,\r\n        uvs,\r\n        indices,\r\n        minPos,\r\n        maxPos,\r\n        boundingRadius,\r\n    };\r\n\r\n    // =======================\r\n    // internal fucntions\r\n    // =======================\r\n\r\n    function generateTorso (): void {\r\n        const indexArray: number[][] = [];\r\n\r\n        // this will be used to calculate the normal\r\n        const r = radiusTop - radiusBottom;\r\n        const slope = r * r / height * Math.sign(r);\r\n\r\n        // generate positions, normals and uvs\r\n        for (let y = 0; y <= heightSegments; y++) {\r\n            const indexRow: number[] = [];\r\n            const v = y / heightSegments;\r\n\r\n            // calculate the radius of the current row\r\n            const radius = v * r + radiusBottom;\r\n\r\n            for (let x = 0; x <= radialSegments; ++x) {\r\n                const u = x / radialSegments;\r\n                const theta = u * arc;\r\n\r\n                const sinTheta = Math.sin(theta);\r\n                const cosTheta = Math.cos(theta);\r\n\r\n                // vertex\r\n                positions[3 * index] = radius * sinTheta;\r\n                positions[3 * index + 1] = v * height - halfHeight;\r\n                positions[3 * index + 2] = radius * cosTheta;\r\n\r\n                // normal\r\n                Vec3.normalize(temp1, Vec3.set(temp2, sinTheta, -slope, cosTheta));\r\n                normals[3 * index] = temp1.x;\r\n                normals[3 * index + 1] = temp1.y;\r\n                normals[3 * index + 2] = temp1.z;\r\n\r\n                // uv\r\n                uvs[2 * index] = (1 - u) * 2 % 1;\r\n                uvs[2 * index + 1] = v;\r\n\r\n                // save index of vertex in respective row\r\n                indexRow.push(index);\r\n\r\n                // increase index\r\n                ++index;\r\n            }\r\n\r\n            // now save positions of the row in our index array\r\n            indexArray.push(indexRow);\r\n        }\r\n\r\n        // generate indices\r\n        for (let y = 0; y < heightSegments; ++y) {\r\n            for (let x = 0; x < radialSegments; ++x) {\r\n                // we use the index array to access the correct indices\r\n                const i1 = indexArray[y][x];\r\n                const i2 = indexArray[y + 1][x];\r\n                const i3 = indexArray[y + 1][x + 1];\r\n                const i4 = indexArray[y][x + 1];\r\n\r\n                // face one\r\n                indices[indexOffset] = i1; ++indexOffset;\r\n                indices[indexOffset] = i4; ++indexOffset;\r\n                indices[indexOffset] = i2; ++indexOffset;\r\n\r\n                // face two\r\n                indices[indexOffset] = i4; ++indexOffset;\r\n                indices[indexOffset] = i3; ++indexOffset;\r\n                indices[indexOffset] = i2; ++indexOffset;\r\n            }\r\n        }\r\n    }\r\n\r\n    function generateCap (top): void {\r\n        const radius = top ? radiusTop : radiusBottom;\r\n        const sign = top ? 1 : -1;\r\n\r\n        // save the index of the first center vertex\r\n        const centerIndexStart = index;\r\n\r\n        // first we generate the center vertex data of the cap.\r\n        // because the geometry needs one set of uvs per face,\r\n        // we must generate a center vertex per face/segment\r\n\r\n        for (let x = 1; x <= radialSegments; ++x) {\r\n            // vertex\r\n            positions[3 * index] = 0;\r\n            positions[3 * index + 1] = halfHeight * sign;\r\n            positions[3 * index + 2] = 0;\r\n\r\n            // normal\r\n            normals[3 * index] = 0;\r\n            normals[3 * index + 1] = sign;\r\n            normals[3 * index + 2] = 0;\r\n\r\n            // uv\r\n            uvs[2 * index] = 0.5;\r\n            uvs[2 * index + 1] = 0.5;\r\n\r\n            // increase index\r\n            ++index;\r\n        }\r\n\r\n        // save the index of the last center vertex\r\n        const centerIndexEnd = index;\r\n\r\n        // now we generate the surrounding positions, normals and uvs\r\n\r\n        for (let x = 0; x <= radialSegments; ++x) {\r\n            const u = x / radialSegments;\r\n            const theta = u * arc;\r\n\r\n            const cosTheta = Math.cos(theta);\r\n            const sinTheta = Math.sin(theta);\r\n\r\n            // vertex\r\n            positions[3 * index] = radius * sinTheta;\r\n            positions[3 * index + 1] = halfHeight * sign;\r\n            positions[3 * index + 2] = radius * cosTheta;\r\n\r\n            // normal\r\n            normals[3 * index] = 0;\r\n            normals[3 * index + 1] = sign;\r\n            normals[3 * index + 2] = 0;\r\n\r\n            // uv\r\n            uvs[2 * index] = 0.5 - (sinTheta * 0.5 * sign);\r\n            uvs[2 * index + 1] = 0.5 + (cosTheta * 0.5);\r\n\r\n            // increase index\r\n            ++index;\r\n        }\r\n\r\n        // generate indices\r\n\r\n        for (let x = 0; x < radialSegments; ++x) {\r\n            const c = centerIndexStart + x;\r\n            const i = centerIndexEnd + x;\r\n\r\n            if (top) {\r\n                // face top\r\n                indices[indexOffset] = i + 1; ++indexOffset;\r\n                indices[indexOffset] = c; ++indexOffset;\r\n                indices[indexOffset] = i; ++indexOffset;\r\n            } else {\r\n                // face bottom\r\n                indices[indexOffset] = c; ++indexOffset;\r\n                indices[indexOffset] = i + 1; ++indexOffset;\r\n                indices[indexOffset] = i; ++indexOffset;\r\n            }\r\n        }\r\n    }\r\n}\r\n","/*\r\n Copyright (c) 2020-2023 Xiamen Yaji Software Co., Ltd.\r\n\r\n https://www.cocos.com/\r\n\r\n Permission is hereby granted, free of charge, to any person obtaining a copy\r\n of this software and associated documentation files (the \"Software\"), to deal\r\n in the Software without restriction, including without limitation the rights to\r\n use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\r\n of the Software, and to permit persons to whom the Software is furnished to do so,\r\n subject to the following conditions:\r\n\r\n The above copyright notice and this permission notice shall be included in\r\n all copies or substantial portions of the Software.\r\n\r\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n THE SOFTWARE.\r\n*/\r\n\r\nimport { Vec3 } from '../core';\r\n\r\n/**\r\n * @en\r\n * The definition of the parameter for building a capsule.\r\n * @zh\r\n * 胶囊体参数选项。\r\n */\r\nexport interface ICapsuteOptions {\r\n    sides: number;\r\n    heightSegments: number;\r\n    capped: boolean;\r\n    arc: number;\r\n}\r\n\r\nconst temp1 = new Vec3(0, 0, 0);\r\nconst temp2 = new Vec3(0, 0, 0);\r\n\r\n/**\r\n * Generate a capsule with radiusTop radiusBottom 0.5, height 2, centered at origin,\r\n * but may be repositioned through the `center` option.\r\n * @zh\r\n * 生成一个胶囊体。\r\n * @param radiusTop @zh 顶部半径。 @en The radius of top sphere\r\n * @param radiusBottom @zh 底部半径。@en The radius of bottom sphere\r\n * @param opts @zh 胶囊体参数选项。@en The optional creation parameters of the capsule\r\n */\r\nexport default function capsule (radiusTop = 0.5, radiusBottom = 0.5, height = 2, opts: RecursivePartial<ICapsuteOptions> = {}): { positions: number[]; normals: number[]; uvs: number[]; indices: number[]; minPos: Vec3; maxPos: Vec3; boundingRadius: number; } {\r\n    const torsoHeight = height - radiusTop - radiusBottom;\r\n    const sides = opts.sides || 32;\r\n    const heightSegments = opts.heightSegments || 32;\r\n    const bottomProp = radiusBottom / height;\r\n    const torProp = torsoHeight / height;\r\n    const topProp = radiusTop / height;\r\n    const bottomSegments = Math.floor(heightSegments * bottomProp);\r\n    const topSegments = Math.floor(heightSegments * topProp);\r\n    const torSegments = Math.floor(heightSegments * torProp);\r\n    const topOffset = torsoHeight + radiusBottom - height / 2;\r\n    const torOffset = radiusBottom - height / 2;\r\n    const bottomOffset = radiusBottom - height / 2;\r\n\r\n    const arc = opts.arc || 2.0 * Math.PI;\r\n\r\n    // calculate vertex count\r\n    const positions: number[] = [];\r\n    const normals: number[] = [];\r\n    const uvs: number[] = [];\r\n    const indices: number[] = [];\r\n    const maxRadius = Math.max(radiusTop, radiusBottom);\r\n    const minPos = new Vec3(-maxRadius, -height / 2, -maxRadius);\r\n    const maxPos = new Vec3(maxRadius, height / 2, maxRadius);\r\n    const boundingRadius = height / 2;\r\n\r\n    let index = 0;\r\n    const indexArray: number[][] = [];\r\n\r\n    generateBottom();\r\n\r\n    generateTorso();\r\n\r\n    generateTop();\r\n\r\n    return {\r\n        positions,\r\n        normals,\r\n        uvs,\r\n        indices,\r\n        minPos,\r\n        maxPos,\r\n        boundingRadius,\r\n    };\r\n\r\n    // =======================\r\n    // internal fucntions\r\n    // =======================\r\n\r\n    function generateTorso (): void {\r\n    // this will be used to calculate the normal\r\n        const slope = (radiusTop - radiusBottom) / torsoHeight;\r\n\r\n        // generate positions, normals and uvs\r\n        for (let y = 0; y <= torSegments; y++) {\r\n            const indexRow: number[] = [];\r\n            const lat = y / torSegments;\r\n            const radius = lat * (radiusTop - radiusBottom) + radiusBottom;\r\n\r\n            for (let x = 0; x <= sides; ++x) {\r\n                const u = x / sides;\r\n                const v = lat * torProp + bottomProp;\r\n                const theta = u * arc - (arc / 4);\r\n\r\n                const sinTheta = Math.sin(theta);\r\n                const cosTheta = Math.cos(theta);\r\n\r\n                // vertex\r\n                positions.push(radius * sinTheta);\r\n                positions.push(lat * torsoHeight + torOffset);\r\n                positions.push(radius * cosTheta);\r\n\r\n                // normal\r\n                Vec3.normalize(temp1, Vec3.set(temp2, sinTheta, -slope, cosTheta));\r\n                normals.push(temp1.x);\r\n                normals.push(temp1.y);\r\n                normals.push(temp1.z);\r\n\r\n                // uv\r\n                uvs.push(u, v);\r\n                // save index of vertex in respective row\r\n                indexRow.push(index);\r\n\r\n                // increase index\r\n                ++index;\r\n            }\r\n\r\n            // now save positions of the row in our index array\r\n            indexArray.push(indexRow);\r\n        }\r\n\r\n        // generate indices\r\n        for (let y = 0; y < torSegments; ++y) {\r\n            for (let x = 0; x < sides; ++x) {\r\n                // we use the index array to access the correct indices\r\n                const i1 = indexArray[y][x];\r\n                const i2 = indexArray[y + 1][x];\r\n                const i3 = indexArray[y + 1][x + 1];\r\n                const i4 = indexArray[y][x + 1];\r\n\r\n                // face one\r\n                indices.push(i1);\r\n                indices.push(i4);\r\n                indices.push(i2);\r\n\r\n                // face two\r\n                indices.push(i4);\r\n                indices.push(i3);\r\n                indices.push(i2);\r\n            }\r\n        }\r\n    }\r\n\r\n    function generateBottom (): void {\r\n        for (let lat = 0; lat <= bottomSegments; ++lat) {\r\n            const theta = lat * Math.PI / bottomSegments / 2;\r\n            const sinTheta = Math.sin(theta);\r\n            const cosTheta = -Math.cos(theta);\r\n\r\n            for (let lon = 0; lon <= sides; ++lon) {\r\n                const phi = lon * 2 * Math.PI / sides - Math.PI / 2.0;\r\n                const sinPhi = Math.sin(phi);\r\n                const cosPhi = Math.cos(phi);\r\n\r\n                const x = sinPhi * sinTheta;\r\n                const y = cosTheta;\r\n                const z = cosPhi * sinTheta;\r\n                const u = lon / sides;\r\n                const v = lat / heightSegments;\r\n\r\n                positions.push(x * radiusBottom, y * radiusBottom + bottomOffset, z * radiusBottom);\r\n                normals.push(x, y, z);\r\n                uvs.push(u, v);\r\n\r\n                if ((lat < bottomSegments) && (lon < sides)) {\r\n                    const seg1 = sides + 1;\r\n                    const a = seg1 * lat + lon;\r\n                    const b = seg1 * (lat + 1) + lon;\r\n                    const c = seg1 * (lat + 1) + lon + 1;\r\n                    const d = seg1 * lat + lon + 1;\r\n\r\n                    indices.push(a, d, b);\r\n                    indices.push(d, c, b);\r\n                }\r\n\r\n                ++index;\r\n            }\r\n        }\r\n    }\r\n\r\n    function generateTop (): void {\r\n        for (let lat = 0; lat <= topSegments; ++lat) {\r\n            const theta = lat * Math.PI / topSegments / 2 + Math.PI / 2;\r\n            const sinTheta = Math.sin(theta);\r\n            const cosTheta = -Math.cos(theta);\r\n\r\n            for (let lon = 0; lon <= sides; ++lon) {\r\n                const phi = lon * 2 * Math.PI / sides - Math.PI / 2.0;\r\n                const sinPhi = Math.sin(phi);\r\n                const cosPhi = Math.cos(phi);\r\n\r\n                const x = sinPhi * sinTheta;\r\n                const y = cosTheta;\r\n                const z = cosPhi * sinTheta;\r\n                const u = lon / sides;\r\n                const v = lat / heightSegments + (1 - topProp);\r\n\r\n                positions.push(x * radiusTop, y * radiusTop + topOffset, z * radiusTop);\r\n                normals.push(x, y, z);\r\n                uvs.push(u, v);\r\n\r\n                if ((lat < topSegments) && (lon < sides)) {\r\n                    const seg1 = sides + 1;\r\n                    const a = seg1 * lat + lon + indexArray[torSegments][sides] + 1;\r\n                    const b = seg1 * (lat + 1) + lon + indexArray[torSegments][sides] + 1;\r\n                    const c = seg1 * (lat + 1) + lon + 1 + indexArray[torSegments][sides] + 1;\r\n                    const d = seg1 * lat + lon + 1 + indexArray[torSegments][sides] + 1;\r\n\r\n                    indices.push(a, d, b);\r\n                    indices.push(d, c, b);\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n","/*\r\n Copyright (c) 2020-2023 Xiamen Yaji Software Co., Ltd.\r\n\r\n https://www.cocos.com/\r\n\r\n Permission is hereby granted, free of charge, to any person obtaining a copy\r\n of this software and associated documentation files (the \"Software\"), to deal\r\n in the Software without restriction, including without limitation the rights to\r\n use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\r\n of the Software, and to permit persons to whom the Software is furnished to do so,\r\n subject to the following conditions:\r\n\r\n The above copyright notice and this permission notice shall be included in\r\n all copies or substantial portions of the Software.\r\n\r\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n THE SOFTWARE.\r\n*/\r\n\r\nimport { Vec3 } from '../core';\r\nimport { applyDefaultGeometryOptions, IGeometry, IGeometryOptions } from './define';\r\n\r\n/**\r\n * @en\r\n * The definition of the parameter for building a plane.\r\n * @zh\r\n * 平面参数选项。\r\n */\r\ninterface IPlaneOptions extends RecursivePartial<IGeometryOptions> {\r\n    /**\r\n     * Plane extent on X-axis.\r\n     */\r\n    width: number;\r\n\r\n    /**\r\n     * Plane extent on Z-axis.\r\n     */\r\n    length: number;\r\n\r\n    /**\r\n     * Segment count on X-axis.\r\n     */\r\n    widthSegments: number;\r\n\r\n    /**\r\n     * Segment count on Z-axis.\r\n     */\r\n    lengthSegments: number;\r\n}\r\n\r\n/**\r\n * @zh\r\n * 应用默认的平面参数选项。\r\n * @param options 平面参数选项。\r\n */\r\nfunction applyDefaultPlaneOptions (options?: RecursivePartial<IPlaneOptions>): IPlaneOptions {\r\n    options = applyDefaultGeometryOptions<IPlaneOptions>(options);\r\n    options.width = options.width || 10;\r\n    options.length = options.length || 10;\r\n    options.widthSegments = options.widthSegments || 10;\r\n    options.lengthSegments = options.lengthSegments || 10;\r\n    return options as IPlaneOptions;\r\n}\r\n\r\nconst temp1 = new Vec3(0, 0, 0);\r\nconst temp2 = new Vec3(0, 0, 0);\r\nconst temp3 = new Vec3(0, 0, 0);\r\nconst r = new Vec3(0, 0, 0);\r\nconst c00 = new Vec3(0, 0, 0);\r\nconst c10 = new Vec3(0, 0, 0);\r\nconst c01 = new Vec3(0, 0, 0);\r\n\r\n/**\r\n * @en\r\n * This function generates a plane on XOZ plane with positive Y direction.\r\n * @zh\r\n * 生成一个平面，其位于XOZ平面，方向为Y轴正方向。\r\n * @param options @zh 平面参数选项。@en The optional creation parameters of the plane\r\n */\r\nexport default function plane (options?: IPlaneOptions): IGeometry {\r\n    const normalizedOptions = applyDefaultPlaneOptions(options);\r\n\r\n    const {\r\n        width,\r\n        length,\r\n        widthSegments: uSegments,\r\n        lengthSegments: vSegments,\r\n    } = normalizedOptions;\r\n\r\n    const hw = width * 0.5;\r\n    const hl = length * 0.5;\r\n\r\n    const positions: number[] = [];\r\n    const uvs: number[] = [];\r\n    const indices: number[] = [];\r\n    const minPos = new Vec3(-hw, 0, -hl);\r\n    const maxPos = new Vec3(hw, 0, hl);\r\n    const boundingRadius = Math.sqrt(width * width + length * length);\r\n\r\n    Vec3.set(c00, -hw, 0, hl);\r\n    Vec3.set(c10, hw, 0, hl);\r\n    Vec3.set(c01, -hw, 0, -hl);\r\n\r\n    for (let y = 0; y <= vSegments; y++) {\r\n        for (let x = 0; x <= uSegments; x++) {\r\n            const u = x / uSegments;\r\n            const v = y / vSegments;\r\n\r\n            Vec3.lerp(temp1, c00, c10, u);\r\n            Vec3.lerp(temp2, c00, c01, v);\r\n            Vec3.subtract(temp3, temp2, c00);\r\n            Vec3.add(r, temp1, temp3);\r\n\r\n            positions.push(r.x, r.y, r.z);\r\n            if (normalizedOptions.includeUV) {\r\n                uvs.push(u, v);\r\n            }\r\n\r\n            if ((x < uSegments) && (y < vSegments)) {\r\n                const useg1 = uSegments + 1;\r\n                const a = x + y * useg1;\r\n                const b = x + (y + 1) * useg1;\r\n                const c = (x + 1) + (y + 1) * useg1;\r\n                const d = (x + 1) + y * useg1;\r\n\r\n                indices.push(a, d, b);\r\n                indices.push(d, c, b);\r\n            }\r\n        }\r\n    }\r\n\r\n    const result: IGeometry = {\r\n        positions,\r\n        indices,\r\n        minPos,\r\n        maxPos,\r\n        boundingRadius,\r\n    };\r\n\r\n    if (normalizedOptions.includeNormal) {\r\n        const nVertex = (vSegments + 1) * (uSegments + 1);\r\n        const normals = new Array<number>(3 * nVertex);\r\n        result.normals = normals;\r\n        for (let i = 0; i < nVertex; ++i) {\r\n            normals[i * 3 + 0] = 0;\r\n            normals[i * 3 + 1] = 1;\r\n            normals[i * 3 + 2] = 0;\r\n        }\r\n    }\r\n\r\n    if (normalizedOptions.includeUV) {\r\n        result.uvs = uvs;\r\n    }\r\n\r\n    return result;\r\n}\r\n"],"names":["applyDefaultGeometryOptions","options","undefined","includeNormal","includeUV","ws","widthSegments","hs","heightSegments","ls","lengthSegments","hw","width","hh","height","hl","length","corners","Vec3","set","c0","c1","c2","c3","c4","c5","c6","c7","faceAxes","faceNormals","faceTangents","positions","normals","uvs","tangents","indices","minPos","maxPos","boundingRadius","Math","sqrt","_buildPlane","side","uSegments","vSegments","u","v","ix","iy","offset","faceAxe","faceNormal","faceTangent","lerp","temp1","temp2","subtract","temp3","add","r","push","x","y","z","useg1","a","b","c","d","radiusTop","radiusBottom","opts","halfHeight","radialSegments","capped","arc","PI","cntCap","vertCount","indexCount","Array","maxRadius","max","index","indexOffset","indexArray","slope","sign","indexRow","radius","theta","sinTheta","sin","cosTheta","cos","normalize","i1","i2","i3","i4","generateTorso","generateCap","top","centerIndexStart","centerIndexEnd","i","torsoHeight","sides","bottomProp","torProp","topProp","bottomSegments","floor","topSegments","torSegments","topOffset","torOffset","bottomOffset","lat","lon","phi","seg1","generateBottom","generateTop","normalizedOptions","applyDefaultPlaneOptions","c00","c10","c01","result","nVertex"],"mappings":"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"}