{"version":3,"file":"graphics.js","sources":["../../../cocos/2d/assembler/graphics/webgl/earcut.ts","../../../cocos/2d/assembler/graphics/webgl/graphics-assembler.ts","../../../cocos/2d/assembler/graphics/webgl/index.ts","../../../exports/graphics.ts"],"sourcesContent":["/*\r\n Copyright (c) 2017-2023 Xiamen Yaji Software Co., Ltd.\r\n\r\n http://www.cocos.com\r\n\r\n Permission is hereby granted, free of charge, to any person obtaining a copy\r\n of this software and associated documentation files (the \"Software\"), to deal\r\n in the Software without restriction, including without limitation the rights to\r\n use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\r\n of the Software, and to permit persons to whom the Software is furnished to do so,\r\n subject to the following conditions:\r\n\r\n The above copyright notice and this permission notice shall be included in\r\n all copies or substantial portions of the Software.\r\n\r\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n THE SOFTWARE.\r\n*/\r\n\r\n/** @mangle */\r\nclass Aim {\r\n    // vertex index in coordinates array\r\n    public declare i: number;\r\n\r\n    // vertex coordinates\r\n    public declare x: number;\r\n    public declare y: number;\r\n\r\n    // previous and next vertex nodes in a polygon ring\r\n    public prev: Aim | null = null;\r\n    public next: Aim | null = null;\r\n\r\n    // z-order curve value\r\n    public z: number = null as any;\r\n\r\n    // previous and next nodes in z-order\r\n    public prevZ: Aim | null = null;\r\n    public nextZ: Aim | null = null;\r\n\r\n    // indicates whether this is a steiner point\r\n    public steiner = false;\r\n\r\n    constructor (i: number, x: number, y: number) {\r\n        this.i = i;\r\n        this.x = x;\r\n        this.y = y;\r\n    }\r\n}\r\n\r\n// create a circular doubly linked list from polygon points in the specified winding order\r\nfunction linkedList (datas: number[], start: number, end: number, dim: number, clockwise: boolean): Aim | null {\r\n    let i = 0;\r\n    let last: Aim | null = null;\r\n\r\n    if (clockwise === (signedArea(datas, start, end, dim) > 0)) {\r\n        for (i = start; i < end; i += dim) {\r\n            last = insertNode(i, datas[i], datas[i + 1], last);\r\n        }\r\n    } else {\r\n        for (i = end - dim; i >= start; i -= dim) {\r\n            last = insertNode(i, datas[i], datas[i + 1], last);\r\n        }\r\n    }\r\n\r\n    if (last && equals(last, last.next!)) {\r\n        removeNode(last);\r\n        last = last.next;\r\n    }\r\n\r\n    return last;\r\n}\r\n\r\n// eliminate colinear or duplicate points\r\nfunction filterPoints (start: Aim | null, end: Aim | null = null): Aim | null {\r\n    if (!start) {\r\n        return start;\r\n    }\r\n\r\n    if (!end) {\r\n        end = start;\r\n    }\r\n\r\n    let p = start;\r\n    let again = false;\r\n    do {\r\n        again = false;\r\n\r\n        if (!p.steiner && (equals(p, p.next!) || area(p.prev!, p, p.next!) === 0)) {\r\n            removeNode(p);\r\n            p = end = p.prev!;\r\n            if (p === p.next) {\r\n                return null;\r\n            }\r\n            again = true;\r\n        } else {\r\n            p = p.next!;\r\n        }\r\n    } while (again || p !== end);\r\n\r\n    return end;\r\n}\r\n\r\n// main ear slicing loop which triangulates a polygon (given as a linked list)\r\nfunction earcutLinked (ear: Aim | null, triangles: number[], dim: number, minX: number, minY: number, size: number, pass = 0): void {\r\n    if (!ear) {\r\n        return;\r\n    }\r\n\r\n    // interlink polygon nodes in z-order\r\n    if (!pass && size) {\r\n        indexCurve(ear, minX, minY, size);\r\n    }\r\n\r\n    let stop: Aim | null = ear;\r\n    let prev: Aim | null = null;\r\n    let next: Aim | null = null;\r\n\r\n    // iterate through ears, slicing them one by one\r\n    while (ear!.prev !== ear!.next) {\r\n        prev = ear!.prev!;\r\n        next = ear!.next!;\r\n\r\n        if (size ? isEarHashed(ear!, minX, minY, size) : isEar(ear!)) {\r\n            // cut off the triangle\r\n            triangles.push(prev.i / dim);\r\n            triangles.push(ear!.i / dim);\r\n            triangles.push(next.i / dim);\r\n\r\n            removeNode(ear!);\r\n\r\n            // skipping the next vertices leads to less sliver triangles\r\n            ear = next.next;\r\n            stop = next.next;\r\n\r\n            continue;\r\n        }\r\n\r\n        ear = next;\r\n\r\n        // if we looped through the whole remaining polygon and can't find any more ears\r\n        if (ear === stop) {\r\n            // try filtering points and slicing again\r\n            if (!pass) {\r\n                earcutLinked(filterPoints(ear), triangles, dim, minX, minY, size, 1);\r\n\r\n            // if this didn't work, try curing all small self-intersections locally\r\n            } else if (pass === 1) {\r\n                ear = cureLocalIntersections(ear, triangles, dim);\r\n                earcutLinked(ear, triangles, dim, minX, minY, size, 2);\r\n\r\n            // as a last resort, try splitting the remaining polygon into two\r\n            } else if (pass === 2) {\r\n                splitEarcut(ear, triangles, dim, minX, minY, size);\r\n            }\r\n\r\n            break;\r\n        }\r\n    }\r\n}\r\n\r\n// check whether a polygon node forms a valid ear with adjacent nodes\r\nfunction isEar (ear: Aim): boolean {\r\n    const a = ear.prev!;\r\n    const b = ear;\r\n    const c = ear.next!;\r\n\r\n    if (area(a, b, c) >= 0) { return false; } // reflex, can't be an ear\r\n\r\n    // now make sure we don't have other points inside the potential ear\r\n    let p = ear.next!.next!;\r\n\r\n    while (p !== ear.prev) {\r\n        if (pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y)\r\n            && area(p.prev!, p, p.next!) >= 0) { return false; }\r\n        p = p.next!;\r\n    }\r\n\r\n    return true;\r\n}\r\n\r\nfunction isEarHashed (ear: Aim, minX: number, minY: number, size: number): boolean {\r\n    const a = ear.prev!;\r\n    const b = ear;\r\n    const c = ear.next!;\r\n\r\n    if (area(a, b, c) >= 0) { return false; } // reflex, can't be an ear\r\n\r\n    // triangle bbox; min & max are calculated like this for speed\r\n    const minTX = a.x < b.x ? (a.x < c.x ? a.x : c.x) : (b.x < c.x ? b.x : c.x);\r\n    const minTY = a.y < b.y ? (a.y < c.y ? a.y : c.y) : (b.y < c.y ? b.y : c.y);\r\n    const maxTX = a.x > b.x ? (a.x > c.x ? a.x : c.x) : (b.x > c.x ? b.x : c.x);\r\n    const maxTY = a.y > b.y ? (a.y > c.y ? a.y : c.y) : (b.y > c.y ? b.y : c.y);\r\n\r\n    // z-order range for the current triangle bbox;\r\n    const minZ = zOrder(minTX, minTY, minX, minY, size);\r\n    const maxZ = zOrder(maxTX, maxTY, minX, minY, size);\r\n\r\n    // first look for points inside the triangle in increasing z-order\r\n    let p = ear.nextZ;\r\n\r\n    while (p && p.z <= maxZ) {\r\n        if (p !== ear.prev && p !== ear.next\r\n            && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y)\r\n            && area(p.prev!, p, p.next!) >= 0) { return false; }\r\n        p = p.nextZ;\r\n    }\r\n\r\n    // then look for points in decreasing z-order\r\n    p = ear.prevZ;\r\n\r\n    while (p && p.z >= minZ) {\r\n        if (p !== ear.prev && p !== ear.next\r\n            && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y)\r\n            && area(p.prev!, p, p.next!) >= 0) {\r\n            return false;\r\n        }\r\n\r\n        p = p.prevZ;\r\n    }\r\n\r\n    return true;\r\n}\r\n\r\n// go through all polygon nodes and cure small local self-intersections\r\nfunction cureLocalIntersections (start: Aim, triangles: number[], dim: number): Aim {\r\n    let p = start;\r\n    do {\r\n        const a = p.prev!;\r\n        const b = p.next!.next!;\r\n\r\n        if (!equals(a, b) && intersects(a, p, p.next!, b) && locallyInside(a, b) && locallyInside(b, a)) {\r\n            triangles.push(a.i / dim);\r\n            triangles.push(p.i / dim);\r\n            triangles.push(b.i / dim);\r\n\r\n            // remove two nodes involved\r\n            removeNode(p);\r\n            removeNode(p.next!);\r\n\r\n            p = start = b;\r\n        }\r\n        p = p.next!;\r\n    } while (p !== start);\r\n\r\n    return p;\r\n}\r\n\r\n// try splitting polygon into two and triangulate them independently\r\nfunction splitEarcut (start: Aim | null, triangles: number[], dim: number, minX: number, minY: number, size: number): void {\r\n    // look for a valid diagonal that divides the polygon into two\r\n    let a = start!;\r\n    do {\r\n        let b = a.next!.next;\r\n        while (b !== a.prev) {\r\n            if (a.i !== b!.i && isValidDiagonal(a, b!)) {\r\n                // split the polygon in two by the diagonal\r\n                let c = splitPolygon(a, b!);\r\n\r\n                // filter colinear points around the cuts\r\n                a = filterPoints(a, a.next)!;\r\n                c = filterPoints(c, c.next)!;\r\n\r\n                // run earcut on each half\r\n                earcutLinked(a, triangles, dim, minX, minY, size);\r\n                earcutLinked(c, triangles, dim, minX, minY, size);\r\n                return;\r\n            }\r\n            b = b!.next;\r\n        }\r\n        a = a.next!;\r\n    } while (a !== start);\r\n}\r\n\r\n// link every hole into the outer loop, producing a single-ring polygon without holes\r\nfunction eliminateHoles (datas: number[], holeIndices: number[], outerNode: Aim | null, dim: number): Aim | null {\r\n    const queue: Aim[] = [];\r\n    let i = 0;\r\n    let len = 0;\r\n    let start = 0;\r\n    let end = 0;\r\n    let list: Aim | null = null;\r\n\r\n    for (i = 0, len = holeIndices.length; i < len; i++) {\r\n        start = holeIndices[i] * dim;\r\n        end = i < len - 1 ? holeIndices[i + 1] * dim : datas.length;\r\n        list = linkedList(datas, start, end, dim, false);\r\n        if (!list) {\r\n            continue;\r\n        }\r\n        if (list === list.next) {\r\n            list.steiner = true;\r\n        }\r\n\r\n        queue.push(getLeftmost(list));\r\n    }\r\n\r\n    queue.sort(compareX);\r\n\r\n    if (!outerNode) {\r\n        return outerNode;\r\n    }\r\n\r\n    // process holes from left to right\r\n    for (i = 0; i < queue.length; i++) {\r\n        eliminateHole(queue[i], outerNode);\r\n        outerNode = filterPoints(outerNode, outerNode!.next);\r\n    }\r\n\r\n    return outerNode;\r\n}\r\n\r\nfunction compareX (a, b): number {\r\n    return a.x - b.x;\r\n}\r\n\r\n// find a bridge between vertices that connects hole with an outer ring and link it\r\nfunction eliminateHole (hole: Aim, outerNode: Aim | null): void {\r\n    outerNode = findHoleBridge(hole, outerNode!);\r\n    if (outerNode) {\r\n        const b = splitPolygon(outerNode, hole);\r\n        filterPoints(b, b.next);\r\n    }\r\n}\r\n\r\n// David Eberly's algorithm for finding a bridge between hole and outer polygon\r\nfunction findHoleBridge (hole: Aim, outerNode: Aim): Aim | null {\r\n    let p = outerNode;\r\n    const hx = hole.x;\r\n    const hy = hole.y;\r\n    let qx = -Infinity;\r\n    let m: Aim | null = null;\r\n\r\n    // find a segment intersected by a ray from the hole's leftmost point to the left;\r\n    // segment's endpoint with lesser x will be potential connection point\r\n    do {\r\n        if (hy <= p.y && hy >= p.next!.y) {\r\n            const x = p.x + (hy - p.y) * (p.next!.x - p.x) / (p.next!.y - p.y);\r\n            if (x <= hx && x > qx) {\r\n                qx = x;\r\n                if (x === hx) {\r\n                    if (hy === p.y) { return p; }\r\n                    if (hy === p.next!.y) { return p.next; }\r\n                }\r\n                m = p.x < p.next!.x ? p : p.next!;\r\n            }\r\n        }\r\n        p = p.next!;\r\n    } while (p !== outerNode);\r\n\r\n    if (!m) {\r\n        return null;\r\n    }\r\n\r\n    if (hx === qx) {\r\n        return m.prev;\r\n    } // hole touches outer segment; pick lower endpoint\r\n\r\n    // look for points inside the triangle of hole point, segment intersection and endpoint;\r\n    // if there are no points found, we have a valid connection;\r\n    // otherwise choose the point of the minimum angle with the ray as connection point\r\n\r\n    const stop = m;\r\n    const mx = m.x;\r\n    const my = m.y;\r\n    let tanMin = Infinity;\r\n    let tan;\r\n\r\n    p = m.next!;\r\n\r\n    while (p !== stop) {\r\n        if (hx >= p.x && p.x >= mx\r\n                && pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {\r\n            tan = Math.abs(hy - p.y) / (hx - p.x); // tangential\r\n\r\n            if ((tan < tanMin || (tan === tanMin && p.x > m.x)) && locallyInside(p, hole)) {\r\n                m = p;\r\n                tanMin = tan;\r\n            }\r\n        }\r\n\r\n        p = p.next!;\r\n    }\r\n\r\n    return m;\r\n}\r\n\r\n// interlink polygon nodes in z-order\r\nfunction indexCurve (start: Aim, minX: number, minY: number, size: number): void {\r\n    let p = start;\r\n    do {\r\n        if (p.z === null) {\r\n            p.z = zOrder(p.x, p.y, minX, minY, size);\r\n        }\r\n\r\n        p.prevZ = p.prev;\r\n        p.nextZ = p.next;\r\n        p = p.next!;\r\n    } while (p !== start);\r\n\r\n    p.prevZ!.nextZ = null;\r\n    p.prevZ = null;\r\n\r\n    sortLinked(p);\r\n}\r\n\r\n// Simon Tatham's linked list merge sort algorithm\r\n// http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html\r\nfunction sortLinked (list: Aim | null): Aim | null {\r\n    let i = 0;\r\n    let p: Aim | null = null;\r\n    let q: Aim | null = null;\r\n    let e: Aim | null = null;\r\n    let tail: Aim | null = null;\r\n    let numMerges = 0;\r\n    let pSize = 0;\r\n    let qSize = 0;\r\n    let inSize = 1;\r\n\r\n    do {\r\n        p = list;\r\n        list = null;\r\n        tail = null;\r\n        numMerges = 0;\r\n\r\n        while (p) {\r\n            numMerges++;\r\n            q = p;\r\n            pSize = 0;\r\n            for (i = 0; i < inSize; i++) {\r\n                pSize++;\r\n                q = q.nextZ;\r\n                if (!q) { break; }\r\n            }\r\n\r\n            qSize = inSize;\r\n\r\n            while (pSize > 0 || (qSize > 0 && q)) {\r\n                if (pSize === 0) {\r\n                    e = q;\r\n                    q = q!.nextZ;\r\n                    qSize--;\r\n                } else if (qSize === 0 || !q) {\r\n                    e = p;\r\n                    p = p!.nextZ;\r\n                    pSize--;\r\n                } else if (p!.z <= q.z) {\r\n                    e = p;\r\n                    p = p!.nextZ;\r\n                    pSize--;\r\n                } else {\r\n                    e = q;\r\n                    q = q.nextZ;\r\n                    qSize--;\r\n                }\r\n\r\n                if (tail) { tail.nextZ = e; } else { list = e; }\r\n\r\n                e!.prevZ = tail;\r\n                tail = e;\r\n            }\r\n\r\n            p = q;\r\n        }\r\n\r\n        tail!.nextZ = null;\r\n        inSize *= 2;\r\n    } while (numMerges > 1);\r\n\r\n    return list;\r\n}\r\n\r\n// z-order of a point given coords and size of the data bounding box\r\nfunction zOrder (x: number, y: number, minX: number, minY: number, size: number): number {\r\n    // coords are transformed into non-negative 15-bit integer range\r\n    x = 32767 * (x - minX) / size;\r\n    y = 32767 * (y - minY) / size;\r\n\r\n    x = (x | (x << 8)) & 0x00FF00FF;\r\n    x = (x | (x << 4)) & 0x0F0F0F0F;\r\n    x = (x | (x << 2)) & 0x33333333;\r\n    x = (x | (x << 1)) & 0x55555555;\r\n\r\n    y = (y | (y << 8)) & 0x00FF00FF;\r\n    y = (y | (y << 4)) & 0x0F0F0F0F;\r\n    y = (y | (y << 2)) & 0x33333333;\r\n    y = (y | (y << 1)) & 0x55555555;\r\n\r\n    return x | (y << 1);\r\n}\r\n\r\n// find the leftmost node of a polygon ring\r\nfunction getLeftmost (start: Aim): Aim {\r\n    let p = start;\r\n    let leftmost = start;\r\n    do {\r\n        if (p.x < leftmost.x) {\r\n            leftmost = p;\r\n        }\r\n\r\n        p = p.next!;\r\n    } while (p !== start);\r\n\r\n    return leftmost;\r\n}\r\n\r\n// check if a point lies within a convex triangle\r\nfunction pointInTriangle (ax: number, ay: number, bx: number, by: number, cx: number, cy: number, px: number, py: number): boolean {\r\n    return (cx - px) * (ay - py) - (ax - px) * (cy - py) >= 0\r\n           && (ax - px) * (by - py) - (bx - px) * (ay - py) >= 0\r\n           && (bx - px) * (cy - py) - (cx - px) * (by - py) >= 0;\r\n}\r\n\r\n// check if a diagonal between two polygon nodes is valid (lies in polygon interior)\r\nfunction isValidDiagonal (a: Aim, b: Aim): boolean {\r\n    return a.next!.i !== b.i && a.prev!.i !== b.i && !intersectsPolygon(a, b)\r\n           && locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b);\r\n}\r\n\r\n// signed area of a triangle\r\nfunction area (p: Aim, q: Aim, r: Aim): number {\r\n    return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);\r\n}\r\n\r\n// check if two points are equal\r\nfunction equals (p1: Aim, p2: Aim): boolean {\r\n    return p1.x === p2.x && p1.y === p2.y;\r\n}\r\n\r\n// check if two segments intersect\r\nfunction intersects (p1: Aim, q1: Aim, p2: Aim, q2: Aim): boolean {\r\n    if ((equals(p1, q1) && equals(p2, q2))\r\n        || (equals(p1, q2) && equals(p2, q1))) {\r\n        return true;\r\n    }\r\n\r\n    return area(p1, q1, p2) > 0 !== area(p1, q1, q2) > 0\r\n           && area(p2, q2, p1) > 0 !== area(p2, q2, q1) > 0;\r\n}\r\n\r\n// check if a polygon diagonal intersects any polygon segments\r\nfunction intersectsPolygon (a: Aim, b: Aim): boolean {\r\n    let p = a;\r\n    do {\r\n        if (p.i !== a.i && p.next!.i !== a.i && p.i !== b.i && p.next!.i !== b.i\r\n                && intersects(p, p.next!, a, b)) { return true; }\r\n        p = p.next!;\r\n    } while (p !== a);\r\n\r\n    return false;\r\n}\r\n\r\n// check if a polygon diagonal is locally inside the polygon\r\nfunction locallyInside (a: Aim, b: Aim): boolean {\r\n    return area(a.prev!, a, a.next!) < 0\r\n        ? area(a, b, a.next!) >= 0 && area(a, a.prev!, b) >= 0\r\n        : area(a, b, a.prev!) < 0 || area(a, a.next!, b) < 0;\r\n}\r\n\r\n// check if the middle point of a polygon diagonal is inside the polygon\r\nfunction middleInside (a: Aim, b: Aim): boolean {\r\n    let p = a;\r\n    let inside = false;\r\n    const px = (a.x + b.x) / 2;\r\n    const py = (a.y + b.y) / 2;\r\n    do {\r\n        if (((p.y > py) !== (p.next!.y > py)) && (px < (p.next!.x - p.x) * (py - p.y) / (p.next!.y - p.y) + p.x)) {\r\n            inside = !inside;\r\n        }\r\n        p = p.next!;\r\n    } while (p !== a);\r\n\r\n    return inside;\r\n}\r\n\r\n// link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;\r\n// if one belongs to the outer ring and another to a hole, it merges it into a single ring\r\nfunction splitPolygon (a: Aim, b: Aim): Aim {\r\n    const a2 = new Aim(a.i, a.x, a.y);\r\n    const b2 = new Aim(b.i, b.x, b.y);\r\n    const an = a.next!;\r\n    const bp = b.prev!;\r\n\r\n    a.next = b;\r\n    b.prev = a;\r\n\r\n    a2.next = an;\r\n    an.prev = a2;\r\n\r\n    b2.next = a2;\r\n    a2.prev = b2;\r\n\r\n    bp.next = b2;\r\n    b2.prev = bp;\r\n\r\n    return b2;\r\n}\r\n\r\n// create a node and optionally link it with previous one (in a circular doubly linked list)\r\nfunction insertNode (i: number, x: number, y: number, last: Aim | null): Aim {\r\n    const p = new Aim(i, x, y);\r\n\r\n    if (!last) {\r\n        p.prev = p;\r\n        p.next = p;\r\n    } else {\r\n        p.next = last.next;\r\n        p.prev = last;\r\n        last.next!.prev = p;\r\n        last.next = p;\r\n    }\r\n\r\n    return p;\r\n}\r\n\r\nfunction removeNode (p: Aim): void {\r\n    p.next!.prev = p.prev;\r\n    p.prev!.next = p.next;\r\n\r\n    if (p.prevZ) {\r\n        p.prevZ.nextZ = p.nextZ;\r\n    }\r\n\r\n    if (p.nextZ) {\r\n        p.nextZ.prevZ = p.prevZ;\r\n    }\r\n}\r\n\r\nfunction signedArea (datas: number[], start: number, end: number, dim: number): number {\r\n    let sum = 0;\r\n    for (let i = start, j = end - dim; i < end; i += dim) {\r\n        sum += (datas[j] - datas[i]) * (datas[i + 1] + datas[j + 1]);\r\n        j = i;\r\n    }\r\n    return sum;\r\n}\r\n\r\nexport function earcut (datas: number[], holeIndices: number[] | null, dim: number): number[] {\r\n    dim = dim || 3;\r\n\r\n    const hasHoles = holeIndices ? holeIndices.length : 0;\r\n    const outerLen = hasHoles ? holeIndices![0] * dim : datas.length;\r\n    let outerNode = linkedList(datas, 0, outerLen, dim, true);\r\n    const triangles: number[] = [];\r\n\r\n    if (!outerNode) {\r\n        return triangles;\r\n    }\r\n\r\n    let minX = 0;\r\n    let minY = 0;\r\n    let maxX = 0;\r\n    let maxY = 0;\r\n    let x = 0;\r\n    let y = 0;\r\n    let size = 0;\r\n\r\n    if (hasHoles) {\r\n        outerNode = eliminateHoles(datas, holeIndices!, outerNode, dim);\r\n    }\r\n\r\n    // if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox\r\n    if (datas.length > 80 * dim) {\r\n        minX = maxX = datas[0];\r\n        minY = maxY = datas[1];\r\n\r\n        for (let i = dim; i < outerLen; i += dim) {\r\n            x = datas[i];\r\n            y = datas[i + 1];\r\n            if (x < minX) { minX = x; }\r\n            if (y < minY) { minY = y; }\r\n            if (x > maxX) { maxX = x; }\r\n            if (y > maxY) { maxY = y; }\r\n        }\r\n\r\n        // minX, minY and size are later used to transform coords into integers for z-order calculation\r\n        size = Math.max(maxX - minX, maxY - minY);\r\n    }\r\n\r\n    earcutLinked(outerNode, triangles, dim, minX, minY, size);\r\n\r\n    return triangles;\r\n}\r\n\r\n// // return a percentage difference between the polygon area and its triangulation area;\r\n// // used to verify correctness of triangulation\r\n// earcut.deviation = function (data, holeIndices, dim, triangles) {\r\n//     const hasHoles = holeIndices && holeIndices.length;\r\n//     const outerLen = hasHoles ? holeIndices[0] * dim : data.length;\r\n\r\n//     let polygonArea = Math.abs(signedArea(data, 0, outerLen, dim));\r\n//     if (hasHoles) {\r\n//         for (let i = 0, len = holeIndices.length; i < len; i++) {\r\n//             const start = holeIndices[i] * dim;\r\n//             const end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;\r\n//             polygonArea -= Math.abs(signedArea(data, start, end, dim));\r\n//         }\r\n//     }\r\n\r\n//     let trianglesArea = 0;\r\n//     for (i = 0; i < triangles.length; i += 3) {\r\n//         const a = triangles[i] * dim;\r\n//         const b = triangles[i + 1] * dim;\r\n//         const c = triangles[i + 2] * dim;\r\n//         trianglesArea += Math.abs(\r\n//             (data[a] - data[c]) * (data[b + 1] - data[a + 1]) -\r\n//             (data[a] - data[b]) * (data[c + 1] - data[a + 1]));\r\n//     }\r\n\r\n//     return polygonArea === 0 && trianglesArea === 0 ? 0 :\r\n//         Math.abs((trianglesArea - polygonArea) / polygonArea);\r\n// };\r\n\r\n// // turn a polygon in a multi-dimensional array form (e.g. as in GeoJSON) into a form Earcut accepts\r\n// earcut.flatten = function (data) {\r\n//     let dim = data[0][0].length,\r\n//         result = {vertices: [], holes: [], dimensions: dim},\r\n//         holeIndex = 0;\r\n\r\n//     for (let i = 0; i < data.length; i++) {\r\n//         for (let j = 0; j < data[i].length; j++) {\r\n//             for (let d = 0; d < dim; d++) { result.vertices.push(data[i][j][d]); }\r\n//         }\r\n//         if (i > 0) {\r\n//             holeIndex += data[i - 1].length;\r\n//             result.holes.push(holeIndex);\r\n//         }\r\n//     }\r\n//     return result;\r\n// };\r\n","/*\r\n Copyright (c) 2017-2023 Xiamen Yaji Software Co., Ltd.\r\n\r\n http://www.cocos.com\r\n\r\n Permission is hereby granted, free of charge, to any person obtaining a copy\r\n of this software and associated documentation files (the \"Software\"), to deal\r\n in the Software without restriction, including without limitation the rights to\r\n use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\r\n of the Software, and to permit persons to whom the Software is furnished to do so,\r\n subject to the following conditions:\r\n\r\n The above copyright notice and this permission notice shall be included in\r\n all copies or substantial portions of the Software.\r\n\r\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n THE SOFTWARE.\r\n*/\r\nimport { JSB } from 'internal:constants';\r\nimport { Color, Vec3 } from '../../../../core';\r\nimport { IAssembler } from '../../../renderer/base';\r\nimport { MeshRenderData } from '../../../renderer/render-data';\r\nimport { IBatcher } from '../../../renderer/i-batcher';\r\nimport { Graphics } from '../../../components/graphics';\r\nimport { LineCap, LineJoin, PointFlags } from '../types';\r\nimport { earcut as Earcut } from './earcut';\r\nimport { Impl, Point } from './impl';\r\n\r\nconst MAX_VERTEX = 65535;\r\nconst MAX_INDICES = MAX_VERTEX * 2;\r\n\r\nconst PI = Math.PI;\r\nconst min = Math.min;\r\nconst max = Math.max;\r\nconst ceil = Math.ceil;\r\nconst acos = Math.acos;\r\nconst cos = Math.cos;\r\nconst sin = Math.sin;\r\nconst atan2 = Math.atan2;\r\n\r\nconst attrBytes = 8;\r\n\r\nlet _renderData: MeshRenderData | null = null;\r\nlet _impl: Impl | null = null;\r\nconst _curColor = new Color();\r\n\r\nconst vec3_temps: Vec3[] = [];\r\nfor (let i = 0; i < 4; i++) {\r\n    vec3_temps.push(new Vec3());\r\n}\r\n\r\nfunction curveDivs (r: number, arc: number, tol: number): number {\r\n    const da = acos(r / (r + tol)) * 2.0;\r\n    return max(2, ceil(arc / da));\r\n}\r\n\r\nfunction clamp (v: number, minNum: number, maxNum: number): number {\r\n    if (v < minNum) {\r\n        return minNum;\r\n    } else if (v > maxNum) {\r\n        return maxNum;\r\n    }\r\n    return v;\r\n}\r\n\r\n/**\r\n * graphics 组装器\r\n * 可通过 `UI.graphicsAssembler` 获取该组装器。\r\n */\r\nexport class GraphicsAssembler implements IAssembler {\r\n    updateRenderData (graphics: Graphics): void {\r\n        if (JSB) {\r\n            if (graphics.renderData) {\r\n                graphics.renderData.material = graphics.getMaterialInstance(0);\r\n            }\r\n        }\r\n    }\r\n\r\n    private getRenderData (graphics: Graphics, vertexCount: number): MeshRenderData | null {\r\n        if (!_impl) {\r\n            return null;\r\n        }\r\n\r\n        const renderDataList = _impl.getRenderDataList();\r\n        let renderData = renderDataList[_impl.dataOffset];\r\n        if (!renderData) {\r\n            return null;\r\n        }\r\n\r\n        let meshBuffer = renderData;\r\n\r\n        const maxVertexCount = meshBuffer ? meshBuffer.vertexStart + vertexCount : 0;\r\n        if (maxVertexCount > MAX_VERTEX || maxVertexCount * 3 > MAX_INDICES) {\r\n            ++_impl.dataOffset;\r\n\r\n            if (_impl.dataOffset < renderDataList.length) {\r\n                renderData = renderDataList[_impl.dataOffset];\r\n            } else {\r\n                renderData = _impl.requestRenderData();\r\n                renderDataList[_impl.dataOffset] = renderData;\r\n            }\r\n\r\n            meshBuffer = renderData;\r\n        }\r\n\r\n        if (meshBuffer && meshBuffer.vertexCount < maxVertexCount) {\r\n            meshBuffer.request(vertexCount, vertexCount * 3);\r\n        }\r\n\r\n        return renderData;\r\n    }\r\n\r\n    stroke (graphics: Graphics): void {\r\n        Color.copy(_curColor, graphics.strokeColor);\r\n        // graphics.node.getWorldMatrix(_currMatrix);\r\n        if (!graphics.impl) {\r\n            return;\r\n        }\r\n\r\n        this._flattenPaths(graphics.impl);\r\n        this._expandStroke(graphics);\r\n\r\n        graphics.impl.updatePathOffset = true;\r\n\r\n        this.end(graphics);\r\n    }\r\n\r\n    fill (graphics: Graphics): void {\r\n        Color.copy(_curColor, graphics.fillColor);\r\n        // graphics.node.getWorldMatrix(_currMatrix);\r\n\r\n        this._expandFill(graphics);\r\n        if (graphics.impl) {\r\n            graphics.impl.updatePathOffset = true;\r\n        }\r\n\r\n        this.end(graphics);\r\n    }\r\n\r\n    end (graphics: Graphics): void {\r\n        graphics._markForUpdateRenderData();\r\n    }\r\n\r\n    private _expandStroke (graphics: Graphics): void {\r\n        const w = graphics.lineWidth * 0.5;\r\n        const lineCap = graphics.lineCap;\r\n        const lineJoin = graphics.lineJoin;\r\n        const miterLimit = graphics.miterLimit;\r\n\r\n        _impl = graphics.impl;\r\n\r\n        if (!_impl) {\r\n            return;\r\n        }\r\n\r\n        const nCap = curveDivs(w, PI, _impl.tessTol);\r\n\r\n        this._calculateJoins(_impl, w, lineJoin, miterLimit);\r\n\r\n        const paths = _impl.paths;\r\n\r\n        // Calculate max vertex usage.\r\n        let vertexCount = 0;\r\n        for (let i = _impl.pathOffset, l = _impl.pathLength; i < l; i++) {\r\n            const path = paths[i];\r\n            const pointsLength = path.points.length;\r\n\r\n            if (lineJoin === LineJoin.ROUND) {\r\n                vertexCount += (pointsLength + path.bevel * (nCap + 2) + 1) * 2;\r\n            } else {\r\n                vertexCount += (pointsLength + path.bevel * 5 + 1) * 2;\r\n            } // plus one for loop\r\n\r\n            if (!path.closed) {\r\n                // space for caps\r\n                if (lineCap === LineCap.ROUND) {\r\n                    vertexCount += (nCap * 2 + 2) * 2;\r\n                } else {\r\n                    vertexCount += (3 + 3) * 2;\r\n                }\r\n            }\r\n        }\r\n\r\n        const meshBuffer: MeshRenderData | null = _renderData = this.getRenderData(graphics, vertexCount);\r\n        if (!meshBuffer) {\r\n            return;\r\n        }\r\n        const vData = meshBuffer.vData;\r\n        const iData = meshBuffer.iData;\r\n\r\n        for (let i = _impl.pathOffset, l = _impl.pathLength; i < l; i++) {\r\n            const path = paths[i];\r\n            const pts = path.points;\r\n            const pointsLength = pts.length;\r\n            const offset = meshBuffer.vertexStart;\r\n\r\n            let p0: Point;\r\n            let p1: Point;\r\n            let start = 0;\r\n            let end = 0;\r\n            const loop = path.closed;\r\n            if (loop) {\r\n                // Looping\r\n                p0 = pts[pointsLength - 1];\r\n                p1 = pts[0];\r\n                start = 0;\r\n                end = pointsLength;\r\n            } else {\r\n                // Add cap\r\n                p0 = pts[0];\r\n                p1 = pts[1];\r\n                start = 1;\r\n                end = pointsLength - 1;\r\n            }\r\n\r\n            p1 = p1 || p0;\r\n\r\n            if (!loop) {\r\n                // Add cap\r\n                const dPos = new Point(p1.x, p1.y);\r\n                dPos.subtract(p0);\r\n                dPos.normalize();\r\n\r\n                const dx = dPos.x;\r\n                const dy = dPos.y;\r\n\r\n                if (lineCap === LineCap.BUTT) {\r\n                    this._buttCapStart(p0, dx, dy, w, 0);\r\n                } else if (lineCap === LineCap.SQUARE) {\r\n                    this._buttCapStart(p0, dx, dy, w, w);\r\n                } else if (lineCap === LineCap.ROUND) {\r\n                    this._roundCapStart(p0, dx, dy, w, nCap);\r\n                }\r\n            }\r\n\r\n            for (let j = start; j < end; ++j) {\r\n                if (lineJoin === LineJoin.ROUND) {\r\n                    this._roundJoin(p0, p1, w, w, nCap);\r\n                } else if ((p1.flags & (PointFlags.PT_BEVEL | PointFlags.PT_INNERBEVEL)) !== 0) {\r\n                    this._bevelJoin(p0, p1, w, w);\r\n                } else {\r\n                    this._vSet(p1.x + p1.dmx * w, p1.y + p1.dmy * w, 1);\r\n                    this._vSet(p1.x - p1.dmx * w, p1.y - p1.dmy * w, -1);\r\n                }\r\n\r\n                p0 = p1;\r\n                p1 = pts[j + 1];\r\n            }\r\n\r\n            if (loop) {\r\n                // Loop it\r\n                const vDataOffset = offset * attrBytes;\r\n                this._vSet(vData[vDataOffset], vData[vDataOffset + 1], 1);\r\n                this._vSet(vData[vDataOffset + attrBytes], vData[vDataOffset + attrBytes + 1], -1);\r\n            } else {\r\n                // Add cap\r\n                const dPos = new Point(p1.x, p1.y);\r\n                dPos.subtract(p0);\r\n                dPos.normalize();\r\n\r\n                const dx = dPos.x;\r\n                const dy = dPos.y;\r\n\r\n                if (lineCap === LineCap.BUTT) {\r\n                    this._buttCapEnd(p1, dx, dy, w, 0);\r\n                } else if (lineCap === LineCap.SQUARE) {\r\n                    this._buttCapEnd(p1, dx, dy, w, w);\r\n                } else if (lineCap === LineCap.ROUND) {\r\n                    this._roundCapEnd(p1, dx, dy, w, nCap);\r\n                }\r\n            }\r\n\r\n            // stroke indices\r\n            let indicesOffset = meshBuffer.indexStart;\r\n            for (let begin = offset + 2, over = meshBuffer.vertexStart; begin < over; begin++) {\r\n                iData[indicesOffset++] = begin - 2;\r\n                iData[indicesOffset++] = begin - 1;\r\n                iData[indicesOffset++] = begin;\r\n            }\r\n\r\n            meshBuffer.indexStart = indicesOffset;\r\n        }\r\n        _renderData = null;\r\n        _impl = null;\r\n    }\r\n\r\n    private _expandFill (graphics: Graphics): void {\r\n        _impl = graphics.impl;\r\n        if (!_impl) {\r\n            return;\r\n        }\r\n\r\n        const paths = _impl.paths;\r\n\r\n        // Calculate max vertex usage.\r\n        let vertexCount = 0;\r\n        for (let i = _impl.pathOffset, l = _impl.pathLength; i < l; i++) {\r\n            const path = paths[i];\r\n            const pointsLength = path.points.length;\r\n\r\n            vertexCount += pointsLength;\r\n        }\r\n\r\n        const renderData: MeshRenderData | null = _renderData = this.getRenderData(graphics, vertexCount);\r\n        if (!renderData) {\r\n            return;\r\n        }\r\n\r\n        const meshBuffer = renderData;\r\n        const vData = meshBuffer.vData;\r\n        const iData = meshBuffer.iData;\r\n\r\n        for (let i = _impl.pathOffset, l = _impl.pathLength; i < l; i++) {\r\n            const path = paths[i];\r\n            const pts = path.points;\r\n            const pointsLength = pts.length;\r\n\r\n            if (pointsLength === 0) {\r\n                continue;\r\n            }\r\n\r\n            // Calculate shape vertices.\r\n            const vertexOffset = renderData.vertexStart;\r\n\r\n            for (let j = 0; j < pointsLength; ++j) {\r\n                this._vSet(pts[j].x, pts[j].y);\r\n            }\r\n\r\n            let indicesOffset = renderData.indexStart;\r\n\r\n            if (path.complex) {\r\n                const earcutData: number[] = [];\r\n                for (let j = vertexOffset, end = renderData.vertexStart; j < end; j++) {\r\n                    let vDataOffset = j * attrBytes;\r\n                    earcutData.push(vData[vDataOffset++]);\r\n                    earcutData.push(vData[vDataOffset++]);\r\n                    earcutData.push(vData[vDataOffset++]);\r\n                }\r\n\r\n                const newIndices = Earcut(earcutData, null, 3);\r\n\r\n                if (!newIndices || newIndices.length === 0) {\r\n                    continue;\r\n                }\r\n\r\n                for (let j = 0, nIndices = newIndices.length; j < nIndices; j++) {\r\n                    iData[indicesOffset++] = newIndices[j] + vertexOffset;\r\n                }\r\n            } else {\r\n                const first = vertexOffset;\r\n                for (let start = vertexOffset + 2, end = meshBuffer.vertexStart; start < end; start++) {\r\n                    iData[indicesOffset++] = first;\r\n                    iData[indicesOffset++] = start - 1;\r\n                    iData[indicesOffset++] = start;\r\n                }\r\n            }\r\n\r\n            meshBuffer.indexStart = indicesOffset;\r\n        }\r\n\r\n        _renderData = null;\r\n        _impl = null;\r\n    }\r\n\r\n    private _calculateJoins (impl: Impl, w: number, lineJoin: LineJoin, miterLimit: number): void {\r\n        let iw = 0.0;\r\n\r\n        if (w > 0.0) {\r\n            iw = 1 / w;\r\n        }\r\n\r\n        // Calculate which joins needs extra vertices to append, and gather vertex count.\r\n        const paths = impl.paths;\r\n        for (let i = impl.pathOffset, l = impl.pathLength; i < l; i++) {\r\n            const path = paths[i];\r\n\r\n            const pts = path.points;\r\n            const ptsLength = pts.length;\r\n            let p0 = pts[ptsLength - 1];\r\n            let p1 = pts[0];\r\n            let nLeft = 0;\r\n\r\n            path.bevel = 0;\r\n\r\n            for (let j = 0; j < ptsLength; j++) {\r\n                let dmr2 = 0;\r\n                let cross = 0;\r\n                let limit = 0;\r\n\r\n                // perp normals\r\n                const dlx0 = p0.dy;\r\n                const dly0 = -p0.dx;\r\n                const dlx1 = p1.dy;\r\n                const dly1 = -p1.dx;\r\n\r\n                // Calculate extrusions\r\n                p1.dmx = (dlx0 + dlx1) * 0.5;\r\n                p1.dmy = (dly0 + dly1) * 0.5;\r\n                dmr2 = p1.dmx * p1.dmx + p1.dmy * p1.dmy;\r\n                if (dmr2 > 0.000001) {\r\n                    let scale = 1 / dmr2;\r\n                    if (scale > 600) {\r\n                        scale = 600;\r\n                    }\r\n                    p1.dmx *= scale;\r\n                    p1.dmy *= scale;\r\n                }\r\n\r\n                // Keep track of left turns.\r\n                cross = p1.dx * p0.dy - p0.dx * p1.dy;\r\n                if (cross > 0) {\r\n                    nLeft++;\r\n                    p1.flags |= PointFlags.PT_LEFT;\r\n                }\r\n\r\n                // Calculate if we should use bevel or miter for inner join.\r\n                limit = max(11, min(p0.len, p1.len) * iw);\r\n                if (dmr2 * limit * limit < 1) {\r\n                    p1.flags |= PointFlags.PT_INNERBEVEL;\r\n                }\r\n\r\n                // Check to see if the corner needs to be beveled.\r\n                if (p1.flags & PointFlags.PT_CORNER) {\r\n                    if (dmr2 * miterLimit * miterLimit < 1\r\n                        || lineJoin === LineJoin.BEVEL\r\n                        || lineJoin === LineJoin.ROUND) {\r\n                        p1.flags |= PointFlags.PT_BEVEL;\r\n                    }\r\n                }\r\n\r\n                if ((p1.flags & (PointFlags.PT_BEVEL | PointFlags.PT_INNERBEVEL)) !== 0) {\r\n                    path.bevel++;\r\n                }\r\n\r\n                p0 = p1;\r\n                p1 = pts[j + 1];\r\n            }\r\n        }\r\n    }\r\n\r\n    private _flattenPaths (impl: Impl): void {\r\n        const paths = impl.paths;\r\n        for (let i = impl.pathOffset, l = impl.pathLength; i < l; i++) {\r\n            const path = paths[i];\r\n            const pts = path.points;\r\n\r\n            let p0 = pts[pts.length - 1];\r\n            let p1 = pts[0];\r\n\r\n            if (pts.length > 2 && p0.equals(p1)) {\r\n                path.closed = true;\r\n                pts.pop();\r\n                p0 = pts[pts.length - 1];\r\n            }\r\n\r\n            for (let j = 0, size = pts.length; j < size; j++) {\r\n                // Calculate segment direction and length\r\n                const dPos = new Point(p1.x, p1.y);\r\n                dPos.subtract(p0);\r\n                p0.len = dPos.length();\r\n                if (dPos.x || dPos.y) {\r\n                    dPos.normalize();\r\n                }\r\n                p0.dx = dPos.x;\r\n                p0.dy = dPos.y;\r\n                // Advance\r\n                p0 = p1;\r\n                p1 = pts[j + 1];\r\n            }\r\n        }\r\n    }\r\n\r\n    private _chooseBevel (bevel: number, p0: Point, p1: Point, w: number): [number, number, number, number] {\r\n        const x = p1.x;\r\n        const y = p1.y;\r\n        let x0 = 0;\r\n        let y0 = 0;\r\n        let x1 = 0;\r\n        let y1 = 0;\r\n\r\n        if (bevel !== 0) {\r\n            x0 = x + p0.dy * w;\r\n            y0 = y - p0.dx * w;\r\n            x1 = x + p1.dy * w;\r\n            y1 = y - p1.dx * w;\r\n        } else {\r\n            x0 = x1 = x + p1.dmx * w;\r\n            y0 = y1 = y + p1.dmy * w;\r\n        }\r\n\r\n        return [x0, y0, x1, y1];\r\n    }\r\n\r\n    private _buttCapStart (p: Point, dx: number, dy: number, w: number, d: number): void {\r\n        const px = p.x - dx * d;\r\n        const py = p.y - dy * d;\r\n        const dlx = dy;\r\n        const dly = -dx;\r\n\r\n        this._vSet(px + dlx * w, py + dly * w, 1);\r\n        this._vSet(px - dlx * w, py - dly * w, -1);\r\n    }\r\n\r\n    private _buttCapEnd (p: Point, dx: number, dy: number, w: number, d: number): void {\r\n        const px = p.x + dx * d;\r\n        const py = p.y + dy * d;\r\n        const dlx = dy;\r\n        const dly = -dx;\r\n\r\n        this._vSet(px + dlx * w, py + dly * w, 1);\r\n        this._vSet(px - dlx * w, py - dly * w, -1);\r\n    }\r\n\r\n    private _roundCapStart (p: Point, dx: number, dy: number, w: number, nCap: number): void {\r\n        const px = p.x;\r\n        const py = p.y;\r\n        const dlx = dy;\r\n        const dly = -dx;\r\n\r\n        for (let i = 0; i < nCap; i++) {\r\n            const a = i / (nCap - 1) * PI;\r\n            const ax = cos(a) * w;\r\n            const ay = sin(a) * w;\r\n            this._vSet(px - dlx * ax - dx * ay, py - dly * ax - dy * ay, 1);\r\n            this._vSet(px, py, 0);\r\n        }\r\n        this._vSet(px + dlx * w, py + dly * w, 1);\r\n        this._vSet(px - dlx * w, py - dly * w, -1);\r\n    }\r\n\r\n    private _roundCapEnd (p: Point, dx: number, dy: number, w: number, nCap: number): void {\r\n        const px = p.x;\r\n        const py = p.y;\r\n        const dlx = dy;\r\n        const dly = -dx;\r\n\r\n        this._vSet(px + dlx * w, py + dly * w, 1);\r\n        this._vSet(px - dlx * w, py - dly * w, -1);\r\n        for (let i = 0; i < nCap; i++) {\r\n            const a = i / (nCap - 1) * PI;\r\n            const ax = cos(a) * w;\r\n            const ay = sin(a) * w;\r\n            this._vSet(px, py, 0);\r\n            this._vSet(px - dlx * ax + dx * ay, py - dly * ax + dy * ay, 1);\r\n        }\r\n    }\r\n\r\n    private _roundJoin (p0: Point, p1: Point, lw: number, rw: number, nCap: number): void {\r\n        const dlx0 = p0.dy;\r\n        const dly0 = -p0.dx;\r\n        const dlx1 = p1.dy;\r\n        const dly1 = -p1.dx;\r\n\r\n        const p1x = p1.x;\r\n        const p1y = p1.y;\r\n\r\n        if ((p1.flags & PointFlags.PT_LEFT) !== 0) {\r\n            const out = this._chooseBevel(p1.flags & PointFlags.PT_INNERBEVEL, p0, p1, lw);\r\n            const lx0 = out[0];\r\n            const ly0 = out[1];\r\n            const lx1 = out[2];\r\n            const ly1 = out[3];\r\n\r\n            const a0 = atan2(-dly0, -dlx0);\r\n            let a1 = atan2(-dly1, -dlx1);\r\n            if (a1 > a0) { a1 -= PI * 2; }\r\n\r\n            this._vSet(lx0, ly0, 1);\r\n            this._vSet(p1x - dlx0 * rw, p1.y - dly0 * rw, -1);\r\n\r\n            const n = clamp(ceil((a0 - a1) / PI) * nCap, 2, nCap);\r\n            for (let i = 0; i < n; i++) {\r\n                const u = i / (n - 1);\r\n                const a = a0 + u * (a1 - a0);\r\n                const rx = p1x + cos(a) * rw;\r\n                const ry = p1y + sin(a) * rw;\r\n                this._vSet(p1x, p1y, 0);\r\n                this._vSet(rx, ry, -1);\r\n            }\r\n\r\n            this._vSet(lx1, ly1, 1);\r\n            this._vSet(p1x - dlx1 * rw, p1y - dly1 * rw, -1);\r\n        } else {\r\n            const out = this._chooseBevel(p1.flags & PointFlags.PT_INNERBEVEL, p0, p1, -rw);\r\n            const rx0 = out[0];\r\n            const ry0 = out[1];\r\n            const rx1 = out[2];\r\n            const ry1 = out[3];\r\n\r\n            const a0 = atan2(dly0, dlx0);\r\n            let a1 = atan2(dly1, dlx1);\r\n            if (a1 < a0) { a1 += PI * 2; }\r\n\r\n            this._vSet(p1x + dlx0 * rw, p1y + dly0 * rw, 1);\r\n            this._vSet(rx0, ry0, -1);\r\n\r\n            const n = clamp(ceil((a1 - a0) / PI) * nCap, 2, nCap);\r\n            for (let i = 0; i < n; i++) {\r\n                const u = i / (n - 1);\r\n                const a = a0 + u * (a1 - a0);\r\n                const lx = p1x + cos(a) * lw;\r\n                const ly = p1y + sin(a) * lw;\r\n                this._vSet(lx, ly, 1);\r\n                this._vSet(p1x, p1y, 0);\r\n            }\r\n\r\n            this._vSet(p1x + dlx1 * rw, p1y + dly1 * rw, 1);\r\n            this._vSet(rx1, ry1, -1);\r\n        }\r\n    }\r\n\r\n    private _bevelJoin (p0: Point, p1: Point, lw: number, rw: number): void {\r\n        let rx0 = 0;\r\n        let ry0 = 0;\r\n        let rx1 = 0;\r\n        let ry1 = 0;\r\n        let lx0 = 0;\r\n        let ly0 = 0;\r\n        let lx1 = 0;\r\n        let ly1 = 0;\r\n        const dlx0 = p0.dy;\r\n        const dly0 = -p0.dx;\r\n        const dlx1 = p1.dy;\r\n        const dly1 = -p1.dx;\r\n\r\n        if (p1.flags & PointFlags.PT_LEFT) {\r\n            const out = this._chooseBevel(p1.flags & PointFlags.PT_INNERBEVEL, p0, p1, lw);\r\n            lx0 = out[0];\r\n            ly0 = out[1];\r\n            lx1 = out[2];\r\n            ly1 = out[3];\r\n\r\n            this._vSet(lx0, ly0, 1);\r\n            this._vSet(p1.x - dlx0 * rw, p1.y - dly0 * rw, -1);\r\n\r\n            this._vSet(lx1, ly1, 1);\r\n            this._vSet(p1.x - dlx1 * rw, p1.y - dly1 * rw, -1);\r\n        } else {\r\n            const out = this._chooseBevel(p1.flags & PointFlags.PT_INNERBEVEL, p0, p1, -rw);\r\n            rx0 = out[0];\r\n            ry0 = out[1];\r\n            rx1 = out[2];\r\n            ry1 = out[3];\r\n\r\n            this._vSet(p1.x + dlx0 * lw, p1.y + dly0 * lw, 1);\r\n            this._vSet(rx0, ry0, -1);\r\n\r\n            this._vSet(p1.x + dlx1 * lw, p1.y + dly1 * lw, 1);\r\n            this._vSet(rx1, ry1, -1);\r\n        }\r\n    }\r\n\r\n    private _vSet (x: number, y: number, distance = 0): void {\r\n        if (!_renderData) {\r\n            return;\r\n        }\r\n\r\n        const meshBuffer = _renderData;\r\n        let dataOffset = meshBuffer.vertexStart * attrBytes;\r\n        const vData = meshBuffer.vData;\r\n        // vec3.set(_tempVec3, x, y, 0);\r\n        // vec3.transformMat4(_tempVec3, _tempVec3, _currMatrix);\r\n\r\n        vData[dataOffset++] = x;\r\n        vData[dataOffset++] = y;\r\n        vData[dataOffset++] = 0;\r\n        Color.toArray(vData, _curColor, dataOffset);\r\n        dataOffset += 4;\r\n        vData[dataOffset++] = distance;\r\n        meshBuffer.vertexStart++;\r\n    }\r\n}\r\n\r\nexport const graphicsAssembler = new GraphicsAssembler();\r\n","/*\r\n Copyright (c) 2017-2023 Xiamen Yaji Software Co., Ltd.\r\n\r\n http://www.cocos.com\r\n\r\n Permission is hereby granted, free of charge, to any person obtaining a copy\r\n of this software and associated documentation files (the \"Software\"), to deal\r\n in the Software without restriction, including without limitation the rights to\r\n use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\r\n of the Software, and to permit persons to whom the Software is furnished to do so,\r\n subject to the following conditions:\r\n\r\n The above copyright notice and this permission notice shall be included in\r\n all copies or substantial portions of the Software.\r\n\r\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n THE SOFTWARE.\r\n*/\r\n\r\nimport { UIRenderer } from '../../../framework/ui-renderer';\r\nimport { IAssembler, IAssemblerManager } from '../../../renderer/base';\r\nimport { Graphics } from '../../../components/graphics';\r\nimport { graphicsAssembler as graphics } from './graphics-assembler';\r\n\r\nconst graphicsAssemblerManager: IAssemblerManager = {\r\n    getAssembler (sprite: UIRenderer): IAssembler {\r\n        return graphics;\r\n    },\r\n};\r\n\r\nGraphics.Assembler = graphicsAssemblerManager;\r\nexport {\r\n    graphics,\r\n    graphicsAssemblerManager as graphicsAssembler,\r\n};\r\n","import { cclegacy } from './base';\r\nimport { graphicsAssembler } from '../cocos/2d/assembler/graphics';\r\n\r\nexport * from '../cocos/2d/components/graphics';\r\nexport { graphicsAssembler };\r\n\r\ncclegacy.UI.graphicsAssembler = graphicsAssembler;\r\n"],"names":["Aim","i","x","y","this","prev","next","z","prevZ","nextZ","steiner","linkedList","datas","start","end","dim","clockwise","last","signedArea","insertNode","equals","removeNode","filterPoints","p","again","area","earcutLinked","ear","triangles","minX","minY","size","pass","indexCurve","stop","isEarHashed","isEar","push","cureLocalIntersections","splitEarcut","a","b","c","pointInTriangle","minTX","minTY","maxTX","maxTY","minZ","zOrder","maxZ","intersects","locallyInside","isValidDiagonal","splitPolygon","sortLinked","list","q","e","tail","numMerges","pSize","qSize","inSize","ax","ay","bx","by","cx","cy","px","py","intersectsPolygon","middleInside","r","p1","p2","q1","q2","inside","a2","b2","an","bp","sum","j","earcut","holeIndices","outerLen","length","outerNode","maxX","maxY","Math","max","PI","min","ceil","acos","cos","sin","atan2","_renderData","_impl","_curColor","Color","vec3_temps","Vec3","clamp","v","minNum","maxNum","graphicsAssembler","GraphicsAssembler","_proto","prototype","updateRenderData","getRenderData","graphics","vertexCount","renderDataList","getRenderDataList","renderData","dataOffset","meshBuffer","maxVertexCount","vertexStart","MAX_VERTEX","requestRenderData","request","stroke","copy","strokeColor","impl","_flattenPaths","_expandStroke","updatePathOffset","fill","fillColor","_expandFill","_markForUpdateRenderData","w","lineWidth","lineCap","lineJoin","miterLimit","arc","tol","da","nCap","tessTol","_calculateJoins","paths","pathOffset","l","pathLength","path","pointsLength","points","LineJoin","ROUND","bevel","closed","LineCap","vData","iData","pts","offset","p0","loop","dPos","Point","subtract","normalize","dx","dy","BUTT","_buttCapStart","SQUARE","_roundCapStart","_roundJoin","flags","PointFlags","PT_BEVEL","PT_INNERBEVEL","_bevelJoin","_vSet","dmx","dmy","vDataOffset","_buttCapEnd","_roundCapEnd","indicesOffset","indexStart","begin","over","vertexOffset","complex","earcutData","newIndices","Earcut","nIndices","first","iw","ptsLength","dmr2","limit","dlx0","dly0","dlx1","dly1","scale","PT_LEFT","len","PT_CORNER","BEVEL","pop","_chooseBevel","x0","y0","x1","y1","d","dlx","dly","lw","rw","p1x","p1y","out","lx0","ly0","lx1","ly1","a0","a1","n","rx","ry","rx0","ry0","rx1","ry1","lx","ly","distance","toArray","graphicsAssemblerManager","exports","getAssembler","Graphics","Assembler","cclegacy","UI"],"mappings":"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"}