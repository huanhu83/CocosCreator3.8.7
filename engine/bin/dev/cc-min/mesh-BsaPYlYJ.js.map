{"version":3,"file":"mesh-BsaPYlYJ.js","sources":["../../../cocos/3d/misc/buffer-blob.ts","../../../cocos/3d/assets/morph-rendering.ts","../../../cocos/3d/misc/mesh-codec.ts","../../../cocos/3d/assets/mesh.ts"],"sourcesContent":["/*\r\n Copyright (c) 2020-2023 Xiamen Yaji Software Co., Ltd.\r\n\r\n https://www.cocos.com/\r\n\r\n Permission is hereby granted, free of charge, to any person obtaining a copy\r\n of this software and associated documentation files (the \"Software\"), to deal\r\n in the Software without restriction, including without limitation the rights to\r\n use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\r\n of the Software, and to permit persons to whom the Software is furnished to do so,\r\n subject to the following conditions:\r\n\r\n The above copyright notice and this permission notice shall be included in\r\n all copies or substantial portions of the Software.\r\n\r\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n THE SOFTWARE.\r\n*/\r\n\r\n/** @mangle */\r\nexport class BufferBlob {\r\n    private _arrayBufferOrPaddings: Array<ArrayBuffer | number> = [];\r\n    private _length = 0;\r\n\r\n    constructor () {}\r\n\r\n    public setNextAlignment (align: number): void {\r\n        if (align !== 0) {\r\n            const remainder = this._length % align;\r\n            if (remainder !== 0) {\r\n                const padding = align - remainder;\r\n                this._arrayBufferOrPaddings.push(padding);\r\n                this._length += padding;\r\n            }\r\n        }\r\n    }\r\n\r\n    public addBuffer (arrayBuffer: ArrayBuffer): number {\r\n        const result = this._length;\r\n        this._arrayBufferOrPaddings.push(arrayBuffer);\r\n        this._length += arrayBuffer.byteLength;\r\n        return result;\r\n    }\r\n\r\n    public getLength (): number {\r\n        return this._length;\r\n    }\r\n\r\n    public getCombined (): ArrayBufferLike {\r\n        const result = new Uint8Array(this._length);\r\n        let counter = 0;\r\n        this._arrayBufferOrPaddings.forEach((arrayBufferOrPadding) => {\r\n            if (typeof arrayBufferOrPadding === 'number') {\r\n                counter += arrayBufferOrPadding;\r\n            } else {\r\n                result.set(new Uint8Array(arrayBufferOrPadding), counter);\r\n                counter += arrayBufferOrPadding.byteLength;\r\n            }\r\n        });\r\n        return result.buffer;\r\n    }\r\n}\r\n","/*\r\n Copyright (c) 2020-2023 Xiamen Yaji Software Co., Ltd.\r\n\r\n https://www.cocos.com/\r\n\r\n Permission is hereby granted, free of charge, to any person obtaining a copy\r\n of this software and associated documentation files (the \"Software\"), to deal\r\n in the Software without restriction, including without limitation the rights to\r\n use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\r\n of the Software, and to permit persons to whom the Software is furnished to do so,\r\n subject to the following conditions:\r\n\r\n The above copyright notice and this permission notice shall be included in\r\n all copies or substantial portions of the Software.\r\n\r\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n THE SOFTWARE.\r\n*/\r\n\r\nimport {\r\n    AttributeName, Buffer, BufferUsageBit, Device, MemoryUsageBit, DescriptorSet, BufferInfo, FormatFeatureBit, Format, Texture, Sampler,\r\n} from '../../gfx';\r\nimport { Mesh } from './mesh';\r\nimport { Texture2D } from '../../asset/assets/texture-2d';\r\nimport { ImageAsset } from '../../asset/assets/image-asset';\r\nimport { UBOMorph, UBOMorphEnum, UNIFORM_NORMAL_MORPH_TEXTURE_BINDING,\r\n    UNIFORM_POSITION_MORPH_TEXTURE_BINDING, UNIFORM_TANGENT_MORPH_TEXTURE_BINDING } from '../../rendering/define';\r\nimport { Morph, SubMeshMorph } from './morph';\r\nimport { assertIsNonNullable, assertIsTrue, warn, bits, nextPow2, cclegacy, warnID } from '../../core';\r\nimport { IMacroPatch } from '../../render-scene';\r\nimport { TextureFilter, PixelFormat, WrapMode } from '../../asset/assets/asset-enum';\r\n\r\n/**\r\n * True if force to use cpu computing based sub-mesh rendering.\r\n * Only customizable by modify the internal engine code.\r\n */\r\nconst preferCpuComputing = false;\r\n\r\n/**\r\n * @en Interface for classes which control the rendering of morph resources.\r\n * @zh 支持形变网格渲染的基类。\r\n */\r\nexport interface MorphRendering {\r\n    createInstance (): MorphRenderingInstance;\r\n}\r\n\r\n/**\r\n * @en The instance of [[MorphRendering]] for dedicated control in the mesh renderer.\r\n * The root [[MorphRendering]] is owned by [[Mesh]] asset, each [[MeshRenderer]] can have its own morph rendering instance.\r\n * @zh 用于网格渲染器中独立控制 [[MorphRendering]] 的实例。原始 [[MorphRendering]] 被 [[Mesh]] 资源持有，每个 [[MeshRenderer]] 都持有自己的形变网格渲染实例。\r\n */\r\nexport interface MorphRenderingInstance {\r\n    /**\r\n     * Sets weights of targets of specified sub mesh.\r\n     * @param subMeshIndex\r\n     * @param weights\r\n     */\r\n    setWeights (subMeshIndex: number, weights: number[]): void;\r\n\r\n    /**\r\n     * Adapts pipeline state to do the rendering.\r\n     * @param subMeshIndex\r\n     * @param pipelineState\r\n     */\r\n    adaptPipelineState (subMeshIndex: number, descriptorSet: DescriptorSet): void;\r\n\r\n    /**\r\n     * Acquire the define overrides needed to do the rendering.\r\n     */\r\n    requiredPatches (subMeshIndex: number): IMacroPatch[] | null;\r\n\r\n    /**\r\n     * Destroy the rendering instance.\r\n     */\r\n    destroy (): void;\r\n}\r\n\r\n/**\r\n * @en Create morph rendering from mesh which contains morph targets data.\r\n * @zh 从包含形变对象的网格资源中创建形变网格渲染对象。\r\n * @param mesh @en The mesh to create morph rendering from. @zh 用于创建形变网格渲染对象的原始网格资源。\r\n * @param gfxDevice @en The device instance acquired from [[Root]]. @zh 设备对象实例，可以从 [[Root]] 获取。\r\n */\r\nexport function createMorphRendering (mesh: Mesh, gfxDevice: Device): MorphRendering {\r\n    return new StdMorphRendering(mesh, gfxDevice);\r\n}\r\n\r\n/**\r\n * @en Standard morph rendering class, it supports both GPU and CPU based morph blending.\r\n * If sub mesh morph targets count is less than [[pipeline.UBOMorphEnum.MAX_MORPH_TARGET_COUNT]], then GPU based blending is enabled.\r\n * Each of the sub-mesh morph has its own [[MorphRenderingInstance]],\r\n * its morph target weights, render pipeline state and strategy of morph blending are controlled separately.\r\n * @zh 标准形变网格渲染类，它同时支持 CPU 和 GPU 的形变混合计算。\r\n * 如果子网格形变目标数量少于 [[pipeline.UBOMorphEnum.MAX_MORPH_TARGET_COUNT]]，那么就会使用基于 GPU 的形变混合计算。\r\n * 每个子网格形变都使用自己独立的 [[MorphRenderingInstance]]，它的形变目标权重、渲染管线状态和形变混合计算策略都是独立控制的。\r\n */\r\nexport class StdMorphRendering implements MorphRendering {\r\n    private declare _mesh: Mesh;\r\n    private _subMeshRenderings: (SubMeshMorphRendering | null)[] = [];\r\n\r\n    constructor (mesh: Mesh, gfxDevice: Device) {\r\n        this._mesh = mesh;\r\n        if (!this._mesh.struct.morph) {\r\n            return;\r\n        }\r\n\r\n        const nSubMeshes = this._mesh.struct.primitives.length;\r\n        this._subMeshRenderings = new Array(nSubMeshes).fill(null);\r\n        for (let iSubMesh = 0; iSubMesh < nSubMeshes; ++iSubMesh) {\r\n            const subMeshMorph = this._mesh.struct.morph.subMeshMorphs[iSubMesh];\r\n            if (!subMeshMorph) {\r\n                continue;\r\n            }\r\n\r\n            if (preferCpuComputing || subMeshMorph.targets.length > UBOMorphEnum.MAX_MORPH_TARGET_COUNT) {\r\n                this._subMeshRenderings[iSubMesh] = new CpuComputing(\r\n                    this._mesh,\r\n                    iSubMesh,\r\n                    this._mesh.struct.morph,\r\n                    gfxDevice,\r\n                );\r\n            } else {\r\n                this._subMeshRenderings[iSubMesh] = new GpuComputing(\r\n                    this._mesh,\r\n                    iSubMesh,\r\n                    this._mesh.struct.morph,\r\n                    gfxDevice,\r\n                );\r\n            }\r\n        }\r\n    }\r\n\r\n    public createInstance (): MorphRenderingInstance {\r\n        const nSubMeshes = this._mesh.struct.primitives.length;\r\n        const subMeshInstances: (SubMeshMorphRenderingInstance | null)[] = new Array(nSubMeshes);\r\n        for (let iSubMesh = 0; iSubMesh < nSubMeshes; ++iSubMesh) {\r\n            subMeshInstances[iSubMesh] = this._subMeshRenderings[iSubMesh]?.createInstance() ?? null;\r\n        }\r\n        return {\r\n            setWeights (subMeshIndex: number, weights: number[]): void {\r\n                subMeshInstances[subMeshIndex]?.setWeights(weights);\r\n            },\r\n\r\n            requiredPatches: (subMeshIndex: number): IMacroPatch[] | null => {\r\n                assertIsNonNullable(this._mesh.struct.morph);\r\n                const subMeshMorph = this._mesh.struct.morph.subMeshMorphs[subMeshIndex];\r\n                const subMeshRenderingInstance = subMeshInstances[subMeshIndex];\r\n                if (subMeshRenderingInstance === null) {\r\n                    return null;\r\n                }\r\n                assertIsNonNullable(subMeshMorph);\r\n                const patches: IMacroPatch[] = [\r\n                    { name: 'CC_USE_MORPH', value: true },\r\n                    { name: 'CC_MORPH_TARGET_COUNT', value: subMeshMorph.targets.length },\r\n                ];\r\n                if (subMeshMorph.attributes.includes(AttributeName.ATTR_POSITION)) {\r\n                    patches.push({ name: 'CC_MORPH_TARGET_HAS_POSITION', value: true });\r\n                }\r\n                if (subMeshMorph.attributes.includes(AttributeName.ATTR_NORMAL)) {\r\n                    patches.push({ name: 'CC_MORPH_TARGET_HAS_NORMAL', value: true });\r\n                }\r\n                if (subMeshMorph.attributes.includes(AttributeName.ATTR_TANGENT)) {\r\n                    patches.push({ name: 'CC_MORPH_TARGET_HAS_TANGENT', value: true });\r\n                }\r\n                patches.push(...subMeshRenderingInstance.requiredPatches());\r\n                return patches;\r\n            },\r\n\r\n            adaptPipelineState: (subMeshIndex: number, descriptorSet: DescriptorSet): void => {\r\n                subMeshInstances[subMeshIndex]?.adaptPipelineState(descriptorSet);\r\n            },\r\n\r\n            destroy: (): void => {\r\n                subMeshInstances.forEach((subMeshInstance) => {\r\n                    if (subMeshInstance) subMeshInstance.destroy();\r\n                });\r\n            },\r\n        };\r\n    }\r\n}\r\n\r\n/**\r\n * @en Sub-mesh morph rendering describes how to render a sub-mesh morph.\r\n * @zh 子网格形变渲染定义如何渲染一个子网格形变。\r\n */\r\ninterface SubMeshMorphRendering {\r\n    /**\r\n     * Creates a rendering instance.\r\n     */\r\n    createInstance (): SubMeshMorphRenderingInstance;\r\n}\r\n\r\n/**\r\n * @en The instance of sub-mesh morph rendering, each sub-mesh have its own instance\r\n * for controlling its morph target weights, render pipeline state and strategy of morph blending.\r\n * @zh 子网格形变渲染的实例，每个子网格都拥有自己独立的子网格形变渲染实例，用于独立控制形变目标权重、渲染管线状态和形变混合计算策略。\r\n */\r\ninterface SubMeshMorphRenderingInstance {\r\n    /**\r\n     * Set weights of each morph target.\r\n     * @param weights The weights.\r\n     */\r\n    setWeights (weights: number[]): void;\r\n\r\n    /**\r\n     * Asks the define overrides needed to do the rendering.\r\n     */\r\n    requiredPatches (): IMacroPatch[];\r\n\r\n    /**\r\n     * Adapts the pipelineState to apply the rendering.\r\n     * @param pipelineState\r\n     */\r\n    adaptPipelineState (descriptorSet: DescriptorSet): void;\r\n\r\n    /**\r\n     * Destroy this instance.\r\n     */\r\n    destroy (): void;\r\n}\r\n\r\n/**\r\n * (General purpose) Gpu computing based sub-mesh morph rendering.\r\n * This technique computes final attribute displacements on GPU.\r\n * Target displacements of each attribute are transferred through vertex texture, say, morph texture.\r\n */\r\nclass GpuComputing implements SubMeshMorphRendering {\r\n    private declare _gfxDevice: Device;\r\n    private declare _subMeshMorph: SubMeshMorph;\r\n    private declare _textureInfo: {\r\n        width: number;\r\n        height: number;\r\n    };\r\n    private declare _attributes: {\r\n        name: string;\r\n        morphTexture: MorphTexture;\r\n    }[];\r\n    private declare _verticesCount: number;\r\n\r\n    constructor (mesh: Mesh, subMeshIndex: number, morph: Morph, gfxDevice: Device) {\r\n        this._gfxDevice = gfxDevice;\r\n        const subMeshMorph = morph.subMeshMorphs[subMeshIndex];\r\n        assertIsNonNullable(subMeshMorph);\r\n        this._subMeshMorph = subMeshMorph;\r\n\r\n        enableVertexId(mesh, subMeshIndex, gfxDevice);\r\n\r\n        const nVertices = mesh.struct.vertexBundles[mesh.struct.primitives[subMeshIndex].vertexBundelIndices[0]].view.count;\r\n        this._verticesCount = nVertices;\r\n        const nTargets = subMeshMorph.targets.length;\r\n        const vec4Required = nVertices * nTargets;\r\n\r\n        const vec4TextureFactory = createVec4TextureFactory(gfxDevice, vec4Required);\r\n        this._textureInfo = {\r\n            width: vec4TextureFactory.width,\r\n            height: vec4TextureFactory.height,\r\n        };\r\n\r\n        // Creates texture for each attribute.\r\n        this._attributes = subMeshMorph.attributes.map((attributeName, attributeIndex) => {\r\n            const vec4Tex = vec4TextureFactory.create();\r\n            const valueView = vec4Tex.valueView;\r\n            // if (DEV) { // Make it easy to view texture in profilers...\r\n            //     for (let i = 0; i < valueView.length / 4; ++i) {\r\n            //         valueView[i * 4 + 3] = 1.0;\r\n            //     }\r\n            // }\r\n            subMeshMorph.targets.forEach((morphTarget, morphTargetIndex) => {\r\n                const displacementsView = morphTarget.displacements[attributeIndex];\r\n                const displacements = new Float32Array(mesh.data.buffer, mesh.data.byteOffset + displacementsView.offset, displacementsView.count);\r\n                const displacementsOffset = (nVertices * morphTargetIndex) * 4;\r\n                for (let iVertex = 0; iVertex < nVertices; ++iVertex) {\r\n                    valueView[displacementsOffset + 4 * iVertex + 0] = displacements[3 * iVertex + 0];\r\n                    valueView[displacementsOffset + 4 * iVertex + 1] = displacements[3 * iVertex + 1];\r\n                    valueView[displacementsOffset + 4 * iVertex + 2] = displacements[3 * iVertex + 2];\r\n                }\r\n            });\r\n            vec4Tex.updatePixels();\r\n            return {\r\n                name: attributeName,\r\n                morphTexture: vec4Tex,\r\n            };\r\n        });\r\n    }\r\n\r\n    public destroy (): void {\r\n        this._attributes.forEach((attribute) => {\r\n            attribute.morphTexture.destroy();\r\n        });\r\n    }\r\n\r\n    public createInstance (): {\r\n        setWeights: (weights: number[]) => void;\r\n        requiredPatches: () => IMacroPatch[];\r\n        adaptPipelineState: (descriptorSet: DescriptorSet) => void;\r\n        destroy: () => void;\r\n        } {\r\n        const morphUniforms = new MorphUniforms(this._gfxDevice, this._subMeshMorph.targets.length);\r\n        morphUniforms.setMorphTextureInfo(this._textureInfo.width, this._textureInfo.height);\r\n        morphUniforms.setVerticesCount(this._verticesCount);\r\n        morphUniforms.commit();\r\n        return {\r\n            setWeights: (weights: number[]): void => {\r\n                morphUniforms.setWeights(weights);\r\n                morphUniforms.commit();\r\n            },\r\n\r\n            requiredPatches: (): IMacroPatch[] => [{ name: 'CC_MORPH_TARGET_USE_TEXTURE', value: true }],\r\n\r\n            adaptPipelineState: (descriptorSet: DescriptorSet): void => {\r\n                for (let i = 0; i < this._attributes.length; ++i) {\r\n                    const attribute = this._attributes[i];\r\n                    let binding: number | undefined;\r\n                    switch (attribute.name) {\r\n                    case AttributeName.ATTR_POSITION: binding = UNIFORM_POSITION_MORPH_TEXTURE_BINDING; break;\r\n                    case AttributeName.ATTR_NORMAL: binding = UNIFORM_NORMAL_MORPH_TEXTURE_BINDING; break;\r\n                    case AttributeName.ATTR_TANGENT: binding = UNIFORM_TANGENT_MORPH_TEXTURE_BINDING; break;\r\n                    default:\r\n                        warnID(16374); break;\r\n                    }\r\n                    if (binding !== undefined) {\r\n                        descriptorSet.bindSampler(binding, attribute.morphTexture.sampler);\r\n                        descriptorSet.bindTexture(binding, attribute.morphTexture.texture);\r\n                    }\r\n                }\r\n                descriptorSet.bindBuffer(UBOMorph.BINDING, morphUniforms.buffer);\r\n                descriptorSet.update();\r\n            },\r\n\r\n            destroy: (): void => {\r\n\r\n            },\r\n        };\r\n    }\r\n}\r\n\r\n/**\r\n * Cpu computing based sub-mesh morph rendering.\r\n * This technique computes final attribute displacements on CPU.\r\n * The displacements, then, are passed to GPU.\r\n */\r\nclass CpuComputing implements SubMeshMorphRendering {\r\n    private declare _gfxDevice: Device;\r\n    private _attributes: {\r\n        name: string;\r\n        targets: {\r\n            displacements: Float32Array;\r\n        }[];\r\n    }[] = [];\r\n\r\n    constructor (mesh: Mesh, subMeshIndex: number, morph: Morph, gfxDevice: Device) {\r\n        this._gfxDevice = gfxDevice;\r\n        const subMeshMorph = morph.subMeshMorphs[subMeshIndex];\r\n        assertIsNonNullable(subMeshMorph);\r\n        enableVertexId(mesh, subMeshIndex, gfxDevice);\r\n        this._attributes = subMeshMorph.attributes.map((attributeName, attributeIndex) =>  ({\r\n            name: attributeName,\r\n            targets: subMeshMorph.targets.map((attributeDisplacement) => ({\r\n                displacements: new Float32Array(\r\n                    mesh.data.buffer,\r\n                    mesh.data.byteOffset + attributeDisplacement.displacements[attributeIndex].offset,\r\n                    attributeDisplacement.displacements[attributeIndex].count,\r\n                ),\r\n            })),\r\n        }));\r\n    }\r\n\r\n    /**\r\n     * DO NOT use this field.\r\n     */\r\n    get data (): {\r\n        name: string;\r\n        targets: {\r\n            displacements: Float32Array;\r\n        }[];\r\n    }[] {\r\n        return this._attributes;\r\n    }\r\n\r\n    public createInstance (): CpuComputingRenderingInstance {\r\n        return new CpuComputingRenderingInstance(\r\n            this,\r\n            this._attributes[0].targets[0].displacements.length / 3,\r\n            this._gfxDevice,\r\n        );\r\n    }\r\n}\r\nclass CpuComputingRenderingInstance implements SubMeshMorphRenderingInstance {\r\n    private declare _attributes: {\r\n        attributeName: string;\r\n        morphTexture: MorphTexture;\r\n    }[];\r\n    private declare _owner: CpuComputing;\r\n    private declare _morphUniforms: MorphUniforms;\r\n\r\n    public constructor (owner: CpuComputing, nVertices: number, gfxDevice: Device) {\r\n        this._owner = owner;\r\n        this._morphUniforms = new MorphUniforms(gfxDevice, 0 /* TODO? */);\r\n\r\n        const vec4TextureFactory = createVec4TextureFactory(gfxDevice, nVertices);\r\n        this._morphUniforms.setMorphTextureInfo(vec4TextureFactory.width, vec4TextureFactory.height);\r\n        this._morphUniforms.commit();\r\n\r\n        this._attributes = this._owner.data.map((attributeMorph, attributeIndex) => {\r\n            const morphTexture = vec4TextureFactory.create();\r\n            return {\r\n                attributeName: attributeMorph.name,\r\n                morphTexture,\r\n            };\r\n        });\r\n    }\r\n\r\n    public setWeights (weights: number[]): void {\r\n        for (let iAttribute = 0; iAttribute < this._attributes.length; ++iAttribute) {\r\n            const myAttribute = this._attributes[iAttribute];\r\n            const valueView = myAttribute.morphTexture.valueView;\r\n            const attributeMorph = this._owner.data[iAttribute];\r\n            assertIsTrue(weights.length === attributeMorph.targets.length);\r\n            for (let iTarget = 0; iTarget < attributeMorph.targets.length; ++iTarget) {\r\n                const targetDisplacements = attributeMorph.targets[iTarget].displacements;\r\n                const weight = weights[iTarget];\r\n                const nVertices = targetDisplacements.length / 3;\r\n                if (iTarget === 0) {\r\n                    for (let iVertex = 0; iVertex < nVertices; ++iVertex) {\r\n                        valueView[4 * iVertex + 0] = targetDisplacements[3 * iVertex + 0] * weight;\r\n                        valueView[4 * iVertex + 1] = targetDisplacements[3 * iVertex + 1] * weight;\r\n                        valueView[4 * iVertex + 2] = targetDisplacements[3 * iVertex + 2] * weight;\r\n                    }\r\n                } else if (weight !== 0.0) {\r\n                    for (let iVertex = 0; iVertex < nVertices; ++iVertex) {\r\n                        valueView[4 * iVertex + 0] += targetDisplacements[3 * iVertex + 0] * weight;\r\n                        valueView[4 * iVertex + 1] += targetDisplacements[3 * iVertex + 1] * weight;\r\n                        valueView[4 * iVertex + 2] += targetDisplacements[3 * iVertex + 2] * weight;\r\n                    }\r\n                }\r\n            }\r\n\r\n            myAttribute.morphTexture.updatePixels();\r\n        }\r\n    }\r\n\r\n    public requiredPatches (): IMacroPatch[] {\r\n        return [\r\n            { name: 'CC_MORPH_TARGET_USE_TEXTURE', value: true },\r\n            { name: 'CC_MORPH_PRECOMPUTED', value: true },\r\n        ];\r\n    }\r\n\r\n    public adaptPipelineState (descriptorSet: DescriptorSet): void {\r\n        for (let i = 0; i < this._attributes.length; ++i) {\r\n            const attribute = this._attributes[i];\r\n            const attributeName = attribute.attributeName;\r\n            let binding: number | undefined;\r\n            switch (attributeName) {\r\n            case AttributeName.ATTR_POSITION: binding = UNIFORM_POSITION_MORPH_TEXTURE_BINDING; break;\r\n            case AttributeName.ATTR_NORMAL: binding = UNIFORM_NORMAL_MORPH_TEXTURE_BINDING; break;\r\n            case AttributeName.ATTR_TANGENT: binding = UNIFORM_TANGENT_MORPH_TEXTURE_BINDING; break;\r\n            default:\r\n                warnID(16374); break;\r\n            }\r\n            if (binding !== undefined) {\r\n                descriptorSet.bindSampler(binding, attribute.morphTexture.sampler);\r\n                descriptorSet.bindTexture(binding, attribute.morphTexture.texture);\r\n            }\r\n        }\r\n        descriptorSet.bindBuffer(UBOMorph.BINDING, this._morphUniforms.buffer);\r\n        descriptorSet.update();\r\n    }\r\n\r\n    public destroy (): void {\r\n        this._morphUniforms.destroy();\r\n        for (let iAttribute = 0; iAttribute < this._attributes.length; ++iAttribute) {\r\n            const myAttribute = this._attributes[iAttribute];\r\n            myAttribute.morphTexture.destroy();\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Provides the access to morph related uniforms.\r\n */\r\nclass MorphUniforms {\r\n    private declare _targetCount: number;\r\n    private declare _localBuffer: DataView;\r\n    private declare _remoteBuffer: Buffer;\r\n\r\n    constructor (gfxDevice: Device, targetCount: number) {\r\n        this._targetCount = targetCount;\r\n        this._localBuffer = new DataView(new ArrayBuffer(UBOMorphEnum.SIZE));\r\n        this._remoteBuffer = gfxDevice.createBuffer(new BufferInfo(\r\n            BufferUsageBit.UNIFORM | BufferUsageBit.TRANSFER_DST,\r\n            MemoryUsageBit.HOST | MemoryUsageBit.DEVICE,\r\n            UBOMorphEnum.SIZE,\r\n            UBOMorphEnum.SIZE,\r\n        ));\r\n    }\r\n\r\n    public destroy (): void {\r\n        this._remoteBuffer.destroy();\r\n    }\r\n\r\n    public get buffer (): Buffer {\r\n        return this._remoteBuffer;\r\n    }\r\n\r\n    public setWeights (weights: number[]): void {\r\n        assertIsTrue(weights.length === this._targetCount);\r\n        const isLittleEndian = cclegacy.sys.isLittleEndian as boolean;\r\n        for (let iWeight = 0; iWeight < weights.length; ++iWeight) {\r\n            this._localBuffer.setFloat32(UBOMorphEnum.OFFSET_OF_WEIGHTS + 4 * iWeight, weights[iWeight], isLittleEndian);\r\n        }\r\n    }\r\n\r\n    public setMorphTextureInfo (width: number, height: number): void {\r\n        const isLittleEndian = cclegacy.sys.isLittleEndian as boolean;\r\n        this._localBuffer.setFloat32(UBOMorphEnum.OFFSET_OF_DISPLACEMENT_TEXTURE_WIDTH, width, isLittleEndian);\r\n        this._localBuffer.setFloat32(UBOMorphEnum.OFFSET_OF_DISPLACEMENT_TEXTURE_HEIGHT, height, isLittleEndian);\r\n    }\r\n\r\n    public setVerticesCount (count: number): void {\r\n        const isLittleEndian = cclegacy.sys.isLittleEndian as boolean;\r\n        this._localBuffer.setFloat32(UBOMorphEnum.OFFSET_OF_VERTICES_COUNT, count, isLittleEndian);\r\n    }\r\n\r\n    public commit (): void {\r\n        this._remoteBuffer.update(this._localBuffer.buffer);\r\n    }\r\n}\r\n\r\nfunction createVec4TextureFactory (gfxDevice: Device, vec4Capacity: number): {\r\n    width: number;\r\n    height: number;\r\n    create: () => {\r\n        readonly texture: Texture;\r\n        readonly sampler: Sampler;\r\n        readonly valueView: Float32Array;\r\n        destroy(): void;\r\n        updatePixels(): void;\r\n    };\r\n} {\r\n    const hasFeatureFloatTexture = gfxDevice.getFormatFeatures(Format.RGBA32F) & FormatFeatureBit.SAMPLED_TEXTURE;\r\n\r\n    let pixelRequired: number;\r\n    let pixelFormat: PixelFormat;\r\n    let pixelBytes: number;\r\n    let UpdateViewConstructor: typeof Float32Array | typeof Uint8Array;\r\n    if (hasFeatureFloatTexture) {\r\n        pixelRequired = vec4Capacity;\r\n        pixelBytes = 16;\r\n        pixelFormat = PixelFormat.RGBA32F;\r\n        UpdateViewConstructor = Float32Array;\r\n    } else {\r\n        pixelRequired = 4 * vec4Capacity;\r\n        pixelBytes = 4;\r\n        pixelFormat = PixelFormat.RGBA8888;\r\n        UpdateViewConstructor = Uint8Array;\r\n    }\r\n\r\n    const { width, height } = bestSizeToHavePixels(pixelRequired);\r\n    assertIsTrue(width * height >= pixelRequired);\r\n\r\n    return {\r\n        width,\r\n        height,\r\n        create: (): {\r\n            readonly texture: Texture;\r\n            readonly sampler: Sampler;\r\n            readonly valueView: Float32Array;\r\n            destroy(): void;\r\n            updatePixels(): void;\r\n        } => {\r\n            const arrayBuffer = new ArrayBuffer(width * height * pixelBytes);\r\n            const valueView = new Float32Array(arrayBuffer);\r\n            const updateView = UpdateViewConstructor === Float32Array ? valueView : new UpdateViewConstructor(arrayBuffer);\r\n            const image = new ImageAsset({\r\n                width,\r\n                height,\r\n                _data: updateView,\r\n                _compressed: false,\r\n                format: pixelFormat,\r\n            });\r\n            const textureAsset = new Texture2D();\r\n            textureAsset.setFilters(TextureFilter.NEAREST, TextureFilter.NEAREST);\r\n            textureAsset.setMipFilter(TextureFilter.NONE);\r\n            textureAsset.setWrapMode(WrapMode.CLAMP_TO_EDGE, WrapMode.CLAMP_TO_EDGE, WrapMode.CLAMP_TO_EDGE);\r\n            textureAsset.image = image;\r\n            if (!textureAsset.getGFXTexture()) {\r\n                warnID(16375);\r\n            }\r\n            const sampler = gfxDevice.getSampler(textureAsset.getSamplerInfo());\r\n            return {\r\n                /**\r\n                 * Gets the GFX texture.\r\n                 */\r\n                get texture (): Texture {\r\n                    return textureAsset.getGFXTexture()!;\r\n                },\r\n\r\n                /**\r\n                 * Gets the GFX sampler.\r\n                 */\r\n                get sampler (): Sampler {\r\n                    return sampler;\r\n                },\r\n\r\n                /**\r\n                 * Value view.\r\n                 */\r\n                get valueView (): Float32Array {\r\n                    return valueView;\r\n                },\r\n\r\n                /**\r\n                 * Destroy the texture. Release its GPU resources.\r\n                 */\r\n                destroy (): void {\r\n                    textureAsset.destroy();\r\n                    // Samplers allocated from `samplerLib` are not required and\r\n                    // should not be destroyed.\r\n                    // this._sampler.destroy();\r\n                },\r\n\r\n                /**\r\n                 * Update the pixels content to `valueView`.\r\n                 */\r\n                updatePixels (): void {\r\n                    textureAsset.uploadData(updateView);\r\n                },\r\n            };\r\n        },\r\n    };\r\n}\r\n\r\ntype MorphTexture = ReturnType<ReturnType<typeof createVec4TextureFactory>['create']>;\r\n\r\n/**\r\n * When use vertex-texture-fetch technique, we do need `gl_vertexId` when we sample per-vertex data.\r\n * WebGL 1.0 does not have `gl_vertexId`; WebGL 2.0, however, does.\r\n */\r\nfunction enableVertexId (mesh: Mesh, subMeshIndex: number, gfxDevice: Device): void {\r\n    mesh.renderingSubMeshes[subMeshIndex].enableVertexIdChannel(gfxDevice);\r\n}\r\n\r\n/**\r\n * Decides a best texture size to have the specified pixel capacity at least.\r\n * The decided width and height has the following characteristics:\r\n * - the width and height are both power of 2;\r\n * - if the width and height are different, the width would be set to the larger once;\r\n * - the width is ensured to be multiple of 4.\r\n * @param nPixels Least pixel capacity.\r\n */\r\nfunction bestSizeToHavePixels (nPixels: number): {\r\n    width: number;\r\n    height: number;\r\n} {\r\n    if (nPixels < 5) {\r\n        nPixels = 5;\r\n    }\r\n    const aligned = nextPow2(nPixels);\r\n    const epxSum = bits.log2(aligned);\r\n    const h = epxSum >> 1;\r\n    const w = (epxSum & 1) ? (h + 1) : h;\r\n    return {\r\n        width: 1 << w,\r\n        height: 1 << h,\r\n    };\r\n}\r\n","/*\r\n Copyright (c) 2023 Xiamen Yaji Software Co., Ltd.\r\n\r\n http://www.cocos.com\r\n\r\n Permission is hereby granted, free of charge, to any person obtaining a copy\r\n of this software and associated documentation files (the \"Software\"), to deal\r\n in the Software without restriction, including without limitation the rights to\r\n use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\r\n of the Software, and to permit persons to whom the Software is furnished to do so,\r\n subject to the following conditions:\r\n\r\n The above copyright notice and this permission notice shall be included in\r\n all copies or substantial portions of the Software.\r\n\r\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n THE SOFTWARE.\r\n*/\r\nimport { CULL_MESHOPT, NATIVE_CODE_BUNDLE_MODE } from 'internal:constants';\r\nimport { ensureWasmModuleReady, instantiateWasm } from 'pal/wasm';\r\n\r\nimport { sys, logID, error } from '../../core';\r\n\r\nimport { game } from '../../game';\r\nimport { NativeCodeBundleMode } from '../../misc/webassembly-support';\r\n\r\n/** @mangle */\r\ninterface IMeshoptDecoder {\r\n    supported: boolean;\r\n    ready: Promise<void>;\r\n    decodeVertexBuffer: (target: Uint8Array, count: number, size: number, source: Uint8Array) => number;\r\n    decodeIndexBuffer: (target: Uint8Array, count: number, size: number, source: Uint8Array) => number;\r\n    decodeIndexSequence: (target: Uint8Array, count: number, size: number, source: Uint8Array) => number;\r\n    decodeGltfBuffer: (target: Uint8Array, count: number, size: number, source: Uint8Array, mode: string) => void;\r\n    useWorkers: boolean;\r\n    decodeGltfBufferAsync: (count: number, size: number, source: Uint8Array, mode: string) => Promise<Uint8Array>;\r\n}\r\n\r\nexport const MeshoptDecoder: IMeshoptDecoder = {} as any;\r\n\r\nfunction initDecoderASM (asm_factory: any): Promise<void> {\r\n    return Promise.all([asm_factory.ready]).then(() => {\r\n        MeshoptDecoder.supported = asm_factory.supported;\r\n        MeshoptDecoder.ready = Promise.resolve();\r\n        MeshoptDecoder.decodeVertexBuffer = asm_factory.decodeVertexBuffer;\r\n        MeshoptDecoder.decodeIndexBuffer = asm_factory.decodeIndexBuffer;\r\n        MeshoptDecoder.decodeIndexSequence = asm_factory.decodeIndexSequence;\r\n        MeshoptDecoder.decodeGltfBuffer = asm_factory.decodeGltfBuffer;\r\n        MeshoptDecoder.useWorkers = asm_factory.useWorkers;\r\n        MeshoptDecoder.decodeGltfBufferAsync = asm_factory.decodeGltfBufferAsync;\r\n        logID(14202);\r\n    });\r\n}\r\n\r\nfunction initDecoderWASM (wasm_factory: any, wasm_url: string): Promise<void> {\r\n    function instantiate (importObject: WebAssembly.Imports): any {\r\n        return instantiateWasm(wasm_url, importObject) as any;\r\n    }\r\n    return Promise.all([wasm_factory.ready(instantiate)]).then(() => {\r\n        MeshoptDecoder.supported = wasm_factory.supported;\r\n        MeshoptDecoder.ready = Promise.resolve();\r\n        MeshoptDecoder.decodeVertexBuffer = wasm_factory.decodeVertexBuffer;\r\n        MeshoptDecoder.decodeIndexBuffer = wasm_factory.decodeIndexBuffer;\r\n        MeshoptDecoder.decodeIndexSequence = wasm_factory.decodeIndexSequence;\r\n        MeshoptDecoder.decodeGltfBuffer = wasm_factory.decodeGltfBuffer;\r\n        MeshoptDecoder.useWorkers = wasm_factory.useWorkers;\r\n        MeshoptDecoder.decodeGltfBufferAsync = wasm_factory.decodeGltfBufferAsync;\r\n        logID(14203);\r\n    });\r\n}\r\n\r\nfunction shouldUseWasmModule (): boolean {\r\n    if (NATIVE_CODE_BUNDLE_MODE === (NativeCodeBundleMode.BOTH as number)) {\r\n        return sys.hasFeature(sys.Feature.WASM);\r\n    } else if (NATIVE_CODE_BUNDLE_MODE === (NativeCodeBundleMode.WASM as number)) {\r\n        return true;\r\n    } else {\r\n        return false;\r\n    }\r\n}\r\n\r\nexport function InitDecoder (): Promise<void> {\r\n    const errorReport = (msg: any): void => { error(msg); };\r\n    return ensureWasmModuleReady().then(() => {\r\n        if (shouldUseWasmModule()) {\r\n            return Promise.all([\r\n                import('external:emscripten/meshopt/meshopt_decoder.wasm.js'),\r\n                import('external:emscripten/meshopt/meshopt_decoder.wasm.wasm'),\r\n            ]).then(([\r\n                { default: meshopt_wasm_factory },\r\n                { default: meshopt_wasm_url },\r\n            ]) => initDecoderWASM(meshopt_wasm_factory, meshopt_wasm_url));\r\n        } else {\r\n            return import('external:emscripten/meshopt/meshopt_decoder.asm.js').then(\r\n                ({ default: meshopt_asm_factory }) => initDecoderASM(meshopt_asm_factory),\r\n            );\r\n        }\r\n    }).catch(errorReport);\r\n}\r\n\r\nif (!CULL_MESHOPT) {\r\n    game.onPostInfrastructureInitDelegate.add(InitDecoder);\r\n}\r\n","/*\r\n Copyright (c) 2017-2023 Xiamen Yaji Software Co., Ltd.\r\n\r\n http://www.cocos.com\r\n\r\n Permission is hereby granted, free of charge, to any person obtaining a copy\r\n of this software and associated documentation files (the \"Software\"), to deal\r\n in the Software without restriction, including without limitation the rights to\r\n use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\r\n of the Software, and to permit persons to whom the Software is furnished to do so,\r\n subject to the following conditions:\r\n\r\n The above copyright notice and this permission notice shall be included in\r\n all copies or substantial portions of the Software.\r\n\r\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n THE SOFTWARE.\r\n*/\r\n\r\nimport { ccclass, serializable } from 'cc.decorator';\r\nimport { EDITOR } from 'internal:constants';\r\nimport { Asset } from '../../asset/assets/asset';\r\nimport { IDynamicGeometry } from '../../primitive/define';\r\nimport { BufferBlob } from '../misc/buffer-blob';\r\nimport { Skeleton } from './skeleton';\r\nimport { geometry, cclegacy, sys, warnID, Mat4, Quat, Vec3, assertIsTrue, murmurhash2_32_gc, errorID, halfToFloat, v3 } from '../../core';\r\nimport { RenderingSubMesh } from '../../asset/assets';\r\nimport {\r\n    Attribute, Device, Buffer, BufferInfo, AttributeName, BufferUsageBit, Feature, Format,\r\n    FormatInfos, FormatType, MemoryUsageBit, PrimitiveMode, getTypedArrayConstructor, DrawInfo, FormatInfo, deviceManager, FormatFeatureBit,\r\n} from '../../gfx';\r\nimport { Morph } from './morph';\r\nimport { MorphRendering, createMorphRendering } from './morph-rendering';\r\nimport { MeshoptDecoder } from '../misc/mesh-codec';\r\nimport zlib  from '../../../external/compression/zlib.min';\r\n\r\nconst vec3Add = Vec3.add;\r\nconst vec3MultiplyScalar = Vec3.multiplyScalar;\r\nconst vec3Subtract = Vec3.subtract;\r\nconst aabbTransform = geometry.AABB.transform;\r\nconst aabbFromPoints = geometry.AABB.fromPoints;\r\nconst vec3Max = Vec3.max;\r\nconst vec3Min = Vec3.min;\r\nconst vec3TransformQuat = Vec3.transformQuat;\r\nconst vec3TransformMat4 = Vec3.transformMat4;\r\n\r\nfunction getIndexStrideCtor (stride: number): Uint8ArrayConstructor | Uint16ArrayConstructor | Uint32ArrayConstructor {\r\n    switch (stride) {\r\n    case 1: return Uint8Array;\r\n    case 2: return Uint16Array;\r\n    case 4: return Uint32Array;\r\n    default: return Uint8Array;\r\n    }\r\n}\r\n\r\nexport declare namespace Mesh {\r\n    export interface IBufferView {\r\n        offset: number;\r\n        length: number;\r\n        count: number;\r\n        stride: number;\r\n    }\r\n\r\n    /**\r\n     * @en Vertex bundle, it describes a set of interleaved vertex attributes and their values.\r\n     * @zh 顶点块。顶点块描述了一组**交错排列**（interleaved）的顶点属性并存储了顶点属性的实际数据。<br>\r\n     * 交错排列是指在实际数据的缓冲区中，每个顶点的所有属性总是依次排列，并总是出现在下一个顶点的所有属性之前。\r\n     */\r\n    export interface IVertexBundle {\r\n        /**\r\n         * @en The actual value for all vertex attributes.\r\n         * You must use DataView to access the data.\r\n         * Because there is no guarantee that the starting offsets of all properties are byte aligned as required by TypedArray.\r\n         * @zh 所有顶点属性的实际数据块。\r\n         * 你必须使用 DataView 来读取数据。\r\n         * 因为不能保证所有属性的起始偏移都按 TypedArray 要求的字节对齐。\r\n         */\r\n        view: IBufferView;\r\n\r\n        /**\r\n         * @en All attributes included in the bundle\r\n         * @zh 包含的所有顶点属性。\r\n         */\r\n        attributes: Attribute[];\r\n    }\r\n\r\n    export interface IMeshCluster {\r\n        clusterView: IBufferView;\r\n        triangleView: IBufferView;\r\n        vertexView: IBufferView;\r\n        coneView?: IBufferView;\r\n    }\r\n\r\n    /**\r\n     * @en Sub mesh contains a list of primitives with the same type (Point, Line or Triangle)\r\n     * @zh 子网格。子网格由一系列相同类型的图元组成（例如点、线、面等）。\r\n     */\r\n    export interface ISubMesh {\r\n        /**\r\n         * @en The vertex bundle references used by the sub mesh.\r\n         * @zh 此子网格引用的顶点块，索引至网格的顶点块数组。\r\n         */\r\n        vertexBundelIndices: number[];\r\n\r\n        /**\r\n         * @en The primitive mode of the sub mesh\r\n         * @zh 此子网格的图元类型。\r\n         */\r\n        primitiveMode: PrimitiveMode;\r\n\r\n        /**\r\n         * @en The index data of the sub mesh\r\n         * @zh 此子网格使用的索引数据。\r\n         */\r\n        indexView?: IBufferView;\r\n\r\n        /**\r\n         * @en The joint map index in [[IStruct.jointMaps]]. Could be absent\r\n         * @zh 此子网格使用的关节索引映射表在 [[IStruct.jointMaps]] 中的索引。\r\n         * 如未定义或指向的映射表不存在，则默认 VB 内所有关节索引数据直接对应骨骼资源数据。\r\n         */\r\n        jointMapIndex?: number;\r\n\r\n        /**\r\n         * @en The cluster data of the sub mesh\r\n         */\r\n        cluster?: IMeshCluster;\r\n    }\r\n\r\n    /**\r\n     * @en dynamic info used to create dyanmic mesh\r\n     * @zh 动态信息，用于创建动态网格\r\n     */\r\n    export interface IDynamicInfo {\r\n        /**\r\n         * @en max submesh count\r\n         * @zh 最大子模型个数。\r\n         */\r\n        maxSubMeshes: number;\r\n\r\n        /**\r\n          * @en max submesh vertex count\r\n          * @zh 子模型最大顶点个数。\r\n          */\r\n        maxSubMeshVertices: number;\r\n\r\n        /**\r\n          * @en max submesh index count\r\n          * @zh 子模型最大索引个数。\r\n          */\r\n        maxSubMeshIndices: number;\r\n    }\r\n\r\n    /**\r\n     * @en dynamic struct\r\n     * @zh 动态结构体\r\n     */\r\n    export interface IDynamicStruct {\r\n        /**\r\n          * @en dynamic mesh info\r\n          * @zh 动态模型信息。\r\n          */\r\n        info: IDynamicInfo;\r\n\r\n        /**\r\n          * @en dynamic submesh bounds\r\n          * @zh 动态子模型包围盒。\r\n          */\r\n        bounds: geometry.AABB[];\r\n    }\r\n\r\n    /**\r\n     * @en The structure of the mesh\r\n     * @zh 描述了网格的结构。\r\n     */\r\n    export interface IStruct {\r\n        /**\r\n         * @en All vertex bundles of the mesh\r\n         * @zh 此网格所有的顶点块。\r\n         */\r\n        vertexBundles: IVertexBundle[];\r\n\r\n        /**\r\n         * @en All sub meshes\r\n         * @zh 此网格的所有子网格。\r\n         */\r\n        primitives: ISubMesh[];\r\n\r\n        /**\r\n         * @en The minimum position of all vertices in the mesh\r\n         * @zh （各分量都）小于等于此网格任何顶点位置的最大位置。\r\n         */\r\n        minPosition?: Vec3;\r\n\r\n        /**\r\n         * @en The maximum position of all vertices in the mesh\r\n         * @zh （各分量都）大于等于此网格任何顶点位置的最小位置。\r\n         */\r\n        maxPosition?: Vec3;\r\n\r\n        /**\r\n         * @en The joint index map list.\r\n         * @zh 此网格使用的关节索引映射关系列表，数组长度应为子模型中实际使用到的所有关节，\r\n         * 每个元素都对应一个原骨骼资源里的索引，按子模型 VB 内的实际索引排列。\r\n         */\r\n        jointMaps?: number[][];\r\n\r\n        /**\r\n         * @en The morph information of the mesh\r\n         * @zh 网格的形变数据\r\n         */\r\n        morph?: Morph;\r\n\r\n        /**\r\n         * @en The specific data of the dynamic mesh\r\n         * @zh 动态网格特有数据\r\n         */\r\n        dynamic?: IDynamicStruct;\r\n\r\n        /**\r\n         * @en Whether the mesh data is quantized to reduce memory usage\r\n         * @zh 此网格数据是否经过量化以减少内存占用。\r\n         */\r\n        quantized?: boolean;\r\n\r\n        /**\r\n         * @en Whether the mesh data is encoded to reduce memory usage\r\n         * @zh\r\n         */\r\n        encoded?: boolean;\r\n\r\n        /**\r\n         * @en Whether the mesh data is compressed to reduce memory usage\r\n         * @zh 此网格数据是否经过压缩以减少内存占用。\r\n         */\r\n        compressed?: boolean;\r\n\r\n        /**\r\n         * @en Whether the mesh contains cluster data\r\n         * @zh 此网格是否包含 cluster 数据。\r\n         */\r\n        cluster?: boolean;\r\n    }\r\n\r\n    /**\r\n     * @en The create info of the mesh\r\n     * @zh 网格创建信息\r\n     */\r\n    export interface ICreateInfo {\r\n        /**\r\n         * @en Mesh structure\r\n         * @zh 网格结构。\r\n         */\r\n        struct: Mesh.IStruct;\r\n\r\n        /**\r\n         * @en Mesh binary data\r\n         * @zh 网格二进制数据。\r\n         */\r\n        data: Uint8Array;\r\n    }\r\n}\r\n\r\nconst v3_1 = new Vec3();\r\nconst v3_2 = new Vec3();\r\nconst globalEmptyMeshBuffer = new Uint8Array();\r\n\r\n/**\r\n * @en A representation of a mesh asset\r\n * A mesh can contain multiple sub-mesh resources. The mesh mainly provides data such as vertices and indices for model instances.\r\n * @zh 代表一个网格资源\r\n * 一个网格可包含多个子网格资源，网格主要为模型实例提供顶点，索引等数据\r\n */\r\n@ccclass('cc.Mesh')\r\nexport class Mesh extends Asset {\r\n    /**\r\n     * @deprecated since v3.5.0, this is an engine private interface that will be removed in the future.\r\n     */\r\n    get _nativeAsset (): ArrayBuffer {\r\n        return this._data.buffer;\r\n    }\r\n    set _nativeAsset (value: ArrayBuffer) {\r\n        this._data = new Uint8Array(value);\r\n    }\r\n\r\n    /**\r\n     * @en The sub meshes count of the mesh.\r\n     * @zh 此网格的子网格数量。\r\n     * @deprecated Please use [[renderingSubMeshes.length]] instead\r\n     */\r\n    get subMeshCount (): number {\r\n        const renderingMesh = this.renderingSubMeshes;\r\n        return renderingMesh ? renderingMesh.length : 0;\r\n    }\r\n\r\n    /**\r\n     * @en The minimum position of all vertices in the mesh\r\n     * @zh （各分量都）小于等于此网格任何顶点位置的最大位置。\r\n     * @deprecated Please use [[struct.minPosition]] instead\r\n     */\r\n    get minPosition (): Readonly<Vec3> | undefined {\r\n        return this.struct.minPosition;\r\n    }\r\n\r\n    /**\r\n     * @en The maximum position of all vertices in the mesh\r\n     * @zh （各分量都）大于等于此网格任何顶点位置的最大位置。\r\n     * @deprecated Please use [[struct.maxPosition]] instead\r\n     */\r\n    get maxPosition (): Readonly<Vec3> | undefined {\r\n        return this.struct.maxPosition;\r\n    }\r\n\r\n    /**\r\n     * @en The struct of the mesh\r\n     * @zh 此网格的结构。\r\n     */\r\n    get struct (): Mesh.IStruct {\r\n        return this._struct;\r\n    }\r\n\r\n    /**\r\n     * @en The actual data of the mesh\r\n     * @zh 此网格的数据。\r\n     */\r\n    get data (): Uint8Array {\r\n        return this._data;\r\n    }\r\n\r\n    /**\r\n     * @en The hash of the mesh\r\n     * @zh 此网格的哈希值。\r\n     */\r\n    get hash (): number {\r\n    // hashes should already be computed offline, but if not, make one\r\n        if (!this._hash) { this._hash = murmurhash2_32_gc(this._data, 666); }\r\n        return this._hash;\r\n    }\r\n\r\n    /**\r\n     * @en The index of the joint buffer of all sub meshes in the joint map buffers\r\n     * @zh 所有子网格的关节索引集合\r\n     */\r\n    get jointBufferIndices (): number[] {\r\n        if (this._jointBufferIndices) { return this._jointBufferIndices; }\r\n        return this._jointBufferIndices = this._struct.primitives.map((p) => p.jointMapIndex || 0);\r\n    }\r\n\r\n    /**\r\n     * @en The sub meshes for rendering. Mesh could be split into different sub meshes for rendering.\r\n     * @zh 此网格创建的渲染网格。\r\n     */\r\n    public get renderingSubMeshes (): RenderingSubMesh[] {\r\n        this.initialize();\r\n        return this._renderingSubMeshes!;\r\n    }\r\n\r\n    /**\r\n     * @en morph rendering data\r\n     * @zh 变形渲染数据\r\n     */\r\n    public morphRendering: MorphRendering | null = null;\r\n\r\n    @serializable\r\n    private _struct: Mesh.IStruct = {\r\n        vertexBundles: [],\r\n        primitives: [],\r\n    };\r\n\r\n    @serializable\r\n    private _hash = 0;\r\n\r\n    private _data: Uint8Array = globalEmptyMeshBuffer;\r\n\r\n    private _initialized = false;\r\n\r\n    @serializable\r\n    private _allowDataAccess = true;\r\n\r\n    private _isMeshDataUploaded = false;\r\n\r\n    private _renderingSubMeshes: RenderingSubMesh[] | null = null;\r\n\r\n    private _boneSpaceBounds: Map<number, (geometry.AABB | null)[]> = new Map();\r\n\r\n    private _jointBufferIndices: number[] | null = null;\r\n\r\n    constructor (name?: string) {\r\n        super(name);\r\n    }\r\n\r\n    /**\r\n     * @en complete loading callback\r\n     * @zh 加载完成回调\r\n     */\r\n    public onLoaded (): void {\r\n        this.initialize();\r\n    }\r\n\r\n    /**\r\n     * @en mesh init\r\n     * @zh 网格初始化函数\r\n     */\r\n    public initialize (): void {\r\n        if (this._initialized) {\r\n            return;\r\n        }\r\n        this._initialized = true;\r\n\r\n        let info = { struct: this.struct, data: this.data };\r\n        if (info.struct.compressed) { // decompress mesh data\r\n            info = inflateMesh(info);\r\n        }\r\n        if (this.struct.encoded) { // decode mesh data\r\n            info = decodeMesh(info);\r\n        }\r\n        if (this.struct.quantized\r\n            && !(deviceManager.gfxDevice.getFormatFeatures(Format.RGB16F) & FormatFeatureBit.VERTEX_ATTRIBUTE)) {\r\n            // dequantize mesh data\r\n            info = dequantizeMesh(info);\r\n        }\r\n\r\n        this._struct = info.struct;\r\n        this._data = info.data;\r\n\r\n        if (this._struct.dynamic) {\r\n            const device: Device = deviceManager.gfxDevice;\r\n            const vertexBuffers: Buffer[] = [];\r\n            const subMeshes: RenderingSubMesh[] = [];\r\n\r\n            for (let i = 0; i < this._struct.vertexBundles.length; i++) {\r\n                const vertexBundle = this._struct.vertexBundles[i];\r\n                const vertexBuffer = device.createBuffer(new BufferInfo(\r\n                    BufferUsageBit.VERTEX | BufferUsageBit.TRANSFER_DST,\r\n                    MemoryUsageBit.DEVICE,\r\n                    vertexBundle.view.length,\r\n                    vertexBundle.view.stride,\r\n                ));\r\n\r\n                vertexBuffers.push(vertexBuffer);\r\n            }\r\n\r\n            for (let i = 0; i < this._struct.primitives.length; i++) {\r\n                const primitive = this._struct.primitives[i];\r\n                const indexView = primitive.indexView;\r\n                let indexBuffer: Buffer | null = null;\r\n\r\n                if (indexView) {\r\n                    indexBuffer = device.createBuffer(new BufferInfo(\r\n                        BufferUsageBit.INDEX | BufferUsageBit.TRANSFER_DST,\r\n                        MemoryUsageBit.DEVICE,\r\n                        indexView.length,\r\n                        indexView.stride,\r\n                    ));\r\n                }\r\n\r\n                const subVBs: Buffer[] = [];\r\n                for (let k = 0; k < primitive.vertexBundelIndices.length; k++) {\r\n                    const idx = primitive.vertexBundelIndices[k];\r\n                    subVBs.push(vertexBuffers[idx]);\r\n                }\r\n\r\n                const allAttributes: Attribute[] = [];\r\n                for (let k = 0; k < primitive.vertexBundelIndices.length; k++) {\r\n                    const idx = primitive.vertexBundelIndices[k];\r\n                    const attributes = this._struct.vertexBundles[idx].attributes;\r\n                    for (let j = 0; j < attributes.length; j++) {\r\n                        const attr = attributes[j];\r\n                        const attribute = new Attribute();\r\n                        attribute.copy(attr);\r\n                        allAttributes.push(attribute);\r\n                    }\r\n                }\r\n\r\n                const subMesh = new RenderingSubMesh(subVBs, allAttributes, primitive.primitiveMode, indexBuffer);\r\n                subMesh.drawInfo = new DrawInfo();\r\n                subMesh.mesh = this;\r\n                subMesh.subMeshIdx = i;\r\n\r\n                subMeshes.push(subMesh);\r\n            }\r\n\r\n            this._renderingSubMeshes = subMeshes;\r\n        } else {\r\n            const { buffer } = this._data;\r\n            const gfxDevice: Device = deviceManager.gfxDevice;\r\n            const vertexBuffers = this._createVertexBuffers(gfxDevice, buffer);\r\n            const indexBuffers: Buffer[] = [];\r\n            const subMeshes: RenderingSubMesh[] = [];\r\n\r\n            for (let i = 0; i < this._struct.primitives.length; i++) {\r\n                const prim = this._struct.primitives[i];\r\n                if (prim.vertexBundelIndices.length === 0) {\r\n                    continue;\r\n                }\r\n\r\n                let indexBuffer: Buffer | null = null;\r\n                let ib: Uint8Array | Uint16Array | Uint32Array | undefined;\r\n                if (prim.indexView) {\r\n                    const idxView = prim.indexView;\r\n\r\n                    let dstStride = idxView.stride;\r\n                    let dstSize = idxView.length;\r\n                    if (dstStride === 4 && !gfxDevice.hasFeature(Feature.ELEMENT_INDEX_UINT)) {\r\n                        const vertexCount = this._struct.vertexBundles[prim.vertexBundelIndices[0]].view.count;\r\n                        if (vertexCount >= 65536) {\r\n                            warnID(10001, vertexCount, 65536);\r\n                            continue; // Ignore this primitive\r\n                        } else {\r\n                            dstStride >>= 1; // Reduce to short.\r\n                            dstSize >>= 1;\r\n                        }\r\n                    }\r\n\r\n                    indexBuffer = gfxDevice.createBuffer(new BufferInfo(\r\n                        BufferUsageBit.INDEX,\r\n                        MemoryUsageBit.DEVICE,\r\n                        dstSize,\r\n                        dstStride,\r\n                    ));\r\n                    indexBuffers.push(indexBuffer);\r\n\r\n                    ib = new (getIndexStrideCtor(idxView.stride))(buffer, idxView.offset, idxView.count);\r\n                    if (idxView.stride !== dstStride) {\r\n                        ib = getIndexStrideCtor(dstStride).from(ib);\r\n                    }\r\n                    indexBuffer.update(ib);\r\n                }\r\n\r\n                const vbReference = prim.vertexBundelIndices.map((idx) => vertexBuffers[idx]);\r\n\r\n                const gfxAttributes: Attribute[] = [];\r\n                if (prim.vertexBundelIndices.length > 0) {\r\n                    const idx = prim.vertexBundelIndices[0];\r\n                    const vertexBundle = this._struct.vertexBundles[idx];\r\n                    const attrs = vertexBundle.attributes;\r\n                    for (let j = 0; j < attrs.length; ++j) {\r\n                        const attr = attrs[j];\r\n                        gfxAttributes[j] = new Attribute(attr.name, attr.format, attr.isNormalized, attr.stream, attr.isInstanced, attr.location);\r\n                    }\r\n                }\r\n\r\n                const subMesh = new RenderingSubMesh(vbReference, gfxAttributes, prim.primitiveMode, indexBuffer);\r\n                subMesh.mesh = this; subMesh.subMeshIdx = i;\r\n\r\n                subMeshes.push(subMesh);\r\n            }\r\n\r\n            this._renderingSubMeshes = subMeshes;\r\n\r\n            if (this._struct.morph) {\r\n                this.morphRendering = createMorphRendering(this, gfxDevice);\r\n            }\r\n\r\n            this._isMeshDataUploaded = true;\r\n            if (!this._allowDataAccess && !EDITOR) {\r\n                this.releaseData();\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @en update dynamic sub mesh geometry\r\n     * @zh 更新动态子网格的几何数据\r\n     * @param primitiveIndex @en sub mesh index @zh 子网格索引\r\n     * @param dynamicGeometry @en sub mesh geometry data @zh 子网格几何数据\r\n     */\r\n    public updateSubMesh (primitiveIndex: number, dynamicGeometry: IDynamicGeometry): void {\r\n        if (!this._struct.dynamic) {\r\n            warnID(14200);\r\n            return;\r\n        }\r\n\r\n        if (primitiveIndex >= this._struct.primitives.length) {\r\n            warnID(14201);\r\n            return;\r\n        }\r\n\r\n        const buffers: Float32Array[] = [];\r\n        if (dynamicGeometry.positions.length > 0) {\r\n            buffers.push(dynamicGeometry.positions);\r\n        }\r\n\r\n        if (dynamicGeometry.normals && dynamicGeometry.normals.length > 0) {\r\n            buffers.push(dynamicGeometry.normals);\r\n        }\r\n\r\n        if (dynamicGeometry.uvs && dynamicGeometry.uvs.length > 0) {\r\n            buffers.push(dynamicGeometry.uvs);\r\n        }\r\n\r\n        if (dynamicGeometry.tangents && dynamicGeometry.tangents.length > 0) {\r\n            buffers.push(dynamicGeometry.tangents);\r\n        }\r\n\r\n        if (dynamicGeometry.colors && dynamicGeometry.colors.length > 0) {\r\n            buffers.push(dynamicGeometry.colors);\r\n        }\r\n\r\n        if (dynamicGeometry.customAttributes) {\r\n            for (let k = 0; k < dynamicGeometry.customAttributes.length; k++) {\r\n                buffers.push(dynamicGeometry.customAttributes[k].values);\r\n            }\r\n        }\r\n\r\n        const dynamic = this._struct.dynamic;\r\n        const info = dynamic.info;\r\n        const primitive = this._struct.primitives[primitiveIndex];\r\n        const subMesh = this._renderingSubMeshes![primitiveIndex];\r\n        const drawInfo = subMesh.drawInfo!;\r\n\r\n        // update _data & buffer\r\n        for (let index = 0; index < buffers.length; index++) {\r\n            const vertices = buffers[index];\r\n            const bundle = this._struct.vertexBundles[primitive.vertexBundelIndices[index]];\r\n            const stride = bundle.view.stride;\r\n            const vertexCount = vertices.byteLength / stride;\r\n            const updateSize  = vertices.byteLength;\r\n            const dstBuffer   = new Uint8Array(this._data.buffer, bundle.view.offset, updateSize);\r\n            const srcBuffer    = new Uint8Array(vertices.buffer, vertices.byteOffset, updateSize);\r\n            const vertexBuffer = subMesh.vertexBuffers[index];\r\n            assertIsTrue(vertexCount <= info.maxSubMeshVertices, 'Too many vertices.');\r\n\r\n            if (updateSize > 0) {\r\n                dstBuffer.set(srcBuffer);\r\n                vertexBuffer.update(srcBuffer, updateSize);\r\n            }\r\n\r\n            bundle.view.count = vertexCount;\r\n            drawInfo.vertexCount = vertexCount;\r\n        }\r\n\r\n        if (primitive.indexView) {\r\n            const indexView = primitive.indexView;\r\n            const stride       = indexView.stride;\r\n            const indexCount   = (stride === 2) ? dynamicGeometry.indices16!.length : dynamicGeometry.indices32!.length;\r\n            const updateSize   = indexCount * stride;\r\n            const dstBuffer   = new Uint8Array(this._data.buffer, indexView.offset, updateSize);\r\n            const srcBuffer    = (stride === 2) ? new Uint8Array(dynamicGeometry.indices16!.buffer, dynamicGeometry.indices16!.byteOffset, updateSize)\r\n                : new Uint8Array(dynamicGeometry.indices32!.buffer, dynamicGeometry.indices32!.byteOffset, updateSize);\r\n            const indexBuffer  = subMesh.indexBuffer!;\r\n            assertIsTrue(indexCount <= info.maxSubMeshIndices, 'Too many indices.');\r\n\r\n            if (updateSize > 0) {\r\n                dstBuffer.set(srcBuffer);\r\n                indexBuffer.update(srcBuffer, updateSize);\r\n            }\r\n\r\n            indexView.count     = indexCount;\r\n            drawInfo.indexCount = indexCount;\r\n        }\r\n\r\n        // update bound\r\n        if (dynamicGeometry.minPos && dynamicGeometry.maxPos) {\r\n            const minPos = v3(dynamicGeometry.minPos.x, dynamicGeometry.minPos.y, dynamicGeometry.minPos.z);\r\n            const maxPos = v3(dynamicGeometry.maxPos.x, dynamicGeometry.maxPos.y, dynamicGeometry.maxPos.z);\r\n\r\n            if (!dynamic.bounds[primitiveIndex]) {\r\n                dynamic.bounds[primitiveIndex] = new geometry.AABB();\r\n            }\r\n\r\n            aabbFromPoints(dynamic.bounds[primitiveIndex], minPos, maxPos);\r\n\r\n            const subMin = v3();\r\n            const subMax = v3();\r\n            dynamic.bounds.forEach((bound) => {\r\n                if (bound) {\r\n                    bound.getBoundary(subMin, subMax);\r\n                    vec3Min(minPos, subMin, minPos);\r\n                    vec3Max(maxPos, subMax, maxPos);\r\n                }\r\n            });\r\n\r\n            this._struct.minPosition = v3(minPos.x, minPos.y, minPos.z);\r\n            this._struct.maxPosition = v3(maxPos.x, maxPos.y, maxPos.z);\r\n        }\r\n\r\n        subMesh.invalidateGeometricInfo();\r\n    }\r\n\r\n    /**\r\n     * @en Destroy the mesh and release all related GPU resources\r\n     * @zh 销毁此网格，并释放它占有的所有 GPU 资源。\r\n     */\r\n    public destroy (): boolean {\r\n        this.destroyRenderingMesh();\r\n        return super.destroy();\r\n    }\r\n\r\n    /**\r\n     * @en Release all related GPU resources\r\n     * @zh 释放此网格占有的所有 GPU 资源。\r\n     */\r\n    public destroyRenderingMesh (): void {\r\n        if (this._renderingSubMeshes) {\r\n            for (let i = 0; i < this._renderingSubMeshes.length; i++) {\r\n                this._renderingSubMeshes[i].destroy();\r\n            }\r\n            this._renderingSubMeshes = null;\r\n            this._initialized = false;\r\n            this._isMeshDataUploaded = false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @en Reset the struct and data of the mesh\r\n     * @zh 重置此网格的结构和数据。\r\n     * @param struct @en The new struct @zh 新结构\r\n     * @param data @en The new data @zh 新数据\r\n     * @deprecated Will be removed in v3.0.0, please use [[reset]] instead\r\n     */\r\n    public assign (struct: Mesh.IStruct, data: Uint8Array): void {\r\n        this.reset({\r\n            struct,\r\n            data,\r\n        });\r\n    }\r\n\r\n    /**\r\n     * @en Reset the mesh with mesh creation information\r\n     * @zh 重置此网格。\r\n     * @param info @en Mesh creation information including struct and data @zh 网格创建信息，包含结构及数据\r\n     */\r\n    public reset (info: Mesh.ICreateInfo): void {\r\n        this.destroyRenderingMesh();\r\n        this._struct = info.struct;\r\n        this._data = info.data;\r\n        this._hash = 0;\r\n    }\r\n\r\n    /**\r\n     * @en Get [[geometry.AABB]] bounds in the skeleton's bone space\r\n     * @zh 获取骨骼变换空间内下的 [[geometry.AABB]] 包围盒\r\n     * @param skeleton @en skeleton data @zh 骨骼信息\r\n     * @param skeleton @en skeleton data @zh 骨骼信息\r\n     */\r\n    public getBoneSpaceBounds (skeleton: Skeleton): (geometry.AABB | null)[] {\r\n        if (this._boneSpaceBounds.has(skeleton.hash)) {\r\n            return this._boneSpaceBounds.get(skeleton.hash)!;\r\n        }\r\n        const bounds: (geometry.AABB | null)[] = [];\r\n        this._boneSpaceBounds.set(skeleton.hash, bounds);\r\n        const valid: boolean[] = [];\r\n        const { bindposes } = skeleton;\r\n        for (let i = 0; i < bindposes.length; i++) {\r\n            bounds.push(new geometry.AABB(Infinity, Infinity, Infinity, -Infinity, -Infinity, -Infinity));\r\n            valid.push(false);\r\n        }\r\n        const { primitives } = this._struct;\r\n        for (let p = 0; p < primitives.length; p++) {\r\n            const joints = this.readAttribute(p, AttributeName.ATTR_JOINTS);\r\n            const weights = this.readAttribute(p, AttributeName.ATTR_WEIGHTS);\r\n            const positions = this.readAttribute(p, AttributeName.ATTR_POSITION);\r\n            if (!joints || !weights || !positions) { continue; }\r\n            const vertCount = Math.min(joints.length / 4, weights.length / 4, positions.length / 3);\r\n            for (let i = 0; i < vertCount; i++) {\r\n                Vec3.set(v3_1, positions[3 * i + 0], positions[3 * i + 1], positions[3 * i + 2]);\r\n                for (let j = 0; j < 4; ++j) {\r\n                    const idx = 4 * i + j;\r\n                    const joint = joints[idx];\r\n                    if (weights[idx] === 0 || joint >= bindposes.length) { continue; }\r\n                    vec3TransformMat4(v3_2, v3_1, bindposes[joint]);\r\n                    valid[joint] = true;\r\n                    const b = bounds[joint]!;\r\n                    vec3Min(b.center, b.center, v3_2);\r\n                    vec3Max(b.halfExtents, b.halfExtents, v3_2);\r\n                }\r\n            }\r\n        }\r\n        for (let i = 0; i < bindposes.length; i++) {\r\n            const b = bounds[i]!;\r\n            if (!valid[i]) { bounds[i] = null; } else { aabbFromPoints(b, b.center, b.halfExtents); }\r\n        }\r\n        return bounds;\r\n    }\r\n\r\n    /**\r\n     * @en Merge the given mesh into the current mesh\r\n     * @zh 合并指定的网格到此网格中。\r\n     * @param mesh @en The mesh to be merged @zh 要合并的网格\r\n     * @param worldMatrix @en The world matrix of the given mesh @zh 给定网格的模型变换矩阵\r\n     * @param validate @en Whether to validate the mesh @zh 是否验证网格顶点布局\r\n     * @returns @en whether the merging was successful or not @zh 返回合并成功与否\r\n     */\r\n    public merge (mesh: Mesh, worldMatrix?: Mat4, validate?: boolean): boolean {\r\n        if (validate) {\r\n            if (!this.validateMergingMesh(mesh)) {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        const vec3_temp = new Vec3();\r\n        const rotate = worldMatrix && new Quat();\r\n        const boundingBox = worldMatrix && new geometry.AABB();\r\n        if (rotate) {\r\n            worldMatrix.getRotation(rotate);\r\n        }\r\n        if (!this._initialized) {\r\n            const struct = JSON.parse(JSON.stringify(mesh._struct)) as Mesh.IStruct;\r\n            const data = mesh._data.slice();\r\n            if (worldMatrix) {\r\n                if (struct.maxPosition && struct.minPosition) {\r\n                    vec3Add(boundingBox!.center, struct.maxPosition, struct.minPosition);\r\n                    vec3MultiplyScalar(boundingBox!.center, boundingBox!.center, 0.5);\r\n                    vec3Subtract(boundingBox!.halfExtents, struct.maxPosition, struct.minPosition);\r\n                    vec3MultiplyScalar(boundingBox!.halfExtents, boundingBox!.halfExtents, 0.5);\r\n                    aabbTransform(boundingBox!, boundingBox!, worldMatrix);\r\n                    vec3Add(struct.maxPosition, boundingBox!.center, boundingBox!.halfExtents);\r\n                    vec3Subtract(struct.minPosition, boundingBox!.center, boundingBox!.halfExtents);\r\n                }\r\n                for (let i = 0; i < struct.vertexBundles.length; i++) {\r\n                    const vtxBdl = struct.vertexBundles[i];\r\n                    for (let j = 0; j < vtxBdl.attributes.length; j++) {\r\n                        if (vtxBdl.attributes[j].name === (AttributeName.ATTR_POSITION as string)\r\n                            || vtxBdl.attributes[j].name === (AttributeName.ATTR_NORMAL as string)) {\r\n                            const { format } = vtxBdl.attributes[j];\r\n\r\n                            const inputView = new DataView(\r\n                                data.buffer,\r\n                                vtxBdl.view.offset + getOffset(vtxBdl.attributes, j),\r\n                            );\r\n\r\n                            const reader = getReader(inputView, format);\r\n                            const writer = getWriter(inputView, format);\r\n                            if (!reader || !writer) {\r\n                                continue;\r\n                            }\r\n                            const vertexCount = vtxBdl.view.count;\r\n\r\n                            const vertexStride = vtxBdl.view.stride;\r\n                            const attrComponentByteLength = getComponentByteLength(format);\r\n                            for (let vtxIdx = 0; vtxIdx < vertexCount; vtxIdx++) {\r\n                                const xOffset = vtxIdx * vertexStride;\r\n                                const yOffset = xOffset + attrComponentByteLength;\r\n                                const zOffset = yOffset + attrComponentByteLength;\r\n                                vec3_temp.set(reader(xOffset), reader(yOffset), reader(zOffset));\r\n                                switch (vtxBdl.attributes[j].name) {\r\n                                case AttributeName.ATTR_POSITION:\r\n                                    vec3_temp.transformMat4(worldMatrix);\r\n                                    break;\r\n                                case AttributeName.ATTR_NORMAL:\r\n                                    vec3TransformQuat(vec3_temp, vec3_temp, rotate!);\r\n                                    break;\r\n                                default:\r\n                                }\r\n                                writer(xOffset, vec3_temp.x);\r\n                                writer(yOffset, vec3_temp.y);\r\n                                writer(zOffset, vec3_temp.z);\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            this.reset({ struct, data });\r\n            this.initialize();\r\n            return true;\r\n        }\r\n\r\n        // merge buffer\r\n        const bufferBlob = new BufferBlob();\r\n\r\n        // merge vertex buffer\r\n        let vertCount = 0;\r\n        let vertStride = 0;\r\n        let srcOffset = 0;\r\n        let dstOffset = 0;\r\n        let vb: ArrayBuffer;\r\n        let vbView: Uint8Array;\r\n        let srcVBView: Uint8Array;\r\n        let dstVBView: Uint8Array;\r\n        let srcAttrOffset = 0;\r\n        let srcVBOffset = 0;\r\n        let dstVBOffset = 0;\r\n        let attrSize = 0;\r\n        let dstAttrView: Uint8Array;\r\n        let hasAttr = false;\r\n\r\n        const vertexBundles = new Array<Mesh.IVertexBundle>(this._struct.vertexBundles.length);\r\n        for (let i = 0; i < this._struct.vertexBundles.length; ++i) {\r\n            const bundle = this._struct.vertexBundles[i];\r\n            const dstBundle = mesh._struct.vertexBundles[i];\r\n\r\n            srcOffset = bundle.view.offset;\r\n            dstOffset = dstBundle.view.offset;\r\n            vertStride = bundle.view.stride;\r\n            vertCount = bundle.view.count + dstBundle.view.count;\r\n\r\n            vb = new ArrayBuffer(vertCount * vertStride);\r\n            vbView = new Uint8Array(vb);\r\n\r\n            srcVBView = this._data.subarray(srcOffset, srcOffset + bundle.view.length);\r\n            srcOffset += srcVBView.length;\r\n            dstVBView = mesh._data.subarray(dstOffset, dstOffset + dstBundle.view.length);\r\n            dstOffset += dstVBView.length;\r\n\r\n            vbView.set(srcVBView);\r\n\r\n            srcAttrOffset = 0;\r\n            for (const attr of bundle.attributes) {\r\n                dstVBOffset = 0;\r\n                hasAttr = false;\r\n                for (const dstAttr of dstBundle.attributes) {\r\n                    if (attr.name === dstAttr.name && attr.format === dstAttr.format) {\r\n                        hasAttr = true;\r\n                        break;\r\n                    }\r\n                    dstVBOffset += FormatInfos[dstAttr.format].size;\r\n                }\r\n                if (hasAttr) {\r\n                    attrSize = FormatInfos[attr.format].size;\r\n                    srcVBOffset = bundle.view.length + srcAttrOffset;\r\n                    for (let v = 0; v < dstBundle.view.count; ++v) {\r\n                        dstAttrView = dstVBView.subarray(dstVBOffset, dstVBOffset + attrSize);\r\n                        vbView.set(dstAttrView, srcVBOffset);\r\n                        if ((attr.name === (AttributeName.ATTR_POSITION as string)\r\n                            || attr.name === (AttributeName.ATTR_NORMAL as string)) && worldMatrix) {\r\n                            const f32_temp = new Float32Array(vbView.buffer, srcVBOffset, 3);\r\n                            vec3_temp.set(f32_temp[0], f32_temp[1], f32_temp[2]);\r\n                            switch (attr.name) {\r\n                            case AttributeName.ATTR_POSITION:\r\n                                vec3_temp.transformMat4(worldMatrix);\r\n                                break;\r\n                            case AttributeName.ATTR_NORMAL:\r\n                                vec3TransformQuat(vec3_temp, vec3_temp, rotate!);\r\n                                break;\r\n                            default:\r\n                            }\r\n                            f32_temp[0] = vec3_temp.x;\r\n                            f32_temp[1] = vec3_temp.y;\r\n                            f32_temp[2] = vec3_temp.z;\r\n                        }\r\n                        srcVBOffset += bundle.view.stride;\r\n                        dstVBOffset += dstBundle.view.stride;\r\n                    }\r\n                }\r\n                srcAttrOffset += FormatInfos[attr.format].size;\r\n            }\r\n\r\n            vertexBundles[i] = {\r\n                attributes: bundle.attributes,\r\n                view: {\r\n                    offset: bufferBlob.getLength(),\r\n                    length: vb.byteLength,\r\n                    count: vertCount,\r\n                    stride: vertStride,\r\n                },\r\n            };\r\n\r\n            bufferBlob.addBuffer(vb);\r\n        }\r\n\r\n        // merge index buffer\r\n        let idxCount = 0;\r\n        let idxStride = 2;\r\n        let ibView: Uint8Array | Uint16Array | Uint32Array;\r\n        let srcIBView: Uint8Array | Uint16Array | Uint32Array;\r\n        let dstIBView: Uint8Array | Uint16Array | Uint32Array;\r\n\r\n        const primitives: Mesh.ISubMesh[] = new Array<Mesh.ISubMesh>(this._struct.primitives.length);\r\n        for (let i = 0; i < this._struct.primitives.length; ++i) {\r\n            const prim = this._struct.primitives[i];\r\n            const dstPrim = mesh._struct.primitives[i];\r\n\r\n            primitives[i] = {\r\n                primitiveMode: prim.primitiveMode,\r\n                vertexBundelIndices: prim.vertexBundelIndices,\r\n            };\r\n\r\n            let vertBatchCount = 0;\r\n            for (const bundleIdx of prim.vertexBundelIndices) {\r\n                vertBatchCount = Math.max(vertBatchCount, this._struct.vertexBundles[bundleIdx].view.count);\r\n            }\r\n\r\n            if (prim.indexView && dstPrim.indexView) {\r\n                idxCount = prim.indexView.count;\r\n                idxCount += dstPrim.indexView.count;\r\n\r\n                srcOffset = prim.indexView.offset;\r\n                dstOffset = dstPrim.indexView.offset;\r\n\r\n                if (idxCount < 256) {\r\n                    idxStride = 1;\r\n                } else if (idxCount < 65536) {\r\n                    idxStride = 2;\r\n                } else {\r\n                    idxStride = 4;\r\n                }\r\n\r\n                const ib = new ArrayBuffer(idxCount * idxStride);\r\n                if (idxStride === 2) {\r\n                    ibView = new Uint16Array(ib);\r\n                } else if (idxStride === 1) {\r\n                    ibView = new Uint8Array(ib);\r\n                } else { // Uint32\r\n                    ibView = new Uint32Array(ib);\r\n                }\r\n\r\n                // merge src indices\r\n                if (prim.indexView.stride === 2) {\r\n                    srcIBView = new Uint16Array(this._data.buffer, srcOffset, prim.indexView.count);\r\n                } else if (prim.indexView.stride === 1) {\r\n                    srcIBView = new Uint8Array(this._data.buffer, srcOffset, prim.indexView.count);\r\n                } else { // Uint32\r\n                    srcIBView = new Uint32Array(this._data.buffer, srcOffset, prim.indexView.count);\r\n                }\r\n\r\n                if (idxStride === prim.indexView.stride) {\r\n                    ibView.set(srcIBView);\r\n                } else {\r\n                    for (let n = 0; n < prim.indexView.count; ++n) {\r\n                        ibView[n] = srcIBView[n];\r\n                    }\r\n                }\r\n                srcOffset += prim.indexView.length;\r\n\r\n                // merge dst indices\r\n                if (dstPrim.indexView.stride === 2) {\r\n                    dstIBView = new Uint16Array(mesh._data.buffer, dstOffset, dstPrim.indexView.count);\r\n                } else if (dstPrim.indexView.stride === 1) {\r\n                    dstIBView = new Uint8Array(mesh._data.buffer, dstOffset, dstPrim.indexView.count);\r\n                } else { // Uint32\r\n                    dstIBView = new Uint32Array(mesh._data.buffer, dstOffset, dstPrim.indexView.count);\r\n                }\r\n                for (let n = 0; n < dstPrim.indexView.count; ++n) {\r\n                    ibView[prim.indexView.count + n] = vertBatchCount + dstIBView[n];\r\n                }\r\n                dstOffset += dstPrim.indexView.length;\r\n\r\n                primitives[i].indexView = {\r\n                    offset: bufferBlob.getLength(),\r\n                    length: ib.byteLength,\r\n                    count: idxCount,\r\n                    stride: idxStride,\r\n                };\r\n\r\n                bufferBlob.setNextAlignment(idxStride);\r\n                bufferBlob.addBuffer(ib);\r\n            }\r\n        }\r\n\r\n        // Create mesh struct.\r\n        const meshStruct: Mesh.IStruct = {\r\n            vertexBundles,\r\n            primitives,\r\n            minPosition: this._struct.minPosition,\r\n            maxPosition: this._struct.maxPosition,\r\n        };\r\n\r\n        if (meshStruct.minPosition && mesh._struct.minPosition && meshStruct.maxPosition && mesh._struct.maxPosition) {\r\n            if (worldMatrix) {\r\n                vec3Add(boundingBox!.center, mesh._struct.maxPosition, mesh._struct.minPosition);\r\n                vec3MultiplyScalar(boundingBox!.center, boundingBox!.center, 0.5);\r\n                vec3Subtract(boundingBox!.halfExtents, mesh._struct.maxPosition, mesh._struct.minPosition);\r\n                vec3MultiplyScalar(boundingBox!.halfExtents, boundingBox!.halfExtents, 0.5);\r\n                aabbTransform(boundingBox!, boundingBox!, worldMatrix);\r\n                vec3Add(vec3_temp, boundingBox!.center, boundingBox!.halfExtents);\r\n                vec3Max(meshStruct.maxPosition, meshStruct.maxPosition, vec3_temp);\r\n                vec3Subtract(vec3_temp, boundingBox!.center, boundingBox!.halfExtents);\r\n                vec3Min(meshStruct.minPosition, meshStruct.minPosition, vec3_temp);\r\n            } else {\r\n                vec3Min(meshStruct.minPosition, meshStruct.minPosition, mesh._struct.minPosition);\r\n                vec3Max(meshStruct.maxPosition, meshStruct.maxPosition, mesh._struct.maxPosition);\r\n            }\r\n        }\r\n\r\n        // Create mesh.\r\n        this.reset({\r\n            struct: meshStruct,\r\n            data: new Uint8Array(bufferBlob.getCombined()),\r\n        });\r\n        this.initialize();\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @en Validation for whether the given mesh can be merged into the current mesh.\r\n     * To pass the validation, it must satisfy either of these two requirements:\r\n     * - When the current mesh have no data\r\n     * - When the two mesh have the same vertex bundle count, the same sub meshes count, and the same sub mesh layout.\r\n     *\r\n     * Same mesh layout means:\r\n     * - They have the same primitive type and reference to the same amount vertex bundle with the same indices.\r\n     * - And they all have or don't have index view\r\n     * @zh 验证指定网格是否可以合并至当前网格。\r\n     *\r\n     * 当满足以下条件之一时，指定网格可以合并至当前网格：\r\n     *  - 当前网格无数据而待合并网格有数据；\r\n     *  - 它们的顶点块数目相同且对应顶点块的布局一致，并且它们的子网格数目相同且对应子网格的布局一致。\r\n     *\r\n     * 两个顶点块布局一致当且仅当：\r\n     *  - 它们具有相同数量的顶点属性且对应的顶点属性具有相同的属性格式。\r\n     *\r\n     * 两个子网格布局一致，当且仅当：\r\n     *  - 它们具有相同的图元类型并且引用相同数量、相同索引的顶点块；并且，\r\n     *  - 要么都需要索引绘制，要么都不需要索引绘制。\r\n     * @param mesh @en The other mesh to be validated @zh 待验证的网格\r\n     */\r\n    public validateMergingMesh (mesh: Mesh): boolean {\r\n        // dynamic mesh is not allowed to merge.\r\n        if (this._struct.dynamic || mesh._struct.dynamic) {\r\n            return false;\r\n        }\r\n\r\n        // validate vertex bundles\r\n        if (this._struct.vertexBundles.length !== mesh._struct.vertexBundles.length) {\r\n            return false;\r\n        }\r\n\r\n        for (let i = 0; i < this._struct.vertexBundles.length; ++i) {\r\n            const bundle = this._struct.vertexBundles[i];\r\n            const dstBundle = mesh._struct.vertexBundles[i];\r\n\r\n            if (bundle.attributes.length !== dstBundle.attributes.length) {\r\n                return false;\r\n            }\r\n            for (let j = 0; j < bundle.attributes.length; ++j) {\r\n                if (bundle.attributes[j].format !== dstBundle.attributes[j].format) {\r\n                    return false;\r\n                }\r\n            }\r\n        }\r\n\r\n        // validate primitives\r\n        if (this._struct.primitives.length !== mesh._struct.primitives.length) {\r\n            return false;\r\n        }\r\n        for (let i = 0; i < this._struct.primitives.length; ++i) {\r\n            const prim = this._struct.primitives[i];\r\n            const dstPrim = mesh._struct.primitives[i];\r\n            if (prim.vertexBundelIndices.length !== dstPrim.vertexBundelIndices.length) {\r\n                return false;\r\n            }\r\n            for (let j = 0; j < prim.vertexBundelIndices.length; ++j) {\r\n                if (prim.vertexBundelIndices[j] !== dstPrim.vertexBundelIndices[j]) {\r\n                    return false;\r\n                }\r\n            }\r\n            if (prim.primitiveMode !== dstPrim.primitiveMode) {\r\n                return false;\r\n            }\r\n\r\n            if (prim.indexView) {\r\n                if (dstPrim.indexView === undefined) {\r\n                    return false;\r\n                }\r\n            } else if (dstPrim.indexView) {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @en Read the requested attribute of the given sub mesh\r\n     * @zh 读取子网格的指定属性。\r\n     * @param primitiveIndex @en Sub mesh index @zh 子网格索引\r\n     * @param attributeName @en Attribute name @zh 属性名称\r\n     * @returns @en Return null if not found or can't read, otherwise, will create a large enough typed array to contain all data of the attribute,\r\n     * the array type will match the data type of the attribute. @zh 读取失败返回 null， 否则返回对应的类型数组\r\n     */\r\n    public readAttribute (primitiveIndex: number, attributeName: AttributeName): TypedArray | null {\r\n        let result: TypedArray | null = null;\r\n        this._accessAttribute(primitiveIndex, attributeName, (vertexBundle, iAttribute) => {\r\n            const vertexCount = vertexBundle.view.count;\r\n            const { format } = vertexBundle.attributes[iAttribute];\r\n            const StorageConstructor = getTypedArrayConstructor(FormatInfos[format]);\r\n            if (vertexCount === 0) {\r\n                return;\r\n            }\r\n\r\n            const inputView = new DataView(\r\n                this._data.buffer,\r\n                vertexBundle.view.offset + getOffset(vertexBundle.attributes, iAttribute),\r\n            );\r\n\r\n            const formatInfo = FormatInfos[format];\r\n            const reader = getReader(inputView, format);\r\n            if (!StorageConstructor || !reader) {\r\n                return;\r\n            }\r\n            const componentCount = formatInfo.count;\r\n            const storage = new StorageConstructor(vertexCount * componentCount);\r\n            const inputStride = vertexBundle.view.stride;\r\n            for (let iVertex = 0; iVertex < vertexCount; ++iVertex) {\r\n                for (let iComponent = 0; iComponent < componentCount; ++iComponent) {\r\n                    storage[componentCount * iVertex + iComponent] = reader(inputStride * iVertex + storage.BYTES_PER_ELEMENT * iComponent);\r\n                }\r\n            }\r\n            result = storage;\r\n        });\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * @en Read the requested attribute of the given sub mesh and fill into the given buffer.\r\n     * @zh 读取子网格的指定属性到目标缓冲区中。\r\n     * @param primitiveIndex @en Sub mesh index @zh 子网格索引\r\n     * @param attributeName @en Attribute name @zh 属性名称\r\n     * @param buffer @en The target array buffer @zh 目标缓冲区\r\n     * @param stride @en attribute stride @zh 属性跨距\r\n     * @param offset @en The offset of the first attribute in the target buffer @zh 第一个属性在目标缓冲区的偏移\r\n     * @returns @en false if failed to access attribute, true otherwise @zh 是否成功拷贝\r\n     */\r\n    public copyAttribute (primitiveIndex: number, attributeName: AttributeName, buffer: ArrayBuffer, stride: number, offset: number): boolean {\r\n        let written = false;\r\n        this._accessAttribute(primitiveIndex, attributeName, (vertexBundle, iAttribute) => {\r\n            const vertexCount = vertexBundle.view.count;\r\n            if (vertexCount === 0) {\r\n                written = true;\r\n                return;\r\n            }\r\n            const { format } = vertexBundle.attributes[iAttribute];\r\n\r\n            const inputView = new DataView(\r\n                this._data.buffer,\r\n                vertexBundle.view.offset + getOffset(vertexBundle.attributes, iAttribute),\r\n            );\r\n\r\n            const outputView = new DataView(buffer, offset);\r\n\r\n            const formatInfo = FormatInfos[format];\r\n\r\n            const reader = getReader(inputView, format);\r\n            const writer = getWriter(outputView, format);\r\n            if (!reader || !writer) {\r\n                return;\r\n            }\r\n\r\n            const componentCount = formatInfo.count;\r\n\r\n            const inputStride = vertexBundle.view.stride;\r\n            const inputComponentByteLength = getComponentByteLength(format);\r\n            const outputStride = stride;\r\n            const outputComponentByteLength = inputComponentByteLength;\r\n            for (let iVertex = 0; iVertex < vertexCount; ++iVertex) {\r\n                for (let iComponent = 0; iComponent < componentCount; ++iComponent) {\r\n                    const inputOffset = inputStride * iVertex + inputComponentByteLength * iComponent;\r\n                    const outputOffset = outputStride * iVertex + outputComponentByteLength * iComponent;\r\n                    writer(outputOffset, reader(inputOffset));\r\n                }\r\n            }\r\n            written = true;\r\n        });\r\n        return written;\r\n    }\r\n\r\n    /**\r\n     * @en Read the indices data of the given sub mesh\r\n     * @zh 读取子网格的索引数据。\r\n     * @param primitiveIndex @en Sub mesh index @zh 子网格索引\r\n     * @returns @en Return null if not found or can't read, otherwise, will create a large enough typed array to contain all indices data,\r\n     * the array type will use the corresponding stride size. @zh 读取失败返回 null，否则返回索引数据\r\n     */\r\n    public readIndices (primitiveIndex: number): Uint8Array | Uint16Array | Uint32Array | null {\r\n        if (primitiveIndex >= this._struct.primitives.length) {\r\n            return null;\r\n        }\r\n        const primitive = this._struct.primitives[primitiveIndex];\r\n        if (!primitive.indexView) {\r\n            return null;\r\n        }\r\n        const { stride } = primitive.indexView;\r\n        const Ctor = stride === 1 ? Uint8Array : (stride === 2 ? Uint16Array : Uint32Array);\r\n        return new Ctor(this._data.buffer, primitive.indexView.offset, primitive.indexView.count);\r\n    }\r\n\r\n    /**\r\n     * @en Read the indices data of the given sub mesh and fill into the given array\r\n     * @zh 读取子网格的索引数据到目标数组中。\r\n     * @param primitiveIndex @en Sub mesh index @zh 子网格索引\r\n     * @param outputArray @en The target output array @zh 目标索引数组\r\n     * @returns @en Return false if failed to access the indices data, return true otherwise. @zh 拷贝失败返回 false， 否则返回 true\r\n     */\r\n    public copyIndices (primitiveIndex: number, outputArray: number[] | ArrayBufferView): boolean {\r\n        if (primitiveIndex >= this._struct.primitives.length) {\r\n            return false;\r\n        }\r\n        const primitive = this._struct.primitives[primitiveIndex];\r\n        if (!primitive.indexView) {\r\n            return false;\r\n        }\r\n        const indexCount = primitive.indexView.count;\r\n        const indexFormat = primitive.indexView.stride === 1 ? Format.R8UI : (primitive.indexView.stride === 2 ? Format.R16UI : Format.R32UI);\r\n        const reader = getReader(new DataView(this._data.buffer), indexFormat)!;\r\n        for (let i = 0; i < indexCount; ++i) {\r\n            outputArray[i] = reader(primitive.indexView.offset + FormatInfos[indexFormat].size * i);\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @en Read the format by attributeName of submesh\r\n     * @zh 根据属性名读取子网格的属性信息。\r\n     * @param primitiveIndex @en Sub mesh index @zh 子网格索引\r\n     * @param attributeName @en Attribute name @zh 属性名称\r\n     * @returns @en Return null if failed to read format, return the format otherwise. @zh 读取失败返回 null， 否则返回 format\r\n     */\r\n    public readAttributeFormat (primitiveIndex: number, attributeName: AttributeName): FormatInfo | null {\r\n        let result: FormatInfo | null = null;\r\n\r\n        this._accessAttribute(primitiveIndex, attributeName, (vertexBundle, iAttribute) => {\r\n            const format = vertexBundle.attributes[iAttribute].format;\r\n            result = FormatInfos[format];\r\n        });\r\n\r\n        return result;\r\n    }\r\n\r\n    private _accessAttribute (\r\n        primitiveIndex: number,\r\n        attributeName: AttributeName,\r\n        accessor: (vertexBundle: Mesh.IVertexBundle, iAttribute: number) => void,\r\n    ): void {\r\n        if (primitiveIndex >= this._struct.primitives.length) {\r\n            return;\r\n        }\r\n        const vertexBundelIndices = this._struct.primitives[primitiveIndex].vertexBundelIndices;\r\n        for (let i = 0; i < vertexBundelIndices.length; i++) {\r\n            const vertexBundleIndex = vertexBundelIndices[i];\r\n            const vertexBundle = this._struct.vertexBundles[vertexBundleIndex];\r\n            const iAttribute = vertexBundle.attributes.findIndex((a) => a.name === (attributeName as string));\r\n            if (iAttribute < 0) {\r\n                continue;\r\n            }\r\n            accessor(vertexBundle, iAttribute);\r\n            break;\r\n        }\r\n    }\r\n\r\n    private _createVertexBuffers (gfxDevice: Device, data: ArrayBuffer): Buffer[] {\r\n        return this._struct.vertexBundles.map((vertexBundle) => {\r\n            const vertexBuffer = gfxDevice.createBuffer(new BufferInfo(\r\n                BufferUsageBit.VERTEX,\r\n                MemoryUsageBit.DEVICE,\r\n                vertexBundle.view.length,\r\n                vertexBundle.view.stride,\r\n            ));\r\n\r\n            const view = new Uint8Array(data, vertexBundle.view.offset, vertexBundle.view.length);\r\n            vertexBuffer.update(view);\r\n            return vertexBuffer;\r\n        });\r\n    }\r\n\r\n    /**\r\n     * @en default init\r\n     * @zh 默认初始化\r\n     * @param uuid @en asset uuid @zh 资源 uuid\r\n     */\r\n    public initDefault (uuid?: string): void {\r\n        super.initDefault(uuid);\r\n        this.reset({\r\n            struct: {\r\n                vertexBundles: [],\r\n                primitives: [],\r\n            },\r\n            data: globalEmptyMeshBuffer,\r\n        });\r\n    }\r\n\r\n    /**\r\n     * @en Set whether the data of this mesh could be accessed (read or wrote), it could be used only for static mesh\r\n     * @zh 设置此网格的数据是否可被存取，此接口只针对静态网格资源生效\r\n     * @param allowDataAccess @en Indicate whether the data of this mesh could be accessed (read or wrote) @zh 是否允许存取网格数据\r\n     */\r\n    public set allowDataAccess (allowDataAccess: boolean) {\r\n        this._allowDataAccess = allowDataAccess;\r\n        if (this._isMeshDataUploaded && !this._allowDataAccess && !EDITOR) {\r\n            this.releaseData();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @en Get whether the data of this mesh could be read or wrote\r\n     * @zh 获取此网格的数据是否可被存取\r\n     * @return @en whether the data of this mesh could be accessed (read or wrote) @zh 此网格的数据是否可被存取\r\n     */\r\n    public get allowDataAccess (): boolean {\r\n        return this._allowDataAccess;\r\n    }\r\n\r\n    private releaseData (): void {\r\n        this._data = globalEmptyMeshBuffer;\r\n    }\r\n}\r\ncclegacy.Mesh = Mesh;\r\n\r\nfunction getOffset (attributes: Attribute[], attributeIndex: number): number {\r\n    let result = 0;\r\n    for (let i = 0; i < attributeIndex; ++i) {\r\n        const attribute = attributes[i];\r\n        result += FormatInfos[attribute.format].size;\r\n    }\r\n    return result;\r\n}\r\n\r\nconst { isLittleEndian } = sys;\r\n\r\nfunction getComponentByteLength (format: Format): number {\r\n    const info = FormatInfos[format];\r\n    return info.size / info.count;\r\n}\r\n\r\nfunction getReader (dataView: DataView, format: Format): ((offset: number) => number) | null {\r\n    const info = FormatInfos[format];\r\n    const stride = info.size / info.count;\r\n\r\n    switch (info.type) {\r\n    case FormatType.UNORM: {\r\n        switch (stride) {\r\n        case 1: return (offset: number): number => dataView.getUint8(offset);\r\n        case 2: return (offset: number): number => dataView.getUint16(offset, isLittleEndian);\r\n        case 4: return (offset: number): number => dataView.getUint32(offset, isLittleEndian);\r\n        default:\r\n        }\r\n        break;\r\n    }\r\n    case FormatType.SNORM: {\r\n        switch (stride) {\r\n        case 1: return (offset: number): number => dataView.getInt8(offset);\r\n        case 2: return (offset: number): number => dataView.getInt16(offset, isLittleEndian);\r\n        case 4: return (offset: number): number => dataView.getInt32(offset, isLittleEndian);\r\n        default:\r\n        }\r\n        break;\r\n    }\r\n    case FormatType.INT: {\r\n        switch (stride) {\r\n        case 1: return (offset: number): number => dataView.getInt8(offset);\r\n        case 2: return (offset: number): number => dataView.getInt16(offset, isLittleEndian);\r\n        case 4: return (offset: number): number => dataView.getInt32(offset, isLittleEndian);\r\n        default:\r\n        }\r\n        break;\r\n    }\r\n    case FormatType.UINT: {\r\n        switch (stride) {\r\n        case 1: return (offset: number): number => dataView.getUint8(offset);\r\n        case 2: return (offset: number): number => dataView.getUint16(offset, isLittleEndian);\r\n        case 4: return (offset: number): number => dataView.getUint32(offset, isLittleEndian);\r\n        default:\r\n        }\r\n        break;\r\n    }\r\n    case FormatType.FLOAT: {\r\n        switch (stride) {\r\n        case 2: return (offset: number) => dataView.getUint16(offset, isLittleEndian);\r\n        case 4: return (offset: number) => dataView.getFloat32(offset, isLittleEndian);\r\n        default:\r\n        }\r\n        break;\r\n    }\r\n    default:\r\n    }\r\n\r\n    return null;\r\n}\r\n\r\nfunction getWriter (dataView: DataView, format: Format): ((offset: number, value: number) => void) | null {\r\n    const info = FormatInfos[format];\r\n    const stride = info.size / info.count;\r\n\r\n    switch (info.type) {\r\n    case FormatType.UNORM: {\r\n        switch (stride) {\r\n        case 1: return (offset: number, value: number): void => dataView.setUint8(offset, value);\r\n        case 2: return (offset: number, value: number): void => dataView.setUint16(offset, value, isLittleEndian);\r\n        case 4: return (offset: number, value: number): void => dataView.setUint32(offset, value, isLittleEndian);\r\n        default:\r\n        }\r\n        break;\r\n    }\r\n    case FormatType.SNORM: {\r\n        switch (stride) {\r\n        case 1: return (offset: number, value: number): void => dataView.setInt8(offset, value);\r\n        case 2: return (offset: number, value: number): void => dataView.setInt16(offset, value, isLittleEndian);\r\n        case 4: return (offset: number, value: number): void => dataView.setInt32(offset, value, isLittleEndian);\r\n        default:\r\n        }\r\n        break;\r\n    }\r\n    case FormatType.INT: {\r\n        switch (stride) {\r\n        case 1: return (offset: number, value: number): void => dataView.setInt8(offset, value);\r\n        case 2: return (offset: number, value: number): void => dataView.setInt16(offset, value, isLittleEndian);\r\n        case 4: return (offset: number, value: number): void => dataView.setInt32(offset, value, isLittleEndian);\r\n        default:\r\n        }\r\n        break;\r\n    }\r\n    case FormatType.UINT: {\r\n        switch (stride) {\r\n        case 1: return (offset: number, value: number): void => dataView.setUint8(offset, value);\r\n        case 2: return (offset: number, value: number): void => dataView.setUint16(offset, value, isLittleEndian);\r\n        case 4: return (offset: number, value: number): void => dataView.setUint32(offset, value, isLittleEndian);\r\n        default:\r\n        }\r\n        break;\r\n    }\r\n    case FormatType.FLOAT: {\r\n        switch (stride) {\r\n        case 2: return (offset: number, value: number) => dataView.setUint16(offset, value, isLittleEndian);\r\n        case 4: return (offset: number, value: number) => dataView.setFloat32(offset, value, isLittleEndian);\r\n        default:\r\n        }\r\n        break;\r\n    }\r\n    default:\r\n    }\r\n\r\n    return null;\r\n}\r\n\r\nexport function decodeMesh (mesh: Mesh.ICreateInfo): Mesh.ICreateInfo {\r\n    if (!mesh.struct.encoded) {\r\n        // the mesh is not encoded, so no need to decode\r\n        return mesh;\r\n    }\r\n\r\n    const res_checker = (res: number): void => {\r\n        if (res < 0) {\r\n            errorID(14204, res);\r\n        }\r\n    };\r\n\r\n    const struct = JSON.parse(JSON.stringify(mesh.struct)) as Mesh.IStruct;\r\n\r\n    const bufferBlob = new BufferBlob();\r\n    bufferBlob.setNextAlignment(0);\r\n\r\n    for (const bundle of struct.vertexBundles) {\r\n        const view = bundle.view;\r\n        const bound = view.count * view.stride;\r\n        const buffer = new Uint8Array(bound);\r\n        const vertex = new Uint8Array(mesh.data.buffer, view.offset, view.length);\r\n        const res = MeshoptDecoder.decodeVertexBuffer(buffer, view.count, view.stride, vertex);\r\n        res_checker(res);\r\n\r\n        bufferBlob.setNextAlignment(view.stride);\r\n        const newView: Mesh.IBufferView = {\r\n            offset: bufferBlob.getLength(),\r\n            length: buffer.byteLength,\r\n            count: view.count,\r\n            stride: view.stride,\r\n        };\r\n        bundle.view = newView;\r\n        bufferBlob.addBuffer(buffer);\r\n    }\r\n\r\n    for (const primitive of struct.primitives) {\r\n        if (primitive.indexView === undefined) {\r\n            continue;\r\n        }\r\n\r\n        const view = primitive.indexView;\r\n        const bound = view.count * view.stride;\r\n        const buffer = new Uint8Array(bound);\r\n        const index = new Uint8Array(mesh.data.buffer, view.offset, view.length);\r\n        const res = MeshoptDecoder.decodeIndexBuffer(buffer, view.count, view.stride, index);\r\n        res_checker(res);\r\n\r\n        bufferBlob.setNextAlignment(view.stride);\r\n        const newView: Mesh.IBufferView = {\r\n            offset: bufferBlob.getLength(),\r\n            length: buffer.byteLength,\r\n            count: view.count,\r\n            stride: view.stride,\r\n        };\r\n        primitive.indexView = newView;\r\n        bufferBlob.addBuffer(buffer);\r\n    }\r\n\r\n    const data = new Uint8Array(bufferBlob.getCombined());\r\n\r\n    return {\r\n        struct,\r\n        data,\r\n    };\r\n}\r\n\r\nexport function inflateMesh (mesh: Mesh.ICreateInfo): Mesh.ICreateInfo {\r\n    const inflator = new zlib.Inflate(mesh.data);\r\n    const decompressed = inflator.decompress();\r\n    mesh.data = decompressed;\r\n    mesh.struct.compressed = false;\r\n    return mesh;\r\n}\r\n\r\nexport function dequantizeMesh (mesh: Mesh.ICreateInfo): Mesh.ICreateInfo {\r\n    const struct = JSON.parse(JSON.stringify(mesh.struct)) as Mesh.IStruct;\r\n\r\n    const bufferBlob = new BufferBlob();\r\n    bufferBlob.setNextAlignment(0);\r\n\r\n    function transformVertex (\r\n        reader: ((offset: number) => number),\r\n        writer: ((offset: number, value: number) => void),\r\n        count: number,\r\n        components: number,\r\n        componentSize: number,\r\n        readerStride: number,\r\n        writerStride: number,\r\n    ): void {\r\n        for (let i = 0; i < count; i++) {\r\n            for (let j = 0; j < components; j++) {\r\n                const inputOffset = readerStride * i + componentSize * j;\r\n                const outputOffset = writerStride * i + componentSize * j;\r\n                writer(outputOffset, reader(inputOffset));\r\n            }\r\n        }\r\n    }\r\n\r\n    function dequantizeHalf (\r\n        reader: ((offset: number) => number),\r\n        writer: ((offset: number, value: number) => void),\r\n        count: number,\r\n        components: number,\r\n        readerStride: number,\r\n        writerStride: number,\r\n    ): void {\r\n        for (let i = 0; i < count; i++) {\r\n            for (let j = 0; j < components; j++) {\r\n                const inputOffset = readerStride * i + 2 * j;\r\n                const outputOffset = writerStride * i + 4 * j;\r\n                const value = halfToFloat(reader(inputOffset));\r\n                writer(outputOffset, value);\r\n            }\r\n        }\r\n    }\r\n\r\n    for (let i = 0; i < struct.vertexBundles.length; ++i) {\r\n        const bundle = struct.vertexBundles[i];\r\n        const view = bundle.view;\r\n        const attributes =  bundle.attributes;\r\n        const oldAttributes = mesh.struct.vertexBundles[i].attributes;\r\n        const strides: number[] = [];\r\n        const dequantizes: boolean[] = [];\r\n        const readers: ((offset: number) => number)[] = [];\r\n        for (let j = 0; j < attributes.length; ++j) {\r\n            const attr = attributes[j];\r\n            const inputView = new DataView(mesh.data.buffer, view.offset + getOffset(oldAttributes, j));\r\n            const reader = getReader(inputView, attr.format);\r\n            let dequantize = true;\r\n            switch (attr.format) {\r\n            case Format.R16F:\r\n                attr.format = Format.R32F;\r\n                break;\r\n            case Format.RG16F:\r\n                attr.format = Format.RG32F;\r\n                break;\r\n            case Format.RGB16F:\r\n                attr.format = Format.RGB32F;\r\n                break;\r\n            case Format.RGBA16F:\r\n                attr.format = Format.RGBA32F;\r\n                break;\r\n            default:\r\n                dequantize = false;\r\n                break;\r\n            }\r\n            strides.push(FormatInfos[attr.format].size);\r\n            dequantizes.push(dequantize);\r\n            readers.push(reader!);\r\n        }\r\n        const netStride = strides.reduce((acc, cur) => acc + cur, 0);\r\n        const newBuffer = new Uint8Array(netStride * view.count);\r\n        for (let j = 0; j < attributes.length; ++j) {\r\n            const attribute = attributes[j];\r\n            const reader = readers[j];\r\n            const outputView = new DataView(newBuffer.buffer, getOffset(attributes, j));\r\n            const writer = getWriter(outputView, attribute.format)!;\r\n            const dequantize = dequantizes[j];\r\n            const formatInfo = FormatInfos[attribute.format];\r\n            if (dequantize) {\r\n                dequantizeHalf(\r\n                    reader,\r\n                    writer,\r\n                    view.count,\r\n                    formatInfo.count,\r\n                    view.stride,\r\n                    netStride,\r\n                );\r\n            } else {\r\n                transformVertex(\r\n                    reader,\r\n                    writer,\r\n                    view.count,\r\n                    formatInfo.count,\r\n                    formatInfo.size / formatInfo.count,\r\n                    view.stride,\r\n                    netStride,\r\n                );\r\n            }\r\n        }\r\n\r\n        bufferBlob.setNextAlignment(netStride);\r\n        const newView: Mesh.IBufferView = {\r\n            offset: bufferBlob.getLength(),\r\n            length: newBuffer.byteLength,\r\n            count: view.count,\r\n            stride: netStride,\r\n        };\r\n        bundle.view = newView;\r\n        bufferBlob.addBuffer(newBuffer);\r\n    }\r\n\r\n    // dump index buffer\r\n    for (const primitive of struct.primitives) {\r\n        if (primitive.indexView === undefined) {\r\n            continue;\r\n        }\r\n        const view = primitive.indexView;\r\n        const buffer = new Uint8Array(mesh.data.buffer, view.offset, view.length);\r\n        bufferBlob.setNextAlignment(view.stride);\r\n        const newView: Mesh.IBufferView = {\r\n            offset: bufferBlob.getLength(),\r\n            length: buffer.byteLength,\r\n            count: view.count,\r\n            stride: view.stride,\r\n        };\r\n        primitive.indexView = newView;\r\n        bufferBlob.addBuffer(buffer);\r\n    }\r\n\r\n    const data = new Uint8Array(bufferBlob.getCombined());\r\n\r\n    struct.quantized = false;\r\n\r\n    return {\r\n        struct,\r\n        data,\r\n    };\r\n}\r\n\r\n// function get\r\n"],"names":["BufferBlob","this","_arrayBufferOrPaddings","_length","_proto","prototype","setNextAlignment","align","remainder","padding","push","addBuffer","arrayBuffer","result","byteLength","getLength","getCombined","Uint8Array","counter","forEach","arrayBufferOrPadding","set","buffer","createMorphRendering","mesh","gfxDevice","StdMorphRendering","_subMeshRenderings","_mesh","struct","morph","nSubMeshes","primitives","length","Array","fill","iSubMesh","subMeshMorph","subMeshMorphs","targets","UBOMorphEnum","MAX_MORPH_TARGET_COUNT","CpuComputing","GpuComputing","createInstance","_this","subMeshInstances","_this$_subMeshRenderi","_this$_subMeshRenderi2","setWeights","subMeshIndex","weights","_subMeshInstances$sub","requiredPatches","assertIsNonNullable","subMeshRenderingInstance","patches","name","value","attributes","includes","AttributeName","ATTR_POSITION","ATTR_NORMAL","ATTR_TANGENT","adaptPipelineState","descriptorSet","_subMeshInstances$sub2","destroy","subMeshInstance","_gfxDevice","_subMeshMorph","enableVertexId","nVertices","vertexBundles","vertexBundelIndices","view","count","_verticesCount","nTargets","vec4TextureFactory","createVec4TextureFactory","_textureInfo","width","height","_attributes","map","attributeName","attributeIndex","vec4Tex","create","valueView","morphTarget","morphTargetIndex","displacementsView","displacements","Float32Array","data","byteOffset","offset","displacementsOffset","iVertex","updatePixels","morphTexture","_proto2","attribute","_this2","morphUniforms","MorphUniforms","setMorphTextureInfo","setVerticesCount","commit","i","binding","UNIFORM_POSITION_MORPH_TEXTURE_BINDING","UNIFORM_NORMAL_MORPH_TEXTURE_BINDING","UNIFORM_TANGENT_MORPH_TEXTURE_BINDING","warnID","undefined","bindSampler","sampler","bindTexture","texture","bindBuffer","UBOMorph","BINDING","update","attributeDisplacement","CpuComputingRenderingInstance","_createClass","key","get","owner","_owner","_morphUniforms","attributeMorph","_proto4","iAttribute","myAttribute","assertIsTrue","iTarget","targetDisplacements","weight","targetCount","_targetCount","_localBuffer","DataView","ArrayBuffer","SIZE","_remoteBuffer","createBuffer","BufferInfo","BufferUsageBit","UNIFORM","TRANSFER_DST","MemoryUsageBit","HOST","DEVICE","_proto5","isLittleEndian","cclegacy","sys","iWeight","setFloat32","OFFSET_OF_WEIGHTS","OFFSET_OF_DISPLACEMENT_TEXTURE_WIDTH","OFFSET_OF_DISPLACEMENT_TEXTURE_HEIGHT","OFFSET_OF_VERTICES_COUNT","vec4Capacity","pixelRequired","pixelFormat","pixelBytes","UpdateViewConstructor","getFormatFeatures","Format","RGBA32F","FormatFeatureBit","SAMPLED_TEXTURE","PixelFormat","RGBA8888","bestSizeToHavePixels","updateView","image","ImageAsset","_data","_compressed","format","textureAsset","Texture2D","setFilters","TextureFilter","NEAREST","setMipFilter","NONE","setWrapMode","WrapMode","CLAMP_TO_EDGE","getGFXTexture","getSampler","getSamplerInfo","uploadData","renderingSubMeshes","enableVertexIdChannel","nPixels","aligned","nextPow2","epxSum","bits","h","MeshoptDecoder","game","onPostInfrastructureInitDelegate","add","ensureWasmModuleReady","then","hasFeature","Feature","WASM","Promise","all","module","import","_ref","wasm_factory","wasm_url","meshopt_wasm_factory","meshopt_wasm_url","ready","importObject","instantiateWasm","supported","resolve","decodeVertexBuffer","decodeIndexBuffer","decodeIndexSequence","decodeGltfBuffer","useWorkers","decodeGltfBufferAsync","logID","n","m","_ref2","asm_factory","meshopt_asm_factory","msg","error","vec3Add","Vec3","vec3MultiplyScalar","multiplyScalar","vec3Subtract","subtract","aabbTransform","geometry","transform","aabbFromPoints","fromPoints","vec3Max","max","vec3Min","min","vec3TransformQuat","transformQuat","vec3TransformMat4","transformMat4","getIndexStrideCtor","stride","Uint16Array","Uint32Array","v3_1","v3_2","globalEmptyMeshBuffer","Mesh","exports","ccclass","_dec","_class2","_Asset","call","morphRendering","_struct","_initializer","_hash","_initializer2","_initialized","_allowDataAccess","_initializer3","_isMeshDataUploaded","_renderingSubMeshes","_boneSpaceBounds","Map","_jointBufferIndices","_inheritsLoose","onLoaded","initialize","info","compressed","inflateMesh","encoded","decodeMesh","quantized","deviceManager","RGB16F","VERTEX_ATTRIBUTE","dequantizeMesh","dynamic","device","vertexBuffers","subMeshes","vertexBundle","vertexBuffer","VERTEX","primitive","indexView","indexBuffer","INDEX","subVBs","k","idx","allAttributes","j","attr","Attribute","copy","subMesh","RenderingSubMesh","primitiveMode","drawInfo","DrawInfo","subMeshIdx","_createVertexBuffers","indexBuffers","prim","ib","idxView","dstStride","dstSize","ELEMENT_INDEX_UINT","vertexCount","from","vbReference","gfxAttributes","attrs","isNormalized","stream","isInstanced","location","EDITOR","releaseData","updateSubMesh","primitiveIndex","dynamicGeometry","buffers","positions","normals","uvs","tangents","colors","customAttributes","values","index","vertices","bundle","updateSize","dstBuffer","srcBuffer","maxSubMeshVertices","indexCount","indices16","indices32","maxSubMeshIndices","minPos","maxPos","v3","x","y","z","bounds","subMin","subMax","bound","getBoundary","minPosition","maxPosition","invalidateGeometricInfo","destroyRenderingMesh","assign","reset","getBoneSpaceBounds","skeleton","has","hash","valid","bindposes","Infinity","p","joints","readAttribute","ATTR_JOINTS","ATTR_WEIGHTS","vertCount","Math","joint","b","center","halfExtents","merge","worldMatrix","validate","validateMergingMesh","vec3_temp","rotate","Quat","boundingBox","getRotation","JSON","parse","stringify","slice","vtxBdl","inputView","getOffset","reader","getReader","writer","getWriter","vertexStride","attrComponentByteLength","getComponentByteLength","vtxIdx","xOffset","yOffset","zOffset","vb","vbView","srcVBView","dstVBView","dstAttrView","bufferBlob","vertStride","srcOffset","dstOffset","srcAttrOffset","srcVBOffset","dstVBOffset","attrSize","hasAttr","dstBundle","subarray","_step","_iterator","done","_step2","_iterator2","dstAttr","FormatInfos","size","v","f32_temp","ibView","srcIBView","dstIBView","idxCount","idxStride","dstPrim","_step3","vertBatchCount","_iterator3","bundleIdx","meshStruct","_accessAttribute","StorageConstructor","getTypedArrayConstructor","formatInfo","componentCount","storage","inputStride","iComponent","BYTES_PER_ELEMENT","copyAttribute","_this3","written","outputView","inputComponentByteLength","outputStride","outputComponentByteLength","readIndices","copyIndices","outputArray","indexFormat","R8UI","R16UI","R32UI","readAttributeFormat","accessor","vertexBundleIndex","findIndex","a","initDefault","uuid","renderingMesh","murmurhash2_32_gc","jointMapIndex","allowDataAccess","Asset","serializable","_applyDecoratedInitializer","_class","dataView","type","FormatType","UNORM","getUint8","getUint16","getUint32","SNORM","INT","getInt8","getInt16","getInt32","UINT","FLOAT","getFloat32","setUint8","setUint16","setUint32","setInt8","setInt16","setInt32","res_checker","res","errorID","_step4","_iterator4","vertex","newView","_step5","_iterator5","decompressed","zlib","Inflate","decompress","transformVertex","components","componentSize","readerStride","writerStride","dequantizeHalf","halfToFloat","oldAttributes","strides","dequantizes","readers","dequantize","R16F","R32F","RG16F","RG32F","RGB32F","RGBA16F","netStride","reduce","acc","cur","newBuffer","_step6","_iterator6"],"mappings":"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"}