{"version":3,"file":"rich-text.js","sources":["../../../cocos/2d/components/rich-text.ts"],"sourcesContent":["/*\r\n Copyright (c) 2013-2016 Chukong Technologies Inc.\r\n Copyright (c) 2017-2023 Xiamen Yaji Software Co., Ltd.\r\n\r\n http://www.cocos.com\r\n\r\n Permission is hereby granted, free of charge, to any person obtaining a copy\r\n of this software and associated documentation files (the \"Software\"), to deal\r\n in the Software without restriction, including without limitation the rights to\r\n use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\r\n of the Software, and to permit persons to whom the Software is furnished to do so,\r\n subject to the following conditions:\r\n\r\n The above copyright notice and this permission notice shall be included in\r\n all copies or substantial portions of the Software.\r\n\r\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n THE SOFTWARE.\r\n*/\r\n\r\nimport { ccclass, requireComponent, executeInEditMode, executionOrder, help, menu, multiline, type, displayOrder, serializable, editable } from \"cc.decorator\";\r\nimport { DEBUG, DEV, EDITOR } from \"internal:constants\";\r\nimport { Font, SpriteAtlas, TTFFont, SpriteFrame } from \"../assets\";\r\nimport { EventTouch } from \"../../input/types\";\r\nimport { assert, warnID, Color, Vec2, CCObjectFlags, cclegacy, js, Size } from \"../../core\";\r\nimport { HtmlTextParser, IHtmlTextParserResultObj, IHtmlTextParserStack } from \"../utils/html-text-parser\";\r\nimport { Node } from \"../../scene-graph\";\r\nimport { CacheMode, HorizontalTextAlignment, Label, VerticalTextAlignment } from \"./label\";\r\nimport { Sprite } from \"./sprite\";\r\nimport { UITransform } from \"../framework\";\r\nimport { Component } from \"../../scene-graph/component\";\r\nimport { NodeEventType } from \"../../scene-graph/node-event\";\r\nimport { BASELINE_RATIO, fragmentText, isUnicodeCJK, isUnicodeSpace, getEnglishWordPartAtFirst, getEnglishWordPartAtLast, getSymbolAt } from \"../utils/text-utils\";\r\nimport { Sorting2D } from \"exports/sorting-2d\";\r\n\r\nconst _htmlTextParser = new HtmlTextParser();\r\nconst RichTextChildName = \"RICHTEXT_CHILD\";\r\nconst RichTextChildImageName = \"RICHTEXT_Image_CHILD\";\r\n\r\nconst _tempSize = new Vec2();\r\nconst _tempSizeLeft = new Vec2();\r\n\r\n/**\r\n * 富文本池。<br/>\r\n */\r\nconst labelPool = new js.Pool((seg: ISegment) => {\r\n    if (DEV) {\r\n        assert(!seg.node.parent, \"Recycling node's parent should be null!\");\r\n    }\r\n    if (!cclegacy.isValid(seg.node)) {\r\n        return false;\r\n    } else {\r\n        const label = seg.node.getComponent(Label);\r\n        if (label) {\r\n            label.outlineWidth = 0;\r\n        }\r\n    }\r\n    return true;\r\n}, 20);\r\n\r\nconst imagePool = new js.Pool((seg: ISegment) => {\r\n    if (DEV) {\r\n        assert(!seg.node.parent, \"Recycling node's parent should be null!\");\r\n    }\r\n    return cclegacy.isValid(seg.node) as boolean;\r\n}, 10);\r\n\r\n//\r\nfunction createSegment(type: string): ISegment {\r\n    return {\r\n        node: new Node(type),\r\n        comp: null,\r\n        lineCount: 0,\r\n        styleIndex: 0,\r\n        imageOffset: \"\",\r\n        clickParam: \"\",\r\n        clickHandler: \"\",\r\n        type,\r\n    };\r\n}\r\n\r\nfunction getSegmentByPool(type: string, content: string | SpriteFrame, richTextNode: Node): ISegment | null {\r\n    let seg;\r\n    if (type === RichTextChildName) {\r\n        seg = labelPool._get();\r\n    } else if (type === RichTextChildImageName) {\r\n        seg = imagePool._get();\r\n    }\r\n    seg = seg || createSegment(type);\r\n    let node = seg.node as Node;\r\n    if (!node) {\r\n        node = new Node(type);\r\n    }\r\n    node.hideFlags |= CCObjectFlags.DontSave | CCObjectFlags.HideInHierarchy;\r\n    node.active = true; // Reset node state when use node\r\n    if (type === RichTextChildImageName) {\r\n        seg.comp = node.getComponent(Sprite) || node.addComponent(Sprite);\r\n        seg.comp.spriteFrame = content as SpriteFrame;\r\n        seg.comp.type = Sprite.Type.SLICED;\r\n        seg.comp.sizeMode = Sprite.SizeMode.CUSTOM;\r\n    } else {\r\n        // RichTextChildName\r\n        seg.comp = node.getComponent(Label) || node.addComponent(Label);\r\n        seg.comp.string = content as string;\r\n        seg.comp.horizontalAlign = HorizontalTextAlignment.LEFT;\r\n        seg.comp.verticalAlign = VerticalTextAlignment.TOP;\r\n        seg.comp.underlineHeight = 2;\r\n    }\r\n\r\n    // 为了让RichText支持Sorting2D\r\n    {\r\n        const parentSorting2d = richTextNode.getComponent(Sorting2D);\r\n        if (parentSorting2d) {\r\n            let sorting2d = node.getComponent(Sorting2D) || node.addComponent(Sorting2D);\r\n            sorting2d.sortingLayer = parentSorting2d.sortingLayer;\r\n            sorting2d.sortingOrder = parentSorting2d.sortingOrder;\r\n        }\r\n    }\r\n\r\n    node.setPosition(0, 0, 0);\r\n    const trans = node._getUITransformComp()!;\r\n    trans.setAnchorPoint(0.5, 0.5);\r\n\r\n    seg.node = node;\r\n    seg.lineCount = 0;\r\n    seg.styleIndex = 0;\r\n    seg.imageOffset = \"\";\r\n    seg.clickParam = \"\";\r\n    seg.clickHandler = \"\";\r\n    return seg as ISegment | null;\r\n}\r\n\r\ninterface ISegment {\r\n    node: Node;\r\n    comp: Label | Sprite | null;\r\n    lineCount: number;\r\n    styleIndex: number;\r\n    imageOffset: string;\r\n    clickParam: string;\r\n    clickHandler: string;\r\n    type: string;\r\n}\r\n\r\n/**\r\n * @en\r\n * The RichText Component.\r\n *\r\n * @zh\r\n * 富文本组件。\r\n */\r\n@ccclass(\"cc.RichText\")\r\n@requireComponent(UITransform)\r\n@help(\"i18n:cc.RichText\")\r\n@executionOrder(110)\r\n@menu(\"2D/RichText\")\r\n@executeInEditMode\r\nexport class RichText extends Component {\r\n    /**\r\n     * @en\r\n     * Content string of RichText.\r\n     *\r\n     * @zh\r\n     * 富文本显示的文本内容。\r\n     */\r\n    @multiline\r\n    get string(): string {\r\n        return this._string;\r\n    }\r\n    set string(value) {\r\n        if (this._string === value) {\r\n            return;\r\n        }\r\n\r\n        this._string = value;\r\n        this._updateRichTextStatus();\r\n    }\r\n\r\n    /**\r\n     * @en\r\n     * Horizontal Alignment of each line in RichText.\r\n     *\r\n     * @zh\r\n     * 文本内容的水平对齐方式。\r\n     */\r\n    @type(HorizontalTextAlignment)\r\n    get horizontalAlign(): HorizontalTextAlignment {\r\n        return this._horizontalAlign;\r\n    }\r\n\r\n    set horizontalAlign(value) {\r\n        if (this.horizontalAlign === value) {\r\n            return;\r\n        }\r\n\r\n        this._horizontalAlign = value;\r\n        this._layoutDirty = true;\r\n        this._updateRichTextStatus();\r\n    }\r\n\r\n    /**\r\n     * @en\r\n     * Vertical Alignment of each line in RichText.\r\n     *\r\n     * @zh\r\n     * 文本内容的竖直对齐方式。\r\n     */\r\n    @type(VerticalTextAlignment)\r\n    get verticalAlign(): VerticalTextAlignment {\r\n        return this._verticalAlign;\r\n    }\r\n\r\n    set verticalAlign(value) {\r\n        if (this._verticalAlign === value) {\r\n            return;\r\n        }\r\n\r\n        this._verticalAlign = value;\r\n        this._layoutDirty = true;\r\n        this._updateRichTextStatus();\r\n    }\r\n\r\n    /**\r\n     * @en\r\n     * Font size of RichText.\r\n     *\r\n     * @zh\r\n     * 富文本字体大小。\r\n     */\r\n    @editable\r\n    get fontSize(): number {\r\n        return this._fontSize;\r\n    }\r\n\r\n    set fontSize(value) {\r\n        if (this._fontSize === value) {\r\n            return;\r\n        }\r\n\r\n        this._fontSize = value;\r\n        this._layoutDirty = true;\r\n        this._updateRichTextStatus();\r\n    }\r\n\r\n    /**\r\n     * @en\r\n     * Font color of RichText. Works when the text content does not have a color parameter set. Transparency cascade is not supported.\r\n     *\r\n     * @zh\r\n     * 富文本默认文字颜色。在文本内容没有设置颜色参数时生效。暂不支持颜色级联。\r\n     */\r\n    @type(Color)\r\n    get fontColor(): Color {\r\n        return this._fontColor;\r\n    }\r\n    set fontColor(value: Color) {\r\n        if (this._fontColor === value) {\r\n            return;\r\n        }\r\n\r\n        this._fontColor = value;\r\n        this._updateTextDefaultColor();\r\n    }\r\n\r\n    /**\r\n     * @en\r\n     * Custom System font of RichText.\r\n     *\r\n     * @zh\r\n     * 富文本定制系统字体。\r\n     */\r\n    @editable\r\n    get fontFamily(): string {\r\n        return this._fontFamily;\r\n    }\r\n    set fontFamily(value: string) {\r\n        if (this._fontFamily === value) return;\r\n        this._fontFamily = value;\r\n        this._layoutDirty = true;\r\n        this._updateRichTextStatus();\r\n    }\r\n\r\n    /**\r\n     * @en\r\n     * Custom System font of RichText.\r\n     *\r\n     * @zh\r\n     * 富文本定制字体。\r\n     */\r\n    @type(Font)\r\n    get font(): TTFFont | null {\r\n        return this._font;\r\n    }\r\n    set font(value) {\r\n        if (this._font === value) {\r\n            return;\r\n        }\r\n        this._font = value;\r\n        this._layoutDirty = true;\r\n        if (this._font) {\r\n            if (EDITOR) {\r\n                this._userDefinedFont = this._font;\r\n            }\r\n            this.useSystemFont = false;\r\n            this._onTTFLoaded();\r\n        } else {\r\n            this.useSystemFont = true;\r\n        }\r\n        this._updateRichTextStatus();\r\n    }\r\n\r\n    /**\r\n     * @en\r\n     * Whether to use system font name or not.\r\n     *\r\n     * @zh\r\n     * 是否使用系统字体。\r\n     */\r\n    @displayOrder(12)\r\n    get useSystemFont(): boolean {\r\n        return this._isSystemFontUsed;\r\n    }\r\n    set useSystemFont(value: boolean) {\r\n        if (this._isSystemFontUsed === value) {\r\n            return;\r\n        }\r\n        this._isSystemFontUsed = value;\r\n\r\n        if (EDITOR) {\r\n            if (value) {\r\n                this._font = null;\r\n            } else if (this._userDefinedFont) {\r\n                this._font = this._userDefinedFont;\r\n                return;\r\n            }\r\n        }\r\n\r\n        this._layoutDirty = true;\r\n        this._updateRichTextStatus();\r\n    }\r\n\r\n    /**\r\n     * @en\r\n     * The cache mode of label. This mode only supports system fonts.\r\n     *\r\n     * @zh\r\n     * 文本缓存模式, 该模式只支持系统字体。\r\n     */\r\n    @type(CacheMode)\r\n    get cacheMode(): CacheMode {\r\n        return this._cacheMode;\r\n    }\r\n    set cacheMode(value: CacheMode) {\r\n        if (this._cacheMode === value) {\r\n            return;\r\n        }\r\n        this._cacheMode = value;\r\n        this._updateRichTextStatus();\r\n    }\r\n\r\n    /**\r\n     * @en\r\n     * The maximize width of the RichText.\r\n     *\r\n     * @zh\r\n     * 富文本的最大宽度。\r\n     */\r\n    @editable\r\n    get maxWidth(): number {\r\n        return this._maxWidth;\r\n    }\r\n\r\n    set maxWidth(value) {\r\n        if (this._maxWidth === value) {\r\n            return;\r\n        }\r\n\r\n        this._maxWidth = value;\r\n        this._layoutDirty = true;\r\n        this._updateRichTextStatus();\r\n    }\r\n\r\n    /**\r\n     * @en\r\n     * Line Height of RichText.\r\n     *\r\n     * @zh\r\n     * 富文本行高。\r\n     */\r\n    @editable\r\n    get lineHeight(): number {\r\n        return this._lineHeight;\r\n    }\r\n\r\n    set lineHeight(value) {\r\n        if (this._lineHeight === value) {\r\n            return;\r\n        }\r\n\r\n        this._lineHeight = value;\r\n        this._layoutDirty = true;\r\n        this._updateRichTextStatus();\r\n    }\r\n\r\n    /**\r\n     * @en\r\n     * The image atlas for the img tag. For each src value in the img tag, there should be a valid spriteFrame in the image atlas.\r\n     *\r\n     * @zh\r\n     * 对于 img 标签里面的 src 属性名称，都需要在 imageAtlas 里面找到一个有效的 spriteFrame，否则 img tag 会判定为无效。\r\n     */\r\n    @type(SpriteAtlas)\r\n    get imageAtlas(): SpriteAtlas | null {\r\n        return this._imageAtlas;\r\n    }\r\n\r\n    set imageAtlas(value) {\r\n        if (this._imageAtlas === value) {\r\n            return;\r\n        }\r\n\r\n        this._imageAtlas = value;\r\n        this._layoutDirty = true;\r\n        this._updateRichTextStatus();\r\n    }\r\n\r\n    /**\r\n     * @en\r\n     * Once checked, the RichText will block all input events (mouse and touch) within\r\n     * the bounding box of the node, preventing the input from penetrating into the underlying node.\r\n     *\r\n     * @zh\r\n     * 选中此选项后，RichText 将阻止节点边界框中的所有输入事件（鼠标和触摸），从而防止输入事件穿透到底层节点。\r\n     */\r\n    @editable\r\n    get handleTouchEvent(): boolean {\r\n        return this._handleTouchEvent;\r\n    }\r\n\r\n    set handleTouchEvent(value) {\r\n        if (this._handleTouchEvent === value) {\r\n            return;\r\n        }\r\n\r\n        this._handleTouchEvent = value;\r\n        if (this.enabledInHierarchy) {\r\n            if (this.handleTouchEvent) {\r\n                this._addEventListeners();\r\n            } else {\r\n                this._removeEventListeners();\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * @en Enum for horizontal text alignment.\r\n     *\r\n     * @zh 文本横向对齐类型。\r\n     */\r\n    public static HorizontalAlign = HorizontalTextAlignment;\r\n    /**\r\n     * @en Enum for vertical text alignment.\r\n     *\r\n     * @zh 文本垂直对齐类型。\r\n     */\r\n    public static VerticalAlign = VerticalTextAlignment;\r\n\r\n    @serializable\r\n    protected _lineHeight = 40;\r\n    @serializable\r\n    protected _string = \"<color=#00ff00>Rich</color><color=#0fffff>Text</color>\";\r\n    // protected _updateRichTextStatus =\r\n    @serializable\r\n    protected _horizontalAlign = HorizontalTextAlignment.LEFT;\r\n    @serializable\r\n    protected _verticalAlign = VerticalTextAlignment.TOP;\r\n    @serializable\r\n    protected _fontSize = 40;\r\n    @serializable\r\n    protected _fontColor: Color = Color.WHITE.clone();\r\n    @serializable\r\n    protected _maxWidth = 0;\r\n    @serializable\r\n    protected _fontFamily = \"Arial\";\r\n    @serializable\r\n    protected _font: TTFFont | null = null;\r\n    @serializable\r\n    protected _isSystemFontUsed = true;\r\n    @serializable\r\n    protected _userDefinedFont: TTFFont | null = null;\r\n    @serializable\r\n    protected _cacheMode: CacheMode = CacheMode.NONE;\r\n    @serializable\r\n    protected _imageAtlas: SpriteAtlas | null = null;\r\n    @serializable\r\n    protected _handleTouchEvent = true;\r\n\r\n    protected _textArray: IHtmlTextParserResultObj[] = [];\r\n    protected _segments: ISegment[] = [];\r\n    protected _labelSegmentsCache: ISegment[] = [];\r\n    protected _linesWidth: number[] = [];\r\n    protected _lineCount = 1;\r\n    protected _labelWidth = 0;\r\n    protected _labelHeight = 0;\r\n    protected _layoutDirty = true;\r\n    protected _lineOffsetX = 0;\r\n    protected declare _updateRichTextStatus: () => void;\r\n    protected _labelChildrenNum = 0; // only ISegment\r\n\r\n    constructor() {\r\n        super();\r\n        this._updateRichTextStatus = this._updateRichText;\r\n    }\r\n\r\n    public onLoad(): void {\r\n        this.node.on(NodeEventType.LAYER_CHANGED, this._applyLayer, this);\r\n        this.node.on(NodeEventType.ANCHOR_CHANGED, this._updateRichTextPosition, this);\r\n    }\r\n\r\n    public onEnable(): void {\r\n        if (this.handleTouchEvent) {\r\n            this._addEventListeners();\r\n        }\r\n\r\n        this._updateRichText();\r\n        this._activateChildren(true);\r\n    }\r\n\r\n    public onDisable(): void {\r\n        if (this.handleTouchEvent) {\r\n            this._removeEventListeners();\r\n        }\r\n\r\n        this._activateChildren(false);\r\n    }\r\n\r\n    public onRestore(): void {\r\n        if (!EDITOR) {\r\n            return;\r\n        }\r\n\r\n        // TODO: refine undo/redo system\r\n        // Because undo/redo will not call onEnable/onDisable,\r\n        // we need call onEnable/onDisable manually to active/disactive children nodes.\r\n        if (this.enabledInHierarchy) {\r\n            this.onEnable();\r\n        } else {\r\n            this.onDisable();\r\n        }\r\n    }\r\n\r\n    public onDestroy(): void {\r\n        this._segments.forEach((seg) => {\r\n            seg.node.removeFromParent();\r\n            if (seg.type === RichTextChildName) {\r\n                labelPool.put(seg);\r\n            } else if (seg.type === RichTextChildImageName) {\r\n                imagePool.put(seg);\r\n            }\r\n        });\r\n\r\n        this.node.off(NodeEventType.ANCHOR_CHANGED, this._updateRichTextPosition, this);\r\n        this.node.off(NodeEventType.LAYER_CHANGED, this._applyLayer, this);\r\n    }\r\n\r\n    protected _addEventListeners(): void {\r\n        this.node.on(NodeEventType.TOUCH_END, this._onTouchEnded, this);\r\n    }\r\n\r\n    protected _removeEventListeners(): void {\r\n        this.node.off(NodeEventType.TOUCH_END, this._onTouchEnded, this);\r\n    }\r\n\r\n    protected _updateLabelSegmentTextAttributes(): void {\r\n        this._segments.forEach((item) => {\r\n            this._applyTextAttribute(item);\r\n        });\r\n    }\r\n\r\n    protected _createFontLabel(str: string): ISegment {\r\n        return getSegmentByPool(RichTextChildName, str, this.node)!;\r\n    }\r\n\r\n    protected _createImage(spriteFrame: SpriteFrame): ISegment {\r\n        return getSegmentByPool(RichTextChildImageName, spriteFrame, this.node)!;\r\n    }\r\n\r\n    protected _onTTFLoaded(): void {\r\n        if (this._font instanceof TTFFont) {\r\n            this._layoutDirty = true;\r\n            this._updateRichText();\r\n        } else {\r\n            this._layoutDirty = true;\r\n            this._updateRichText();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @engineInternal\r\n     * @mangle\r\n     */\r\n    protected splitLongStringApproximatelyIn2048(text: string, styleIndex: number): string[] {\r\n        const approxSize = text.length * this.fontSize;\r\n        const partStringArr: string[] = [];\r\n        // avoid that many short richtext still execute _calculateSize so that performance is low\r\n        // we set a threshold as 2048 * 0.8, if the estimated size is less than it, we can skip _calculateSize precisely\r\n        if (approxSize <= 2048 * 0.8) {\r\n            partStringArr.push(text);\r\n            return partStringArr;\r\n        }\r\n\r\n        this._calculateSize(_tempSize, styleIndex, text);\r\n        if (_tempSize.x < 2048) {\r\n            partStringArr.push(text);\r\n        } else {\r\n            const multilineTexts = text.split(\"\\n\");\r\n            for (let i = 0; i < multilineTexts.length; i++) {\r\n                this._calculateSize(_tempSize, styleIndex, multilineTexts[i]);\r\n                if (_tempSize.x < 2048) {\r\n                    partStringArr.push(multilineTexts[i]);\r\n                } else {\r\n                    const thisPartSplitResultArr = this.splitLongStringOver2048(multilineTexts[i], styleIndex);\r\n                    partStringArr.push(...thisPartSplitResultArr);\r\n                }\r\n            }\r\n        }\r\n        return partStringArr;\r\n    }\r\n\r\n    /**\r\n     * @engineInternal\r\n     * @mangle\r\n     */\r\n    protected splitLongStringOver2048(text: string, styleIndex: number): string[] {\r\n        const partStringArr: string[] = [];\r\n        const longStr = text;\r\n\r\n        let curStart = 0;\r\n        let curEnd = longStr.length / 2;\r\n        let curString = longStr.substring(curStart, curEnd);\r\n        let leftString = longStr.substring(curEnd);\r\n        const curStringSize = this._calculateSize(_tempSize, styleIndex, curString);\r\n        const leftStringSize = this._calculateSize(_tempSizeLeft, styleIndex, leftString);\r\n        let maxWidth = this._maxWidth;\r\n        if (this._maxWidth === 0) {\r\n            maxWidth = 2047.9; // Callback when maxWidth is 0\r\n        }\r\n\r\n        // a line should be an unit to split long string\r\n        const lineCountForOnePart = 1;\r\n        const sizeForOnePart = lineCountForOnePart * maxWidth;\r\n\r\n        // divide text into some pieces of which the size is less than sizeForOnePart\r\n        while (curStringSize.x > sizeForOnePart) {\r\n            curEnd /= 2;\r\n            // at least one char can be an entity, step back.\r\n            if (curEnd < 1) {\r\n                curEnd *= 2;\r\n                break;\r\n            }\r\n\r\n            curString = curString.substring(curStart, curEnd);\r\n            leftString = longStr.substring(curEnd);\r\n            this._calculateSize(curStringSize, styleIndex, curString);\r\n        }\r\n\r\n        // avoid too many loops\r\n        let leftTryTimes = 1000;\r\n        // the minimum step of expansion or reduction\r\n        let curWordStep = 1;\r\n        while (leftTryTimes && curStart < text.length) {\r\n            while (leftTryTimes && curStringSize.x < sizeForOnePart) {\r\n                const nextPartExec = getEnglishWordPartAtFirst(leftString);\r\n                // add a character, unless there is a complete word at the beginning of the next line\r\n                if (nextPartExec && nextPartExec.length > 0) {\r\n                    curWordStep = nextPartExec[0].length;\r\n                }\r\n                curEnd += curWordStep;\r\n\r\n                curString = longStr.substring(curStart, curEnd);\r\n                leftString = longStr.substring(curEnd);\r\n                this._calculateSize(curStringSize, styleIndex, curString);\r\n\r\n                leftTryTimes--;\r\n            }\r\n\r\n            // reduce condition：size > maxwidth && curString.length >= 2\r\n            while (leftTryTimes && curString.length >= 2 && curStringSize.x > sizeForOnePart) {\r\n                curEnd -= curWordStep;\r\n                curString = longStr.substring(curStart, curEnd);\r\n                this._calculateSize(curStringSize, styleIndex, curString);\r\n                // after the first reduction, the step should be 1.\r\n                curWordStep = 1;\r\n\r\n                leftTryTimes--;\r\n            }\r\n\r\n            // consider there is a part of a word at the end of this line, it should be moved to the next line\r\n            if (curString.length >= 2) {\r\n                const lastWordExec = getEnglishWordPartAtLast(curString);\r\n                if (\r\n                    lastWordExec &&\r\n                    lastWordExec.length > 0 &&\r\n                    // to avoid endless loop when there is only one word in this line\r\n                    curString !== lastWordExec[0]\r\n                ) {\r\n                    curEnd -= lastWordExec[0].length;\r\n                    curString = longStr.substring(curStart, curEnd);\r\n                }\r\n            }\r\n\r\n            // curStart and curEnd can be float since they are like positions of pointer,\r\n            // but step must be integer because we split the complete characters of which the unit is integer.\r\n            // it is reasonable that using the length of this result to estimate the next result.\r\n            partStringArr.push(curString);\r\n            const partStep = curString.length;\r\n            curStart = curEnd;\r\n            curEnd += partStep;\r\n\r\n            curString = longStr.substring(curStart, curEnd);\r\n            leftString = longStr.substring(curEnd);\r\n            this._calculateSize(leftStringSize, styleIndex, leftString);\r\n            this._calculateSize(curStringSize, styleIndex, curString);\r\n\r\n            leftTryTimes--;\r\n\r\n            // Exit: If the left part string size is less than 2048, the method will finish.\r\n            if (leftStringSize.x < 2048 && curStringSize.x < sizeForOnePart) {\r\n                partStringArr.push(curString);\r\n                curStart = text.length;\r\n                curEnd = text.length;\r\n                curString = leftString;\r\n                if (leftString !== \"\") {\r\n                    partStringArr.push(curString);\r\n                }\r\n                break;\r\n            }\r\n        }\r\n\r\n        return partStringArr;\r\n    }\r\n\r\n    protected _measureText(styleIndex: number, string?: string): number | ((s: string) => number) {\r\n        const func = (s: string): number => {\r\n            const width = this._calculateSize(_tempSize, styleIndex, s).x;\r\n            return width;\r\n        };\r\n        if (string) {\r\n            return func(string);\r\n        } else {\r\n            return func;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @engineInternal\r\n     * @mangle\r\n     */\r\n    protected _calculateSize(out: Vec2, styleIndex: number, s: string): Vec2 {\r\n        let label: ISegment;\r\n        if (this._labelSegmentsCache.length === 0) {\r\n            label = this._createFontLabel(s);\r\n            this._labelSegmentsCache.push(label);\r\n        } else {\r\n            label = this._labelSegmentsCache[0];\r\n            label.node.getComponent(Label)!.string = s;\r\n        }\r\n        label.styleIndex = styleIndex;\r\n        this._applyTextAttribute(label);\r\n        const size = label.node._getUITransformComp()!.contentSize;\r\n        Vec2.set(out, size.x, size.y);\r\n        return out;\r\n    }\r\n\r\n    protected _onTouchEnded(event: EventTouch): void {\r\n        const components = this.node.getComponents(Component);\r\n\r\n        this._segments.forEach((seg) => {\r\n            const clickHandler = seg.clickHandler;\r\n            const clickParam = seg.clickParam;\r\n            if (clickHandler && this._containsTouchLocation(seg, event.touch!.getUILocation())) {\r\n                components.forEach((component) => {\r\n                    const func = component[clickHandler];\r\n                    if (component.enabledInHierarchy && func) {\r\n                        func.call(component, event, clickParam);\r\n                    }\r\n                });\r\n                event.propagationStopped = true;\r\n            }\r\n        });\r\n    }\r\n\r\n    protected _containsTouchLocation(label: ISegment, point: Vec2): boolean {\r\n        const comp = label.node.getComponent(UITransform);\r\n        if (!comp) {\r\n            return false;\r\n        }\r\n\r\n        const myRect = comp.getBoundingBoxToWorld();\r\n        return myRect.contains(point);\r\n    }\r\n\r\n    protected _resetState(): void {\r\n        const children = this.node.children;\r\n\r\n        for (let i = children.length - 1; i >= 0; i--) {\r\n            const child = children[i];\r\n            if (child.name === RichTextChildName || child.name === RichTextChildImageName) {\r\n                if (DEBUG) {\r\n                    assert(child.parent === this.node);\r\n                }\r\n                child.parent = null;\r\n\r\n                const segment = createSegment(child.name);\r\n                segment.node = child;\r\n                if (child.name === RichTextChildName) {\r\n                    segment.comp = child.getComponent(Label);\r\n                    labelPool.put(segment);\r\n                } else {\r\n                    segment.comp = child.getComponent(Sprite);\r\n                    imagePool.put(segment);\r\n                }\r\n                this._labelChildrenNum--;\r\n            }\r\n        }\r\n\r\n        this._segments.length = 0;\r\n        this._labelSegmentsCache.length = 0;\r\n        this._linesWidth.length = 0;\r\n        this._lineOffsetX = 0;\r\n        this._lineCount = 1;\r\n        this._labelWidth = 0;\r\n        this._labelHeight = 0;\r\n        this._layoutDirty = true;\r\n    }\r\n\r\n    protected _activateChildren(active): void {\r\n        for (let i = this.node.children.length - 1; i >= 0; i--) {\r\n            const child = this.node.children[i];\r\n            if (child.name === RichTextChildName || child.name === RichTextChildImageName) {\r\n                child.active = active;\r\n            }\r\n        }\r\n    }\r\n\r\n    protected _addLabelSegment(stringToken: string, styleIndex: number): ISegment {\r\n        let labelSegment: ISegment;\r\n        if (this._labelSegmentsCache.length === 0) {\r\n            labelSegment = this._createFontLabel(stringToken);\r\n        } else {\r\n            labelSegment = this._labelSegmentsCache.pop()!;\r\n            const label = labelSegment.node.getComponent(Label);\r\n            if (label) {\r\n                label.string = stringToken;\r\n            }\r\n        }\r\n\r\n        // set vertical alignments\r\n        // because horizontal alignment is applied with line offsets in method \"_updateRichTextPosition\"\r\n        const labelComp: Label = labelSegment.comp as Label;\r\n        if (labelComp.verticalAlign !== this._verticalAlign) {\r\n            labelComp.verticalAlign = this._verticalAlign;\r\n        }\r\n\r\n        labelSegment.styleIndex = styleIndex;\r\n        labelSegment.lineCount = this._lineCount;\r\n        labelSegment.node._getUITransformComp()!.setAnchorPoint(0, 0);\r\n        labelSegment.node.layer = this.node.layer;\r\n        this.node.insertChild(labelSegment.node, this._labelChildrenNum++);\r\n        this._applyTextAttribute(labelSegment);\r\n        this._segments.push(labelSegment);\r\n\r\n        return labelSegment;\r\n    }\r\n\r\n    protected _updateRichTextWithMaxWidth(labelString: string, labelWidth: number, styleIndex: number): void {\r\n        let fragmentWidth = labelWidth;\r\n        let labelSegment: ISegment;\r\n\r\n        if (this._lineOffsetX > 0 && fragmentWidth + this._lineOffsetX > this._maxWidth) {\r\n            // concat previous line\r\n            let checkStartIndex = 0;\r\n            while (this._lineOffsetX <= this._maxWidth) {\r\n                const checkEndIndex = this._getFirstWordLen(labelString, checkStartIndex, labelString.length);\r\n                const checkString = labelString.substr(checkStartIndex, checkEndIndex);\r\n                const checkStringWidth = this._measureText(styleIndex, checkString) as number;\r\n\r\n                if (this._lineOffsetX + checkStringWidth <= this._maxWidth) {\r\n                    this._lineOffsetX += checkStringWidth;\r\n                    checkStartIndex += checkEndIndex;\r\n                } else {\r\n                    if (checkStartIndex > 0) {\r\n                        const remainingString = labelString.substr(0, checkStartIndex);\r\n                        this._addLabelSegment(remainingString, styleIndex);\r\n                        labelString = labelString.substr(checkStartIndex, labelString.length);\r\n                        fragmentWidth = this._measureText(styleIndex, labelString) as number;\r\n                    }\r\n                    this._updateLineInfo();\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        if (fragmentWidth > this._maxWidth) {\r\n            const fragments = fragmentText(labelString, fragmentWidth, this._maxWidth, this._measureText(styleIndex) as unknown as (s: string) => number);\r\n            for (let k = 0; k < fragments.length; ++k) {\r\n                const splitString = fragments[k];\r\n                labelSegment = this._addLabelSegment(splitString, styleIndex);\r\n                const labelSize = labelSegment.node._getUITransformComp()!.contentSize;\r\n                this._lineOffsetX += labelSize.width;\r\n                if (fragments.length > 1 && k < fragments.length - 1) {\r\n                    this._updateLineInfo();\r\n                }\r\n            }\r\n        } else {\r\n            this._lineOffsetX += fragmentWidth;\r\n            this._addLabelSegment(labelString, styleIndex);\r\n        }\r\n    }\r\n\r\n    protected _isLastComponentCR(stringToken): boolean {\r\n        return stringToken.length - 1 === stringToken.lastIndexOf(\"\\n\");\r\n    }\r\n\r\n    protected _updateLineInfo(): void {\r\n        this._linesWidth.push(this._lineOffsetX);\r\n        this._lineOffsetX = 0;\r\n        this._lineCount++;\r\n    }\r\n\r\n    protected _needsUpdateTextLayout(newTextArray: IHtmlTextParserResultObj[]): boolean {\r\n        if (this._layoutDirty || !this._textArray || !newTextArray) {\r\n            return true;\r\n        }\r\n\r\n        if (this._textArray.length !== newTextArray.length) {\r\n            return true;\r\n        }\r\n\r\n        for (let i = 0; i < this._textArray.length; i++) {\r\n            const oldItem = this._textArray[i];\r\n            const newItem = newTextArray[i];\r\n            if (oldItem.text !== newItem.text) {\r\n                return true;\r\n            } else {\r\n                const oldStyle = oldItem.style;\r\n                const newStyle = newItem.style;\r\n                if (oldStyle) {\r\n                    if (newStyle) {\r\n                        if (!!newStyle.outline !== !!oldStyle.outline) {\r\n                            return true;\r\n                        }\r\n                        if (oldStyle.size !== newStyle.size || oldStyle.italic !== newStyle.italic || oldStyle.isImage !== newStyle.isImage) {\r\n                            return true;\r\n                        }\r\n                        if (\r\n                            oldStyle.src !== newStyle.src ||\r\n                            oldStyle.imageAlign !== newStyle.imageAlign ||\r\n                            oldStyle.imageHeight !== newStyle.imageHeight ||\r\n                            oldStyle.imageWidth !== newStyle.imageWidth ||\r\n                            oldStyle.imageOffset !== newStyle.imageOffset\r\n                        ) {\r\n                            return true;\r\n                        }\r\n                    } else if (oldStyle.size || oldStyle.italic || oldStyle.isImage || oldStyle.outline) {\r\n                        return true;\r\n                    }\r\n                } else if (newStyle) {\r\n                    if (newStyle.size || newStyle.italic || newStyle.isImage || newStyle.outline) {\r\n                        return true;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    protected _addRichTextImageElement(richTextElement: IHtmlTextParserResultObj): void {\r\n        if (!richTextElement.style) {\r\n            return;\r\n        }\r\n\r\n        const style = richTextElement.style;\r\n        const spriteFrameName = style.src;\r\n        const spriteFrame = this._imageAtlas && spriteFrameName && this._imageAtlas.getSpriteFrame(spriteFrameName);\r\n        if (!spriteFrame) {\r\n            warnID(4400);\r\n        } else {\r\n            const segment = this._createImage(spriteFrame);\r\n            const uiTransform = segment.node._getUITransformComp()!;\r\n            switch (style.imageAlign) {\r\n                case \"top\":\r\n                    uiTransform.setAnchorPoint(0, 1);\r\n                    break;\r\n                case \"center\":\r\n                    uiTransform.setAnchorPoint(0, 0.5);\r\n                    break;\r\n                default:\r\n                    uiTransform.setAnchorPoint(0, 0);\r\n                    break;\r\n            }\r\n\r\n            if (style.imageOffset) {\r\n                segment.imageOffset = style.imageOffset;\r\n            }\r\n            segment.node.layer = this.node.layer;\r\n            this.node.insertChild(segment.node, this._labelChildrenNum++);\r\n            this._segments.push(segment);\r\n\r\n            const spriteRect = spriteFrame.rect.clone();\r\n            let scaleFactor = 1;\r\n            let spriteWidth = spriteRect.width;\r\n            let spriteHeight = spriteRect.height;\r\n            const expectWidth = style.imageWidth || 0;\r\n            const expectHeight = style.imageHeight || 0;\r\n\r\n            if (expectHeight > 0) {\r\n                scaleFactor = expectHeight / spriteHeight;\r\n                spriteWidth *= scaleFactor;\r\n                spriteHeight *= scaleFactor;\r\n            } else {\r\n                scaleFactor = this._lineHeight / spriteHeight;\r\n                spriteWidth *= scaleFactor;\r\n                spriteHeight *= scaleFactor;\r\n            }\r\n\r\n            if (expectWidth > 0) {\r\n                spriteWidth = expectWidth;\r\n            }\r\n\r\n            if (this._maxWidth > 0) {\r\n                if (this._lineOffsetX + spriteWidth > this._maxWidth) {\r\n                    this._updateLineInfo();\r\n                }\r\n                this._lineOffsetX += spriteWidth;\r\n            } else {\r\n                this._lineOffsetX += spriteWidth;\r\n                if (this._lineOffsetX > this._labelWidth) {\r\n                    this._labelWidth = this._lineOffsetX;\r\n                }\r\n            }\r\n            uiTransform.setContentSize(spriteWidth, spriteHeight);\r\n            segment.lineCount = this._lineCount;\r\n\r\n            segment.clickHandler = \"\";\r\n            segment.clickParam = \"\";\r\n            const event = style.event;\r\n            if (event) {\r\n                segment.clickHandler = event.click;\r\n                segment.clickParam = event.param;\r\n            }\r\n        }\r\n    }\r\n\r\n    protected _updateTextDefaultColor(): void {\r\n        for (let i = 0; i < this._segments.length; ++i) {\r\n            const segment = this._segments[i];\r\n            const label = segment.node.getComponent(Label);\r\n            if (!label) {\r\n                continue;\r\n            }\r\n            if (this._textArray[segment.styleIndex]?.style?.color) {\r\n                continue;\r\n            }\r\n\r\n            label.color = this._fontColor;\r\n        }\r\n    }\r\n\r\n    protected _updateRichText(): void {\r\n        if (!this.enabledInHierarchy) {\r\n            return;\r\n        }\r\n\r\n        const newTextArray = _htmlTextParser.parse(this._string);\r\n        if (!this._needsUpdateTextLayout(newTextArray)) {\r\n            this._textArray = newTextArray.slice();\r\n            this._updateLabelSegmentTextAttributes();\r\n            return;\r\n        }\r\n\r\n        this._textArray = newTextArray.slice();\r\n        this._resetState();\r\n\r\n        let lastEmptyLine = false;\r\n        let label: ISegment;\r\n\r\n        for (let i = 0; i < this._textArray.length; ++i) {\r\n            const richTextElement = this._textArray[i];\r\n            let text = richTextElement.text;\r\n            if (text === undefined) {\r\n                continue;\r\n            }\r\n\r\n            // handle <br/> <img /> tag\r\n            if (text === \"\") {\r\n                if (richTextElement.style && richTextElement.style.isNewLine) {\r\n                    this._updateLineInfo();\r\n                    continue;\r\n                }\r\n                if (richTextElement.style && richTextElement.style.isImage && this._imageAtlas) {\r\n                    this._addRichTextImageElement(richTextElement);\r\n                    continue;\r\n                }\r\n            }\r\n\r\n            const splitArr: string[] = this.splitLongStringApproximatelyIn2048(text, i);\r\n            text = splitArr.join(\"\\n\");\r\n\r\n            const multilineTexts = text.split(\"\\n\");\r\n\r\n            for (let j = 0; j < multilineTexts.length; ++j) {\r\n                const labelString = multilineTexts[j];\r\n                if (labelString === \"\") {\r\n                    // for continues \\n\r\n                    if (this._isLastComponentCR(text) && j === multilineTexts.length - 1) {\r\n                        continue;\r\n                    }\r\n                    this._updateLineInfo();\r\n                    lastEmptyLine = true;\r\n                    continue;\r\n                }\r\n                lastEmptyLine = false;\r\n\r\n                if (this._maxWidth > 0) {\r\n                    const labelWidth = this._measureText(i, labelString) as number;\r\n                    this._updateRichTextWithMaxWidth(labelString, labelWidth, i);\r\n\r\n                    if (multilineTexts.length > 1 && j < multilineTexts.length - 1) {\r\n                        this._updateLineInfo();\r\n                    }\r\n                } else {\r\n                    label = this._addLabelSegment(labelString, i);\r\n\r\n                    this._lineOffsetX += label.node._getUITransformComp()!.width;\r\n                    if (this._lineOffsetX > this._labelWidth) {\r\n                        this._labelWidth = this._lineOffsetX;\r\n                    }\r\n\r\n                    if (multilineTexts.length > 1 && j < multilineTexts.length - 1) {\r\n                        this._updateLineInfo();\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        if (!lastEmptyLine) {\r\n            this._linesWidth.push(this._lineOffsetX);\r\n        }\r\n\r\n        if (this._maxWidth > 0) {\r\n            this._labelWidth = this._maxWidth;\r\n        }\r\n        this._labelHeight = (this._lineCount + BASELINE_RATIO) * this._lineHeight;\r\n\r\n        // trigger \"size-changed\" event\r\n        this.node._getUITransformComp()!.setContentSize(this._labelWidth, this._labelHeight);\r\n\r\n        this._updateRichTextPosition();\r\n        this._layoutDirty = false;\r\n    }\r\n\r\n    protected _getFirstWordLen(text: string, startIndex: number, textLen: number): number {\r\n        let character = getSymbolAt(text, startIndex);\r\n        if (isUnicodeCJK(character) || isUnicodeSpace(character)) {\r\n            return 1;\r\n        }\r\n\r\n        let len = 1;\r\n        for (let index = startIndex + 1; index < textLen; ++index) {\r\n            character = getSymbolAt(text, index);\r\n            if (isUnicodeSpace(character) || isUnicodeCJK(character)) {\r\n                break;\r\n            }\r\n\r\n            len++;\r\n        }\r\n\r\n        return len;\r\n    }\r\n\r\n    protected _updateRichTextPosition(): void {\r\n        let nextTokenX = 0;\r\n        let nextLineIndex = 1;\r\n        const totalLineCount = this._lineCount;\r\n        const trans = this.node._getUITransformComp()!;\r\n        const anchorX = trans.anchorX;\r\n        const anchorY = trans.anchorY;\r\n        for (let i = 0; i < this._segments.length; ++i) {\r\n            const segment = this._segments[i];\r\n            const lineCount = segment.lineCount;\r\n            if (lineCount > nextLineIndex) {\r\n                nextTokenX = 0;\r\n                nextLineIndex = lineCount;\r\n            }\r\n\r\n            let lineOffsetX = this._labelWidth * (this._horizontalAlign * 0.5 - anchorX);\r\n            switch (this._horizontalAlign) {\r\n                case HorizontalTextAlignment.LEFT:\r\n                    break;\r\n                case HorizontalTextAlignment.CENTER:\r\n                    lineOffsetX -= this._linesWidth[lineCount - 1] / 2;\r\n                    break;\r\n                case HorizontalTextAlignment.RIGHT:\r\n                    lineOffsetX -= this._linesWidth[lineCount - 1];\r\n                    break;\r\n                default:\r\n                    break;\r\n            }\r\n\r\n            const segmentNode = segment.node;\r\n\r\n            const pos = segmentNode.position;\r\n            segmentNode.setPosition(nextTokenX + lineOffsetX, this._lineHeight * (totalLineCount - lineCount) - this._labelHeight * anchorY, pos.z);\r\n\r\n            if (lineCount === nextLineIndex) {\r\n                nextTokenX += segmentNode._getUITransformComp()!.width;\r\n            }\r\n\r\n            const sprite = segmentNode.getComponent(Sprite);\r\n            if (sprite) {\r\n                const position = segmentNode.position.clone();\r\n                // adjust img align (from <img align=top|center|bottom>)\r\n                const lineHeightSet = this._lineHeight;\r\n                const lineHeightReal = this._lineHeight * (1 + BASELINE_RATIO); // single line node height\r\n                switch (segmentNode._getUITransformComp()!.anchorY) {\r\n                    case 1:\r\n                        position.y += lineHeightSet + (lineHeightReal - lineHeightSet) / 2;\r\n                        break;\r\n                    case 0.5:\r\n                        position.y += lineHeightReal / 2;\r\n                        break;\r\n                    default:\r\n                        position.y += (lineHeightReal - lineHeightSet) / 2;\r\n                        break;\r\n                }\r\n                // adjust img offset (from <img offset=12|12,34>)\r\n                if (segment.imageOffset) {\r\n                    const offsets = segment.imageOffset.split(\",\");\r\n                    if (offsets.length === 1 && offsets[0]) {\r\n                        const offsetY = parseFloat(offsets[0]);\r\n                        if (Number.isInteger(offsetY)) position.y += offsetY;\r\n                    } else if (offsets.length === 2) {\r\n                        const offsetX = parseFloat(offsets[0]);\r\n                        const offsetY = parseFloat(offsets[1]);\r\n                        if (Number.isInteger(offsetX)) position.x += offsetX;\r\n                        if (Number.isInteger(offsetY)) position.y += offsetY;\r\n                    }\r\n                }\r\n                segmentNode.position = position;\r\n            }\r\n\r\n            // adjust y for label with outline\r\n            const label = segmentNode.getComponent(Label);\r\n            if (label && label.enableOutline) {\r\n                const position = segmentNode.position.clone();\r\n                position.y -= label.outlineWidth;\r\n                segmentNode.position = position;\r\n            }\r\n        }\r\n    }\r\n\r\n    protected _convertLiteralColorValue(color: string): Color {\r\n        const colorValue = color.toUpperCase();\r\n        if (Color[colorValue]) {\r\n            const colorUse: Color = Color[colorValue];\r\n            return colorUse;\r\n        } else {\r\n            const out = new Color();\r\n            return out.fromHEX(color);\r\n        }\r\n    }\r\n\r\n    protected _applyTextAttribute(labelSeg: ISegment): void {\r\n        const label = labelSeg.node.getComponent(Label);\r\n        if (!label) {\r\n            return;\r\n        }\r\n        this._resetLabelState(label);\r\n\r\n        const index = labelSeg.styleIndex;\r\n\r\n        let textStyle: IHtmlTextParserStack | undefined;\r\n        if (this._textArray[index]) {\r\n            textStyle = this._textArray[index].style;\r\n        }\r\n\r\n        if (textStyle) {\r\n            if (textStyle.color) {\r\n                label.color = this._convertLiteralColorValue(textStyle.color);\r\n            } else {\r\n                label.color = this._fontColor;\r\n            }\r\n            label.isBold = !!textStyle.bold;\r\n            label.isItalic = !!textStyle.italic;\r\n            // TODO: temporary implementation, the italic effect should be implemented in the internal of label-assembler.\r\n            // if (textStyle.italic) {\r\n            //     labelNode.skewX = 12;\r\n            // }\r\n\r\n            label.isUnderline = !!textStyle.underline;\r\n            if (textStyle.outline) {\r\n                label.enableOutline = true;\r\n                label.outlineColor = this._convertLiteralColorValue(textStyle.outline.color);\r\n                label.outlineWidth = textStyle.outline.width;\r\n            }\r\n\r\n            label.fontSize = textStyle.size || this._fontSize;\r\n\r\n            labelSeg.clickHandler = \"\";\r\n            labelSeg.clickParam = \"\";\r\n            const event = textStyle.event;\r\n            if (event) {\r\n                labelSeg.clickHandler = event.click || \"\";\r\n                labelSeg.clickParam = event.param || \"\";\r\n            }\r\n        }\r\n\r\n        label.cacheMode = this._cacheMode;\r\n\r\n        const isAsset = this._font instanceof Font;\r\n        if (isAsset && !this._isSystemFontUsed) {\r\n            label.font = this._font;\r\n        } else {\r\n            label.fontFamily = this._fontFamily;\r\n        }\r\n        label.useSystemFont = this._isSystemFontUsed;\r\n        label.lineHeight = this._lineHeight;\r\n\r\n        label.updateRenderData(true);\r\n    }\r\n\r\n    protected _applyLayer(): void {\r\n        this._segments.forEach((seg) => {\r\n            seg.node.layer = this.node.layer;\r\n        });\r\n    }\r\n\r\n    protected _resetLabelState(label: Label): void {\r\n        label.fontSize = this._fontSize;\r\n        label.color = this._fontColor;\r\n        label.isBold = false;\r\n        label.isItalic = false;\r\n        label.isUnderline = false;\r\n    }\r\n}\r\n\r\ncclegacy.RichText = RichText;\r\n"],"names":["_htmlTextParser","HtmlTextParser","RichTextChildName","RichTextChildImageName","_tempSize","Vec2","_tempSizeLeft","labelPool","js","seg","cclegacy","isValid","node","label","getComponent","Label","outlineWidth","imagePool","createSegment","type","Node","comp","lineCount","styleIndex","imageOffset","clickParam","clickHandler","getSegmentByPool","content","richTextNode","_get","hideFlags","CCObjectFlags","DontSave","HideInHierarchy","active","Sprite","addComponent","spriteFrame","Type","SLICED","sizeMode","SizeMode","CUSTOM","string","horizontalAlign","HorizontalTextAlignment","LEFT","verticalAlign","VerticalTextAlignment","TOP","underlineHeight","parentSorting2d","Sorting2D","sorting2d","sortingLayer","sortingOrder","setPosition","_getUITransformComp","setAnchorPoint","RichText","ccclass","_dec2","requireComponent","UITransform","executionOrder","_dec5","Color","Font","_dec8","CacheMode","SpriteAtlas","_dec","_class","_dec3","_class3","_Component","_this","call","this","_lineHeight","_initializer","_string","_initializer2","_horizontalAlign","_initializer3","_verticalAlign","_initializer4","_fontSize","_initializer5","_fontColor","_initializer6","_maxWidth","_initializer7","_fontFamily","_initializer8","_font","_initializer9","_isSystemFontUsed","_initializer10","_userDefinedFont","_initializer11","_cacheMode","_initializer12","_imageAtlas","_initializer13","_handleTouchEvent","_initializer14","_textArray","_segments","_labelSegmentsCache","_linesWidth","_lineCount","_labelWidth","_labelHeight","_layoutDirty","_lineOffsetX","_labelChildrenNum","_updateRichTextStatus","_updateRichText","_inheritsLoose","_proto","prototype","onLoad","on","NodeEventType","LAYER_CHANGED","_applyLayer","ANCHOR_CHANGED","_updateRichTextPosition","onEnable","handleTouchEvent","_addEventListeners","_activateChildren","onDisable","_removeEventListeners","onRestore","onDestroy","forEach","removeFromParent","put","off","TOUCH_END","_onTouchEnded","_updateLabelSegmentTextAttributes","_this2","item","_applyTextAttribute","_createFontLabel","str","_createImage","_onTTFLoaded","splitLongStringApproximatelyIn2048","text","partStringArr","length","fontSize","push","_calculateSize","x","multilineTexts","split","i","thisPartSplitResultArr","splitLongStringOver2048","apply","longStr","curStart","curEnd","curString","substring","leftString","curStringSize","leftStringSize","maxWidth","sizeForOnePart","leftTryTimes","curWordStep","nextPartExec","getEnglishWordPartAtFirst","lastWordExec","getEnglishWordPartAtLast","_measureText","_this3","func","s","out","size","contentSize","set","y","event","_this4","components","getComponents","Component","_containsTouchLocation","touch","getUILocation","component","enabledInHierarchy","propagationStopped","point","getBoundingBoxToWorld","contains","_resetState","children","child","name","assert","parent","segment","_addLabelSegment","stringToken","labelSegment","pop","labelComp","layer","insertChild","_updateRichTextWithMaxWidth","labelString","labelWidth","fragmentWidth","checkStartIndex","checkEndIndex","_getFirstWordLen","checkString","substr","checkStringWidth","remainingString","_updateLineInfo","fragments","fragmentText","k","splitString","labelSize","width","_isLastComponentCR","lastIndexOf","_needsUpdateTextLayout","newTextArray","oldItem","newItem","oldStyle","style","newStyle","outline","italic","isImage","src","imageAlign","imageHeight","imageWidth","_addRichTextImageElement","richTextElement","spriteFrameName","getSpriteFrame","uiTransform","spriteRect","rect","clone","scaleFactor","spriteWidth","spriteHeight","height","expectWidth","expectHeight","setContentSize","click","param","warnID","_updateTextDefaultColor","_this$_textArray$segm","_this$_textArray$segm2","color","parse","slice","lastEmptyLine","undefined","isNewLine","join","j","BASELINE_RATIO","startIndex","textLen","character","getSymbolAt","isUnicodeCJK","isUnicodeSpace","len","index","nextTokenX","nextLineIndex","totalLineCount","trans","anchorX","anchorY","lineOffsetX","CENTER","RIGHT","segmentNode","pos","position","z","lineHeightSet","lineHeightReal","offsets","offsetY","parseFloat","Number","isInteger","offsetX","enableOutline","_convertLiteralColorValue","colorValue","toUpperCase","fromHEX","labelSeg","_resetLabelState","textStyle","isBold","bold","isItalic","isUnderline","underline","outlineColor","cacheMode","font","fontFamily","useSystemFont","lineHeight","updateRenderData","_this5","_createClass","key","get","value","HorizontalAlign","VerticalAlign","_applyDecoratedDescriptor","_class2","_dec4","Object","getOwnPropertyDescriptor","_dec6","_dec7","_dec9","_applyDecoratedInitializer","serializable","WHITE","NONE"],"mappings":"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"}