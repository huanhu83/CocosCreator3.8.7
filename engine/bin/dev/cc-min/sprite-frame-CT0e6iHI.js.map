{"version":3,"file":"sprite-frame-CT0e6iHI.js","sources":["../../../cocos/2d/utils/dynamic-atlas/atlas.ts","../../../cocos/2d/utils/dynamic-atlas/atlas-manager.ts","../../../cocos/2d/assets/sprite-frame.ts"],"sourcesContent":["/*\r\n Copyright (c) 2022-2023 Xiamen Yaji Software Co., Ltd.\r\n\r\n https://www.cocos.com/\r\n\r\n Permission is hereby granted, free of charge, to any person obtaining a copy\r\n of this software and associated documentation files (the \"Software\"), to deal\r\n in the Software without restriction, including without limitation the rights to\r\n use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\r\n of the Software, and to permit persons to whom the Software is furnished to do so,\r\n subject to the following conditions:\r\n\r\n The above copyright notice and this permission notice shall be included in\r\n all copies or substantial portions of the Software.\r\n\r\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n THE SOFTWARE.\r\n*/\r\n\r\nimport { PixelFormat } from '../../../asset/assets/asset-enum';\r\nimport { ImageAsset } from '../../../asset/assets/image-asset';\r\nimport { Texture2D } from '../../../asset/assets/texture-2d';\r\nimport { BufferTextureCopy } from '../../../gfx';\r\nimport { cclegacy, js, warnID } from '../../../core';\r\nimport { SpriteFrame } from '../../assets/sprite-frame';\r\n\r\nconst space = 2;\r\n\r\nfunction drawTextureAt (texture: DynamicAtlasTexture, image: ImageAsset, x: number, y: number): void {\r\n    texture.drawTextureAt(image, x, y);\r\n}\r\n\r\nexport class Atlas {\r\n    private declare _texture: DynamicAtlasTexture;\r\n    private declare _width: number;\r\n    private declare _height: number;\r\n    private declare _x: number;\r\n    private declare _y: number;\r\n    private declare _nextY: number;\r\n    private _innerTextureInfos: Record<string, {\r\n            x: number,\r\n            y: number,\r\n            texture: Texture2D,\r\n        }> = {};\r\n    private _innerSpriteFrames: SpriteFrame[] = [];\r\n    private _count: number = 0;\r\n\r\n    constructor (width: number, height: number) {\r\n        const texture = new DynamicAtlasTexture();\r\n        texture.initWithSize(width, height);\r\n        this._texture = texture;\r\n\r\n        this._width = width;\r\n        this._height = height;\r\n\r\n        this._x = space;\r\n        this._y = space;\r\n        this._nextY = space;\r\n    }\r\n\r\n    /**\r\n     * @en\r\n     * Append a sprite frame into the dynamic atlas.\r\n     *\r\n     * @zh\r\n     * 添加碎图进入动态图集。\r\n     *\r\n     * @method insertSpriteFrame\r\n     * @param spriteFrame  the sprite frame that will be inserted in the atlas.\r\n     */\r\n    public insertSpriteFrame (spriteFrame: SpriteFrame): {\r\n        x: number;\r\n        y: number;\r\n        texture: DynamicAtlasTexture;\r\n    } | null {\r\n        const rect = spriteFrame.rect;\r\n        // Todo:No renderTexture\r\n        const texture = spriteFrame.texture as Texture2D;\r\n        const info = this._innerTextureInfos[texture.getId()];\r\n\r\n        let sx = rect.x;\r\n        let sy = rect.y;\r\n\r\n        if (info) {\r\n            sx += info.x;\r\n            sy += info.y;\r\n        } else {\r\n            const width = texture.width;\r\n            const height = texture.height;\r\n\r\n            if ((this._x + width + space) > this._width) {\r\n                this._x = space;\r\n                this._y = this._nextY;\r\n            }\r\n\r\n            if ((this._y + height + space) > this._nextY) {\r\n                this._nextY = this._y + height + space;\r\n            }\r\n\r\n            if (this._nextY > this._height) {\r\n                return null;\r\n            }\r\n\r\n            const thisTexture = this._texture;\r\n            const image = texture.image!;\r\n\r\n            if (cclegacy.internal.dynamicAtlasManager.textureBleeding) {\r\n                // Smaller frame is more likely to be affected by linear filter\r\n                if (width <= 8 || height <= 8) {\r\n                    drawTextureAt(thisTexture, image, this._x - 1, this._y - 1);\r\n                    drawTextureAt(thisTexture, image, this._x - 1, this._y + 1);\r\n                    drawTextureAt(thisTexture, image, this._x + 1, this._y - 1);\r\n                    drawTextureAt(thisTexture, image, this._x + 1, this._y + 1);\r\n                }\r\n\r\n                drawTextureAt(thisTexture, image, this._x - 1, this._y);\r\n                drawTextureAt(thisTexture, image, this._x + 1, this._y);\r\n                drawTextureAt(thisTexture, image, this._x, this._y - 1);\r\n                drawTextureAt(thisTexture, image, this._x, this._y + 1);\r\n            }\r\n\r\n            drawTextureAt(thisTexture, image, this._x, this._y);\r\n\r\n            this._innerTextureInfos[texture.getId()] = {\r\n                x: this._x,\r\n                y: this._y,\r\n                texture,\r\n            };\r\n\r\n            this._count++;\r\n\r\n            sx += this._x;\r\n            sy += this._y;\r\n\r\n            this._x += width + space;\r\n        }\r\n\r\n        const frame = {\r\n            x: sx,\r\n            y: sy,\r\n            texture: this._texture,\r\n        };\r\n\r\n        this._innerSpriteFrames.push(spriteFrame);\r\n\r\n        return frame;\r\n    }\r\n\r\n    public removeSpriteFrame (spriteFrame: SpriteFrame): void {\r\n        js.array.fastRemove(this._innerSpriteFrames, spriteFrame);\r\n    }\r\n\r\n    /**\r\n     * @en\r\n     * Delete a texture from the atlas.\r\n     *\r\n     * @zh\r\n     * 从动态图集中删除某张纹理。\r\n     *\r\n     * @method deleteAtlasTexture\r\n     * @param texture  the texture that will be removed from the atlas.\r\n     */\r\n    public deleteInnerTexture (texture: Texture2D): void {\r\n        if (texture && this._innerTextureInfos[texture.getId()]) {\r\n            delete this._innerTextureInfos[texture.getId()];\r\n            this._count--;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @en\r\n     * Whether the atlas is empty.\r\n     *\r\n     * @zh\r\n     * 图集是否为空图集。\r\n     *\r\n     * @method isEmpty\r\n     */\r\n    public isEmpty (): boolean {\r\n        return this._count <= 0;\r\n    }\r\n\r\n    /**\r\n     * @en\r\n     * Reset the dynamic atlas.\r\n     *\r\n     * @zh\r\n     * 重置该动态图集。\r\n     *\r\n     * @method reset\r\n    */\r\n    public reset (): void {\r\n        this._x = space;\r\n        this._y = space;\r\n        this._nextY = space;\r\n\r\n        const frames = this._innerSpriteFrames;\r\n        for (let i = 0, l = frames.length; i < l; i++) {\r\n            const frame = frames[i];\r\n            if (!frame.isValid) {\r\n                continue;\r\n            }\r\n            frame._resetDynamicAtlasFrame();\r\n        }\r\n        this._innerSpriteFrames.length = 0;\r\n        this._innerTextureInfos = {};\r\n    }\r\n\r\n    /**\r\n     * @en\r\n     * Reset the dynamic atlas, and destroy the texture of the atlas.\r\n     *\r\n     * @zh\r\n     * 重置该动态图集，并销毁该图集的纹理。\r\n     *\r\n     * @method destroy\r\n    */\r\n    public destroy (): void {\r\n        this.reset();\r\n        this._texture.destroy();\r\n    }\r\n}\r\n\r\nexport class DynamicAtlasTexture extends Texture2D {\r\n    /**\r\n     * @en\r\n     * Initialize the render texture.\r\n     *\r\n     * @zh\r\n     * 初始化 render texture。\r\n     *\r\n     * @method initWithSize\r\n     */\r\n    public initWithSize (width: number, height: number, format: number = PixelFormat.RGBA8888): void {\r\n        this.reset({\r\n            width,\r\n            height,\r\n            format,\r\n        });\r\n    }\r\n\r\n    /**\r\n     * @en\r\n     * Draw a texture to the specified position.\r\n     *\r\n     * @zh\r\n     * 将指定的图片渲染到指定的位置上。\r\n     *\r\n     * @method drawTextureAt\r\n     * @param {Texture2D} image\r\n     * @param {Number} x\r\n     * @param {Number} y\r\n     */\r\n    public drawTextureAt (image: ImageAsset, x: number, y: number): void {\r\n        const gfxTexture = this.getGFXTexture();\r\n        if (!image || !gfxTexture) {\r\n            return;\r\n        }\r\n\r\n        const gfxDevice = this._getGFXDevice();\r\n        if (!gfxDevice) {\r\n            warnID(16363);\r\n            return;\r\n        }\r\n\r\n        const region = new BufferTextureCopy();\r\n        region.texOffset.x = x;\r\n        region.texOffset.y = y;\r\n        region.texExtent.width = image.width;\r\n        region.texExtent.height = image.height;\r\n        gfxDevice.copyTexImagesToTexture([image.data as HTMLCanvasElement], gfxTexture, [region]);\r\n    }\r\n}\r\n","/*\r\n Copyright (c) 2022-2023 Xiamen Yaji Software Co., Ltd.\r\n\r\n https://www.cocos.com/\r\n\r\n Permission is hereby granted, free of charge, to any person obtaining a copy\r\n of this software and associated documentation files (the \"Software\"), to deal\r\n in the Software without restriction, including without limitation the rights to\r\n use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\r\n of the Software, and to permit persons to whom the Software is furnished to do so,\r\n subject to the following conditions:\r\n\r\n The above copyright notice and this permission notice shall be included in\r\n all copies or substantial portions of the Software.\r\n\r\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n THE SOFTWARE.\r\n*/\r\n\r\nimport { EDITOR_NOT_IN_PREVIEW } from 'internal:constants';\r\nimport { System, macro, cclegacy } from '../../../core';\r\nimport { Atlas, DynamicAtlasTexture } from './atlas';\r\nimport { director, DirectorEvent } from '../../../game';\r\nimport { SpriteFrame } from '../../assets';\r\nimport { Filter } from '../../../gfx/base/define';\r\nimport { TextureBase } from '../../../asset/assets/texture-base';\r\nimport { Texture2D } from '../../../asset/assets';\r\n\r\n/**\r\n * @en The dynamic atlas manager which manages all runtime dynamic packed atlas texture for UI rendering.\r\n * It generates a maximum of [[maxAtlasCount]] atlas texture, all atlas texture have the size of [[textureSize]].\r\n * Normally the [[Root.batcher2D]] is in charge of submitting sprite frames to the dynamic atlas manager, the process is transparent to user.\r\n * Note that the first committed sprite frame will define the filter settings of the atlas textures,\r\n * only sprite frame with the same setting will be accepted afterward.\r\n * @zh 动态合图的管理器，管理所有运行时动态合成的图集，主要用于 UI 渲染。\r\n * 该管理器支持生成 [[maxAtlasCount]] 张动态合图，并且所有合图都有同样的 [[textureSize]] 像素尺寸。\r\n * 一般来说 [[Root.batcher2D]] 负责提交 [[SpriteFrame]] 到动态合图管理器中，这个过程对于开发者是透明的。\r\n * 需要注意的是，第一个提交的 [[SpriteFrame]] 会决定图集的过滤器参数，在此之后只有同样参数的贴图才会被管理器接受。\r\n */\r\nexport class DynamicAtlasManager extends System {\r\n    public static instance: DynamicAtlasManager;\r\n\r\n    private _atlases: Atlas[] = [];\r\n    private _atlasIndex = -1;\r\n\r\n    private _maxAtlasCount = 5;\r\n    private _textureSize = 2048;\r\n    private _maxFrameSize = 512;\r\n    private _textureBleeding = true;\r\n\r\n    private _enabled = false;\r\n\r\n    constructor () {\r\n        super();\r\n    }\r\n\r\n    /**\r\n     * @en\r\n     * Enable or disable the dynamic atlas.\r\n     *\r\n     * @zh\r\n     * 开启或关闭动态图集。\r\n     */\r\n    get enabled (): boolean {\r\n        return this._enabled;\r\n    }\r\n    set enabled (value) {\r\n        if (this._enabled === value) return;\r\n\r\n        if (value) {\r\n            this.reset();\r\n            director.on(DirectorEvent.BEFORE_SCENE_LAUNCH, this.beforeSceneLoad, this);\r\n        } else {\r\n            this.reset();\r\n            director.off(DirectorEvent.BEFORE_SCENE_LAUNCH, this.beforeSceneLoad, this);\r\n        }\r\n\r\n        this._enabled = value;\r\n    }\r\n\r\n    /**\r\n     * @en\r\n     * The maximum number of atlases that can be created.\r\n     *\r\n     * @zh\r\n     * 可以创建的最大图集数量。\r\n     */\r\n    get maxAtlasCount (): number {\r\n        return this._maxAtlasCount;\r\n    }\r\n    set maxAtlasCount (value) {\r\n        this._maxAtlasCount = value;\r\n    }\r\n\r\n    /**\r\n     * @en\r\n     * Get the current created atlas count.\r\n     *\r\n     * @zh\r\n     * 获取当前已经创建的图集数量。\r\n     */\r\n    get atlasCount (): number {\r\n        return this._atlases.length;\r\n    }\r\n\r\n    /**\r\n     * @en\r\n     * Whether to enable textureBleeding.\r\n     *\r\n     * @zh\r\n     * 是否开启 textureBleeding。\r\n     */\r\n    get textureBleeding (): boolean {\r\n        return this._textureBleeding;\r\n    }\r\n    set textureBleeding (enable) {\r\n        this._textureBleeding = enable;\r\n    }\r\n\r\n    /**\r\n     * @en\r\n     * The size of the created atlas.\r\n     *\r\n     * @zh\r\n     * 创建的图集的宽高。\r\n     */\r\n    get textureSize (): number {\r\n        return this._textureSize;\r\n    }\r\n    set textureSize (value) {\r\n        this._textureSize = value;\r\n    }\r\n\r\n    /**\r\n     * @en\r\n     * The maximum size of the picture that can be added to the atlas.\r\n     *\r\n     * @zh\r\n     * 可以添加进图集的图片的最大尺寸。\r\n     */\r\n    get maxFrameSize (): number {\r\n        return this._maxFrameSize;\r\n    }\r\n    set maxFrameSize (value) {\r\n        this._maxFrameSize = value;\r\n    }\r\n\r\n    private newAtlas (): Atlas | null {\r\n        let atlas = this._atlases[++this._atlasIndex];\r\n        if (!atlas && this._atlasIndex < this.maxAtlasCount) {\r\n            atlas = new Atlas(this._textureSize, this._textureSize);\r\n            this._atlases.push(atlas);\r\n        }\r\n        return atlas;\r\n    }\r\n\r\n    private beforeSceneLoad (): void {\r\n        this.reset();\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public init (): void {\r\n        this.enabled = !macro.CLEANUP_IMAGE_CACHE;\r\n    }\r\n\r\n    /**\r\n     * @en\r\n     * Append a sprite frame into the dynamic atlas.\r\n     *\r\n     * @zh\r\n     * 添加碎图进入动态图集。\r\n     *\r\n     * @method insertSpriteFrame\r\n     * @param spriteFrame  the sprite frame that will be inserted in the atlas.\r\n     */\r\n    public insertSpriteFrame (spriteFrame: SpriteFrame):  {\r\n        x: number;\r\n        y: number;\r\n        texture: DynamicAtlasTexture;\r\n    } | null {\r\n        if (EDITOR_NOT_IN_PREVIEW) return null;\r\n        if (!this._enabled || this._atlasIndex >= this._maxAtlasCount\r\n            || !spriteFrame || spriteFrame.original) return null;\r\n\r\n        if (!spriteFrame.packable) return null;\r\n\r\n        // hack for pixel game,should pack to different sampler atlas\r\n        const sampler = spriteFrame.texture.getSamplerInfo();\r\n        if (sampler.minFilter !== Filter.LINEAR || sampler.magFilter !== Filter.LINEAR || sampler.mipFilter !== Filter.NONE) {\r\n            return null;\r\n        }\r\n\r\n        let atlas: Atlas | null = this._atlases[this._atlasIndex];\r\n        if (!atlas) {\r\n            atlas = this.newAtlas();\r\n        }\r\n\r\n        const frame = atlas ? atlas.insertSpriteFrame(spriteFrame) : null;\r\n        if (!frame && this._atlasIndex < this._maxAtlasCount) {\r\n            atlas = this.newAtlas();\r\n            return atlas ? atlas.insertSpriteFrame(spriteFrame) : null;\r\n        }\r\n        return frame;\r\n    }\r\n\r\n    /**\r\n     * @en\r\n     * Reset all dynamic atlases, and all existing ones will be destroyed.\r\n     *\r\n     * @zh\r\n     * 重置所有动态图集，已有的动态图集会被销毁。\r\n     *\r\n     * @method reset\r\n    */\r\n    public reset (): void {\r\n        for (let i = 0, l = this._atlases.length; i < l; i++) {\r\n            this._atlases[i].destroy();\r\n        }\r\n        this._atlases.length = 0;\r\n        this._atlasIndex = -1;\r\n    }\r\n\r\n    /**\r\n     * @en\r\n     * Delete a sprite from the atlas.\r\n     *\r\n     * @zh\r\n     * 从动态图集中删除某张碎图。\r\n     *\r\n     * @method deleteAtlasSpriteFrame\r\n     * @param spriteFrame  the sprite frame that will be removed from the atlas.\r\n     */\r\n    public deleteAtlasSpriteFrame (spriteFrame: SpriteFrame): void {\r\n        if (!spriteFrame.original) return;\r\n\r\n        let atlas: Atlas;\r\n        for (let i = this._atlases.length - 1; i >= 0; i--) {\r\n            atlas = this._atlases[i];\r\n            atlas.removeSpriteFrame(spriteFrame);\r\n        }\r\n        const texture = spriteFrame.original._texture;\r\n        this.deleteAtlasTexture(texture);\r\n    }\r\n\r\n    /**\r\n     * @en\r\n     * Delete a texture from the atlas.\r\n     *\r\n     * @zh\r\n     * 从动态图集中删除某张纹理。\r\n     *\r\n     * @method deleteAtlasTexture\r\n     * @param texture  the texture that will be removed from the atlas.\r\n     */\r\n    public deleteAtlasTexture (texture: TextureBase): void {\r\n        if (texture) {\r\n            for (let i = this._atlases.length - 1; i >= 0; i--) {\r\n                this._atlases[i].deleteInnerTexture(texture as Texture2D);\r\n\r\n                if (this._atlases[i].isEmpty()) {\r\n                    this._atlases[i].destroy();\r\n                    this._atlases.splice(i, 1);\r\n                    this._atlasIndex--;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @en\r\n     * Pack the sprite in the dynamic atlas and update the atlas information of the sprite frame.\r\n     *\r\n     * @zh\r\n     * 将图片打入动态图集，并更新该图片的图集信息。\r\n     *\r\n     * @method packToDynamicAtlas\r\n     * @param frame  the sprite frame that will be packed in the dynamic atlas.\r\n     */\r\n    public packToDynamicAtlas (comp, frame: SpriteFrame | null): void {\r\n        if (EDITOR_NOT_IN_PREVIEW || !this._enabled) return;\r\n\r\n        if (frame && !frame.original && frame.packable && frame.texture && frame.texture.width > 0 && frame.texture.height > 0) {\r\n            const packedFrame = this.insertSpriteFrame(frame);\r\n            if (packedFrame) {\r\n                frame._setDynamicAtlasFrame(packedFrame);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * @en The singleton instance of [[DynamicAtlasManager]], please use [[DynamicAtlasManager.instance]] instead.\r\n * @zh [[DynamicAtlasManager]] 的单例对象，请直接使用 [[DynamicAtlasManager.instance]]。\r\n * @deprecated since v3.7\r\n */\r\nexport const dynamicAtlasManager: DynamicAtlasManager = DynamicAtlasManager.instance = new DynamicAtlasManager();\r\n\r\ndirector.registerSystem('dynamicAtlasManager', dynamicAtlasManager, 0);\r\n\r\ncclegacy.internal.dynamicAtlasManager = dynamicAtlasManager;\r\n","/*\r\n Copyright (c) 2008-2010 Ricardo Quesada\r\n Copyright (c) 2011-2012 cocos2d-x.org\r\n Copyright (c) 2013-2016 Chukong Technologies Inc.\r\n Copyright (c) 2017-2023 Xiamen Yaji Software Co., Ltd.\r\n\r\n http://www.cocos2d-x.org\r\n\r\n Permission is hereby granted, free of charge, to any person obtaining a copy\r\n of this software and associated documentation files (the \"Software\"), to deal\r\n in the Software without restriction, including without limitation the rights to\r\n use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\r\n of the Software, and to permit persons to whom the Software is furnished to do so,\r\n subject to the following conditions:\r\n\r\n The above copyright notice and this permission notice shall be included in\r\n all copies or substantial portions of the Software.\r\n\r\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n THE SOFTWARE.\r\n*/\r\n\r\nimport { ccclass } from 'cc.decorator';\r\nimport { EDITOR, TEST, BUILD } from 'internal:constants';\r\nimport { Rect, Size, Vec2, Vec3, Vec4, cclegacy, errorID, warnID, js, v3, mat4, rect, v4, v2, size } from '../../core';\r\nimport { Asset } from '../../asset/assets/asset';\r\nimport { TextureBase } from '../../asset/assets/texture-base';\r\nimport { ImageAsset, ImageSource } from '../../asset/assets/image-asset';\r\nimport { Texture2D } from '../../asset/assets/texture-2d';\r\nimport { dynamicAtlasManager } from '../utils/dynamic-atlas/atlas-manager';\r\nimport { Mesh } from '../../3d/assets/mesh';\r\nimport { createMesh } from '../../3d/misc';\r\nimport { Attribute, AttributeName, Format, PrimitiveMode, Sampler, SamplerInfo, Texture } from '../../gfx';\r\nimport { ccwindow } from '../../core/global-exports';\r\n\r\nconst INSET_LEFT = 0;\r\nconst INSET_TOP = 1;\r\nconst INSET_RIGHT = 2;\r\nconst INSET_BOTTOM = 3;\r\nconst temp_vec3 = v3();\r\nconst temp_matrix = mat4();\r\n\r\nconst vec3TransformMat4 = Vec3.transformMat4;\r\nconst vec3ToArray = Vec3.toArray;\r\n\r\nenum MeshType {\r\n    RECT = 0,\r\n    POLYGON = 1, // Todo: Polygon mode need add\r\n}\r\n\r\n/**\r\n * @deprecated since v3.7.0, this is an engine private interface that will be removed in the future.\r\n */\r\nexport interface IUV {\r\n    u: number;\r\n    v: number;\r\n}\r\n\r\ninterface IVertices {\r\n    rawPosition: Vec3[]; // Original position of the vertex, pixel value\r\n    positions: number[]; // The position of the vertex after being affected by the attribute\r\n    indexes: number[]; // IB\r\n    uv: number[]; // Pixel uv value\r\n    nuv: number[]; // Normalized uv value\r\n    minPos: Vec3;\r\n    maxPos: Vec3;\r\n}\r\n\r\ninterface IVerticesSerialize { // hack for format\r\n    rawPosition: number[];\r\n    indexes: number[];\r\n    uv: number[];\r\n    nuv: number[];\r\n    minPos: Vec3;\r\n    maxPos: Vec3;\r\n}\r\n\r\ninterface ISpriteFramesSerializeData {\r\n    name: string;\r\n    base: string;\r\n    image: string;\r\n    atlas: string | undefined;\r\n    rect: Rect;\r\n    offset: Vec2;\r\n    originalSize: Size;\r\n    rotated: boolean;\r\n    capInsets: number[];\r\n    vertices: IVerticesSerialize;\r\n    texture: string;\r\n    packable: boolean;\r\n    pixelsToUnit: number;\r\n    pivot: Vec2;\r\n    meshType: MeshType;\r\n}\r\n\r\ninterface ISpriteFrameOriginal {\r\n    spriteframe: SpriteFrame;\r\n    x: number;\r\n    y: number;\r\n}\r\n\r\n/**\r\n * @en Information object interface for initialize a [[SpriteFrame]] asset.\r\n * @zh 用于初始化 [[SpriteFrame]] 资源的对象接口描述。\r\n */\r\nexport interface ISpriteFrameInitInfo {\r\n    /**\r\n     * @en The texture of the sprite frame, could be `TextureBase`.\r\n     * @zh 贴图对象资源，可以是 `TextureBase` 类型。\r\n     */\r\n    texture?: TextureBase;\r\n    /**\r\n     * @en The original size of the sprite frame.\r\n     * @zh 精灵帧原始尺寸。\r\n     */\r\n    originalSize?: Size;\r\n    /**\r\n     * @en The rect of the sprite frame in atlas texture.\r\n     * @zh 精灵帧裁切矩形。\r\n     */\r\n    rect?: Rect;\r\n    /**\r\n     * @en The offset of the sprite frame center from the original center of the original rect.\r\n     * Sprite frame in an atlas texture could be trimmed for clipping the transparent pixels, so the trimmed rect is smaller than the original one,\r\n     * the offset defines the distance from the original center to the trimmed center.\r\n     * @zh 精灵帧偏移量。\r\n     * 在图集中的精灵帧可能会被剔除透明像素以获得更高的空间利用李，剔除后的矩形尺寸比剪裁前更小，偏移量指的是从原始矩形的中心到剪裁后的矩形中心的距离。\r\n     */\r\n    offset?: Vec2;\r\n    /**\r\n     * @en Top side border for sliced 9 frame.\r\n     * @zh 九宫格精灵帧的上边界。\r\n     * @default 0\r\n     */\r\n    borderTop?: number;\r\n    /**\r\n     * @en Bottom side border for sliced 9 frame.\r\n     * @zh 九宫格精灵帧的下边界。\r\n     * @default 0\r\n     */\r\n    borderBottom?: number;\r\n    /**\r\n     * @en Left side border for sliced 9 frame.\r\n     * @zh 九宫格精灵帧的左边界。\r\n     * @default 0\r\n     */\r\n    borderLeft?: number;\r\n    /**\r\n     * @en Right side border for sliced 9 frame.\r\n     * @zh 九宫格精灵帧的右边界。\r\n     * @default 0\r\n     */\r\n    borderRight?: number;\r\n    /**\r\n     * @en Whether the content of sprite frame is rotated.\r\n     * @zh 是否旋转。\r\n     */\r\n    isRotate?: boolean;\r\n    /**\r\n     * @en Whether the uv is flipped.\r\n     * @zh 是否转置 UV。\r\n     */\r\n    isFlipUv?: boolean;\r\n}\r\n\r\nconst temp_uvs: IUV[] = [{ u: 0, v: 0 }, { u: 0, v: 0 }, { u: 0, v: 0 }, { u: 0, v: 0 }];\r\n\r\nexport enum SpriteFrameEvent {\r\n    UV_UPDATED = 'uv_updated',\r\n}\r\n\r\n/**\r\n * @en\r\n * A `SpriteFrame` support several types.\r\n *  1. Rectangle sprite frame\r\n *  2. Sliced 9 sprite frame\r\n *  3. Mesh sprite frame\r\n * It mainly contains:<br/>\r\n *  - texture: A `TextureBase` that will be used by render process.<br/>\r\n *  - rectangle: A rectangle of the texture.\r\n *  - Sliced 9 border insets: The distance of each side from the internal rect to the sprite frame rect.\r\n *  - vertices: Vertex list for the mesh type sprite frame.\r\n *  - uv: The quad uv.\r\n *  - uvSliced: The sliced 9 uv.\r\n *\r\n * @zh\r\n * 精灵帧资源。\r\n * 一个 SpriteFrame 支持多种类型\r\n *  1. 矩形精灵帧\r\n *  2. 九宫格精灵帧\r\n *  3. 网格精灵帧\r\n * 它主要包含下列数据：<br/>\r\n *  - 纹理：会被渲染流程使用的 `TextureBase` 资源。<br/>\r\n *  - 矩形：在纹理中的矩形区域。\r\n *  - 九宫格信息：九宫格的内部矩形四个边距离 SpriteFrame 外部矩形的距离。\r\n *  - 网格信息：网格类型精灵帧的所有顶点列表。\r\n *  - uv: 四边形 UV。\r\n *  - uvSliced: 九宫格 UV。\r\n * 可通过 `SpriteFrame` 获取该组件。\r\n *\r\n * @example\r\n * ```ts\r\n * import { resources } from 'cc';\r\n * // First way to use a SpriteFrame\r\n * const url = \"assets/PurpleMonster/icon/spriteFrame\";\r\n * resources.load(url, (err, spriteFrame) => {\r\n *   const node = new Node(\"New Sprite\");\r\n *   const sprite = node.addComponent(Sprite);\r\n *   sprite.spriteFrame = spriteFrame;\r\n *   node.parent = self.node;\r\n * });\r\n *\r\n * // Second way to use a SpriteFrame\r\n * const self = this;\r\n * const url = \"test_assets/PurpleMonster\";\r\n * resources.load(url, (err, imageAsset) => {\r\n *  if(err){\r\n *    return;\r\n *  }\r\n *\r\n *  const node = new Node(\"New Sprite\");\r\n *  const sprite = node.addComponent(Sprite);\r\n *  const spriteFrame = new SpriteFrame();\r\n *  const tex = imageAsset._texture;\r\n *  spriteFrame.texture = tex;\r\n *  sprite.spriteFrame = spriteFrame;\r\n *  node.parent = self.node;\r\n * });\r\n *\r\n * // Third way to use a SpriteFrame\r\n * const self = this;\r\n * const cameraComp = this.getComponent(Camera);\r\n * const renderTexture = new RenderTexture();\r\n * renderTexture.reset({\r\n *   width: 512,\r\n *   height: 512,\r\n *   depthStencilFormat: RenderTexture.DepthStencilFormat.DEPTH_24_STENCIL_8\r\n * });\r\n *\r\n * cameraComp.targetTexture = renderTexture;\r\n * const spriteFrame = new SpriteFrame();\r\n * spriteFrame.texture = renderTexture;\r\n * ```\r\n */\r\n@ccclass('cc.SpriteFrame')\r\nexport class SpriteFrame extends Asset {\r\n    /**\r\n     * @en Create a SpriteFrame object by an image asset or an native image asset.\r\n     * @zh 通过 Image 资源或者平台相关 Image 对象创建一个 SpriteFrame 资源。\r\n     * @param imageSourceOrImageAsset @en ImageAsset or ImageSource, ImageSource could be HTMLCanvasElement, HTMLImageElement, IMemoryImageSource.\r\n     *                                @zh 图像资源或图像原始图像源，图像原始图像源支持 HTMLCanvasElement HTMLImageElement IMemoryImageSource 三种资源。\r\n     * @returns @en SpriteFrame asset. @zh 精灵资源。\r\n     */\r\n    public static createWithImage (imageSourceOrImageAsset: ImageSource | ImageAsset): SpriteFrame {\r\n        const img = imageSourceOrImageAsset instanceof ImageAsset ? imageSourceOrImageAsset : new ImageAsset(imageSourceOrImageAsset);\r\n        const tex = new Texture2D();\r\n        tex.image = img;\r\n        const spf = new SpriteFrame();\r\n        spf.texture = tex;\r\n        return spf;\r\n    }\r\n\r\n    /**\r\n     * @en uv update event.\r\n     * @zh uv 更新事件。\r\n     */\r\n    public static EVENT_UV_UPDATED = SpriteFrameEvent.UV_UPDATED;\r\n    public static MeshType = MeshType;\r\n\r\n    /**\r\n     * @en Top border distance of sliced 9 rect.\r\n     * @zh 九宫格内部矩形顶部边框距离 SpriteFrame 矩形的距离。\r\n     */\r\n    get insetTop (): number {\r\n        return this._capInsets[INSET_TOP];\r\n    }\r\n\r\n    set insetTop (value) {\r\n        if (this._capInsets[INSET_TOP] === value) {\r\n            return;\r\n        }\r\n\r\n        this._capInsets[INSET_TOP] = value;\r\n        if (this._texture) {\r\n            this._calculateSlicedUV();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @en Bottom border distance of sliced 9 rect.\r\n     * @zh 九宫格内部矩形底部边框距离 SpriteFrame 矩形的距离。\r\n     */\r\n    get insetBottom (): number {\r\n        return this._capInsets[INSET_BOTTOM];\r\n    }\r\n\r\n    set insetBottom (value) {\r\n        if (this._capInsets[INSET_BOTTOM] === value) {\r\n            return;\r\n        }\r\n\r\n        this._capInsets[INSET_BOTTOM] = value;\r\n        if (this._texture) {\r\n            this._calculateSlicedUV();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @en Left border distance of sliced 9 rect.\r\n     * @zh 九宫格内部矩形左边框距离 SpriteFrame 矩形的距离。\r\n     */\r\n    get insetLeft (): number {\r\n        return this._capInsets[INSET_LEFT];\r\n    }\r\n\r\n    set insetLeft (value) {\r\n        if (this._capInsets[INSET_LEFT] === value) {\r\n            return;\r\n        }\r\n\r\n        this._capInsets[INSET_LEFT] = value;\r\n        if (this._texture) {\r\n            this._calculateSlicedUV();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @en Right border distance of sliced 9 rect.\r\n     * @zh 九宫格内部矩形右边框距离 SpriteFrame 矩形的距离。\r\n     */\r\n    get insetRight (): number {\r\n        return this._capInsets[INSET_RIGHT];\r\n    }\r\n\r\n    set insetRight (value) {\r\n        if (this._capInsets[INSET_RIGHT] === value) {\r\n            return;\r\n        }\r\n\r\n        this._capInsets[INSET_RIGHT] = value;\r\n        if (this._texture) {\r\n            this._calculateSlicedUV();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @en Returns the rect of the sprite frame in the texture.\r\n     * If it's an atlas texture, a transparent pixel area is proposed for the actual mapping of the current texture.\r\n     * @zh 获取 SpriteFrame 的纹理矩形区域。\r\n     * 如果是一个 atlas 的贴图，则为当前贴图的实际剔除透明像素区域。\r\n     */\r\n    get rect (): Rect {\r\n        return this._rect;\r\n    }\r\n\r\n    set rect (value) {\r\n        if (this._rect.equals(value)) {\r\n            return;\r\n        }\r\n\r\n        this._rect.set(value);\r\n        if (this._texture) {\r\n            this._calculateUV();\r\n        }\r\n        this._calcTrimmedBorder();\r\n    }\r\n\r\n    /**\r\n     * @en The original size before trimmed.\r\n     * @zh 修剪前的原始大小。\r\n     */\r\n    get originalSize (): Size {\r\n        return this._originalSize;\r\n    }\r\n\r\n    set originalSize (value) {\r\n        if (this._originalSize.equals(value)) {\r\n            return;\r\n        }\r\n\r\n        this._originalSize.set(value);\r\n        if (this._texture) {\r\n            this._calculateUV();\r\n        }\r\n        this._calcTrimmedBorder();\r\n    }\r\n\r\n    /**\r\n     * @en The offset of the sprite frame center.\r\n     * Sprite frame in an atlas texture could be trimmed for clipping the transparent pixels, so the trimmed rect is smaller than the original one,\r\n     * the offset defines the distance from the original center to the trimmed center.\r\n     * @zh 精灵帧偏移量。\r\n     * 在图集中的精灵帧可能会被剔除透明像素以获得更高的空间利用李，剔除后的矩形尺寸比剪裁前更小，偏移量指的是从原始矩形的中心到剪裁后的矩形中心的距离。\r\n     */\r\n    get offset (): Vec2 {\r\n        return this._offset;\r\n    }\r\n\r\n    set offset (value) {\r\n        this._offset.set(value);\r\n        this._calcTrimmedBorder();\r\n    }\r\n\r\n    /**\r\n     * @en Whether the content of sprite frame is rotated.\r\n     * @zh 是否旋转。\r\n     */\r\n    get rotated (): boolean {\r\n        return this._rotated;\r\n    }\r\n\r\n    set rotated (rotated) {\r\n        if (this._rotated === rotated) {\r\n            return;\r\n        }\r\n\r\n        this._rotated = rotated;\r\n        if (this._texture) {\r\n            this._calculateUV();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @en The texture of the sprite frame, could be `TextureBase`.\r\n     * @zh 贴图对象资源，可以是 `TextureBase` 类型。\r\n     */\r\n    get texture (): TextureBase {\r\n        return this._texture;\r\n    }\r\n\r\n    set texture (value) {\r\n        if (!value) {\r\n            warnID(3122, this.name);\r\n            return;\r\n        }\r\n\r\n        if (value === this._texture) {\r\n            return;\r\n        }\r\n\r\n        this.reset({ texture: value }, true);\r\n    }\r\n\r\n    /**\r\n     * @en The uuid of the atlas asset, if exists.\r\n     * @zh 图集资源的 uuid。\r\n     */\r\n    get atlasUuid (): string {\r\n        return this._atlasUuid;\r\n    }\r\n\r\n    set atlasUuid (value: string) {\r\n        this._atlasUuid = value;\r\n    }\r\n\r\n    /**\r\n     * @en The pixel width of the sprite frame.\r\n     * @zh 精灵帧的像素宽度。\r\n     */\r\n    get width (): number {\r\n        return this._texture.width;\r\n    }\r\n\r\n    /**\r\n     * @en The pixel height of the sprite frame.\r\n     * @zh 精灵帧的像素高度。\r\n     */\r\n    get height (): number {\r\n        return this._texture.height;\r\n    }\r\n\r\n    /**\r\n     * @deprecated since v3.7.0, this is an engine private interface that will be removed in the future.\r\n     */\r\n    set _textureSource (value: TextureBase) {\r\n        // Optimization for build\r\n        if (globalThis.Build) {\r\n            this._texture = value;\r\n            return;\r\n        }\r\n        if (value) {\r\n            this._refreshTexture(value);\r\n            this._calculateUV();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @en Whether flip the uv in X direction.\r\n     * @zh 沿 X 轴方向, 翻转 UV。\r\n     */\r\n    get flipUVX (): boolean {\r\n        return this._isFlipUVX;\r\n    }\r\n\r\n    set flipUVX (value) {\r\n        this._isFlipUVX = value;\r\n        this._calculateUV();\r\n    }\r\n\r\n    /**\r\n     * @en Whether flip the uv in Y direction.\r\n     * @zh 沿 Y 轴方向, 翻转 UV。\r\n     */\r\n    get flipUVY (): boolean {\r\n        return this._isFlipUVY;\r\n    }\r\n\r\n    set flipUVY (value) {\r\n        this._isFlipUVY = value;\r\n        this._calculateUV();\r\n    }\r\n\r\n    /**\r\n     * @en Sets whether sprite can be packed into dynamic atlas.\r\n     * @zh 设置精灵是否允许参与自动合图。\r\n     */\r\n    get packable (): boolean {\r\n        return this._packable;\r\n    }\r\n    set packable (value: boolean) {\r\n        this._packable = value;\r\n    }\r\n\r\n    /**\r\n     * @en Original information before packed to dynamic atlas, includes texture, width, height. It's null before being packed to dynamic atlas.\r\n     * @zh 精灵自动合图之前的原始 texture 和宽高信息。在参与自动合图之前此值为 null。\r\n     */\r\n    get original (): {\r\n        _texture: TextureBase;\r\n        _x: number;\r\n        _y: number;\r\n    } | null {\r\n        return this._original;\r\n    }\r\n\r\n    /**\r\n     * @en Number of pixels corresponding to unit size in world space (pixels per unit).\r\n     * @zh 世界空间中的单位大小对应的像素数量（像素每单位）。\r\n     */\r\n    get pixelsToUnit (): number {\r\n        return this._pixelsToUnit;\r\n    }\r\n\r\n    /**\r\n     * @en Local origin position when generating the mesh.\r\n     * @zh 生成 mesh 时本地坐标原点位置。\r\n     */\r\n    get pivot (): Vec2 {\r\n        return this._pivot;\r\n    }\r\n\r\n    /**\r\n     * @en mesh information, you should call the [[ensureMeshData]] function before using it.\r\n     * @zh mesh 信息，你应该在使用它之前调用 [[ensureMeshData]] 函数来确保其可用。\r\n     */\r\n    get mesh (): Mesh | null {\r\n        return this._mesh;\r\n    }\r\n\r\n    /**\r\n     * @deprecated since v3.7.0, this is an engine private interface that will be removed in the future.\r\n     */\r\n    get trimmedBorder (): Vec4 {\r\n        return this._trimmedBorder;\r\n    }\r\n\r\n    /**\r\n     * @en Vertex list for the mesh type sprite frame.\r\n     * @zh 网格类型精灵帧的所有顶点列表。\r\n     */\r\n    public vertices: IVertices | null = null;\r\n\r\n    /**\r\n     * @en UV for quad vertices.\r\n     * @zh 矩形的顶点 UV。\r\n     */\r\n    public uv: number[] = [];\r\n\r\n    /**\r\n     * @deprecated since v3.7.0, this is an engine private interface that will be removed in the future.\r\n     */\r\n    public unbiasUV: number[] = [];\r\n\r\n    /**\r\n     * @en UV for sliced 9 vertices.\r\n     * @zh 九宫格的顶点 UV。\r\n     */\r\n    public uvSliced: IUV[] = [];\r\n\r\n    // the location of the sprite on rendering texture\r\n    protected _rect = rect();\r\n\r\n    protected _trimmedBorder = v4();\r\n\r\n    // for trimming\r\n    protected _offset = v2();\r\n\r\n    // for trimming\r\n    protected _originalSize = size();\r\n\r\n    protected _rotated = false;\r\n\r\n    protected _capInsets = [0, 0, 0, 0];\r\n\r\n    protected _atlasUuid = '';\r\n    // TODO: not initialized in constructor\r\n    protected _texture!: TextureBase;\r\n\r\n    protected _isFlipUVY = false;\r\n\r\n    protected _isFlipUVX = false;\r\n\r\n    // store original info before packed to dynamic atlas\r\n    protected _original: {\r\n        _texture: TextureBase,\r\n        _x: number,\r\n        _y: number,\r\n    } | null = null;\r\n\r\n    protected _packable = true;\r\n\r\n    protected _pixelsToUnit = 100;\r\n\r\n    protected _pivot = v2(0.5, 0.5); // center\r\n\r\n    // Todo: Some features need add\r\n    protected _meshType = MeshType.RECT;\r\n    protected _extrude = 0; // when polygon type use\r\n    protected _customOutLine = [];// MayBe later\r\n    // Here you can generate polygons by polygon-separator, expecting the generated polygons to be pixel-standard vertex arrays,\r\n    // and save this array in the file\r\n    // that is, the mesh information of the original image\r\n    // (two-dimensional mesh information, which needs to be serialized and is the basis for the polygon mesh generation)\r\n    // In addition to the vertex array, a mesh should be generated based on the conditions\r\n    // i.e., the mesh information generated by combining the above five conditions, which needs to be serialized\r\n    // and at runtime, the actual mesh used is the generated mesh (static mesh)\r\n    // (updated after attribute value changes in the editor, adjusting vertices/re-generation)\r\n\r\n    // Mesh api\r\n    protected _mesh: Mesh | null = null;\r\n    protected _minPos = v3();\r\n    protected _maxPos = v3();\r\n\r\n    constructor (name?: string) {\r\n        super(name);\r\n\r\n        if (EDITOR) {\r\n            // Atlas asset uuid\r\n            this._atlasUuid = '';\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @en\r\n     * Returns whether the texture have been loaded.\r\n     * @zh\r\n     * 返回是否已加载精灵帧。\r\n     *\r\n     * @deprecated since v3.3, Useless Code.\r\n     */\r\n    public textureLoaded (): boolean {\r\n        return !!this.texture;\r\n    }\r\n\r\n    /**\r\n     * @en\r\n     * Returns whether the sprite frame is rotated in the texture.\r\n     * @zh\r\n     * 获取 SpriteFrame 是否旋转。\r\n     * @deprecated since v1.2, please use [[rotated]] instead.\r\n     */\r\n    public isRotated (): boolean {\r\n        return this._rotated;\r\n    }\r\n\r\n    /**\r\n     * @en\r\n     * Set whether the sprite frame is rotated in the texture.\r\n     * @zh\r\n     * 设置 SpriteFrame 是否旋转。\r\n     * @param rotated @en rotated.  @zh 是否旋转。\r\n     * @deprecated since v1.2, please use [[rotated]] instead.\r\n     */\r\n    public setRotated (rotated: boolean): void {\r\n        this.rotated = rotated;\r\n    }\r\n\r\n    /**\r\n     * @en Returns the rect of the sprite frame in the texture.\r\n     * If it's an atlas texture, a transparent pixel area is proposed for the actual mapping of the current texture.\r\n     * @zh 获取 SpriteFrame 的纹理矩形区域。\r\n     * 如果是一个 atlas 的贴图，则为当前贴图的实际剔除透明像素区域。\r\n     * @param out @en The output rect. @zh 输出的矩形区域。\r\n     * @returns @en The rect. @zh 矩形区域。\r\n     * @deprecated since v1.2, please use [[rect]].\r\n     */\r\n    public getRect (out?: Rect): Rect {\r\n        if (out) {\r\n            out.set(this._rect);\r\n            return out;\r\n        }\r\n\r\n        return this._rect.clone();\r\n    }\r\n\r\n    /**\r\n     * @en Sets the rect of the sprite frame in the texture.\r\n     * @zh 设置 SpriteFrame 的纹理矩形区域。\r\n     * @param rect @en The new rect. @zh 想要设置的 rect。\r\n     * @deprecated since v1.2, please use [[rect]].\r\n     */\r\n    public setRect (rect: Rect): void {\r\n        this.rect = rect;\r\n    }\r\n\r\n    /**\r\n     * @en Returns the original size before trimmed.\r\n     * @zh 获取修剪前的原始大小。\r\n     * @param out @en The output original size. @zh 输出的原始大小。\r\n     * @returns @en The original size. @zh 原始大小。\r\n     * @deprecated since v1.2, please use [[originalSize]].\r\n     */\r\n    public getOriginalSize (out?: Size): Size {\r\n        if (out) {\r\n            out.set(this._originalSize);\r\n            return out;\r\n        }\r\n\r\n        return this._originalSize.clone();\r\n    }\r\n\r\n    /**\r\n     * @en Sets the original size before trimmed.\r\n     * @zh 设置修剪前的原始大小。\r\n     * @param size @en The new original size. @zh 新设置的原始大小。\r\n     * @deprecated since v1.2, please use [[originalSize]].\r\n     */\r\n    public setOriginalSize (size: Size): void {\r\n        this.originalSize = size;\r\n    }\r\n\r\n    /**\r\n     * @en Gets the offset of the frame.\r\n     * @zh 获取偏移量。\r\n     * @param out @en The output offset object. @zh 输出的偏移量。\r\n     * @returns @en The offset object. @zh 偏移量。\r\n     * @deprecated since v1.2, please use [[offset]]\r\n     */\r\n    public getOffset (out?: Vec2): Vec2 {\r\n        if (out) {\r\n            out.set(this._offset);\r\n            return out;\r\n        }\r\n\r\n        return this._offset.clone();\r\n    }\r\n\r\n    /**\r\n     * @en Sets the offset of the frame.\r\n     * @zh 设置偏移量。\r\n     * @param offset @en The new offset. @zh 新设置的偏移量。\r\n     * @deprecated since v1.2, please use [[offset]]\r\n     */\r\n    public setOffset (offset: Vec2): void {\r\n        this.offset = offset;\r\n    }\r\n\r\n    /**\r\n     * @en Gets the related GFX [[gfx.Texture]] resource.\r\n     * @zh 获取渲染贴图的 GFX 资源。\r\n     * @returns @en Gfx Texture resource. @zh GFX 贴图资源。\r\n     */\r\n    public getGFXTexture (): Texture | null {\r\n        return this._texture.getGFXTexture();\r\n    }\r\n\r\n    /**\r\n     * @en Gets the GFX sampler of its texture.\r\n     * @zh 贴图资源的采样器。\r\n     * @returns @en The GFX sampler resource. @zh GFX贴图采样器。\r\n     */\r\n    public getGFXSampler (): Sampler {\r\n        return this._texture.getGFXSampler();\r\n    }\r\n\r\n    /**\r\n     * @en Gets the hash of its texture.\r\n     * @zh 贴图资源的哈希值。\r\n     * @returns @en Texture`s hash. @zh 贴图哈希值。\r\n     */\r\n    public getHash (): number {\r\n        return this._texture.getHash();\r\n    }\r\n\r\n    /**\r\n     * @en Gets the sampler hash of its texture.\r\n     * @zh 贴图资源的采样器哈希值。\r\n     * @returns @en Sampler`s hash. @zh 采样器哈希值。\r\n     */\r\n    public getSamplerInfo (): Readonly<SamplerInfo> {\r\n        return this._texture.getSamplerInfo();\r\n    }\r\n\r\n    /**\r\n     * @en Resets the sprite frame data.\r\n     * @zh 重置 SpriteFrame 数据。\r\n     * @param info @en SpriteFrame initialization information. @zh SpriteFrame 初始化信息。\r\n     * @param clearData @en Clear Data before initialization. @zh 是否在初始化前清空原有数据。\r\n     */\r\n    public reset (info?: ISpriteFrameInitInfo, clearData = false): void {\r\n        const self = this;\r\n        let calUV = false;\r\n        if (clearData) {\r\n            self._originalSize.set(0, 0);\r\n            self._rect.set(0, 0, 0, 0);\r\n            self._offset.set(0, 0);\r\n            self._capInsets = [0, 0, 0, 0];\r\n            self._rotated = false;\r\n            calUV = true;\r\n        }\r\n\r\n        if (info) {\r\n            if (info.texture) {\r\n                self._rect.set(0, 0, info.texture.width, info.texture.height);\r\n                self._refreshTexture(info.texture);\r\n                self.checkRect(self._texture);\r\n            }\r\n\r\n            if (info.originalSize) {\r\n                self._originalSize.set(info.originalSize);\r\n            }\r\n\r\n            if (info.rect) {\r\n                self._rect.set(info.rect);\r\n            }\r\n\r\n            if (info.offset) {\r\n                self._offset.set(info.offset);\r\n            }\r\n\r\n            const thisCapInsets = self._capInsets;\r\n            if (info.borderTop !== undefined) {\r\n                thisCapInsets[INSET_TOP] = info.borderTop;\r\n            }\r\n\r\n            if (info.borderBottom !== undefined) {\r\n                thisCapInsets[INSET_BOTTOM] = info.borderBottom;\r\n            }\r\n\r\n            if (info.borderLeft !== undefined) {\r\n                thisCapInsets[INSET_LEFT] = info.borderLeft;\r\n            }\r\n\r\n            if (info.borderRight !== undefined) {\r\n                thisCapInsets[INSET_RIGHT] = info.borderRight;\r\n            }\r\n\r\n            if (info.isRotate !== undefined) {\r\n                self._rotated = !!info.isRotate;\r\n            }\r\n\r\n            if (info.isFlipUv !== undefined) {\r\n                self._isFlipUVY = !!info.isFlipUv;\r\n            }\r\n\r\n            calUV = true;\r\n        }\r\n\r\n        if (calUV && self.texture) {\r\n            self._calculateUV();\r\n        }\r\n        self._calcTrimmedBorder();\r\n    }\r\n\r\n    /**\r\n     * @en Check whether the rect of the sprite frame is out of the texture boundary.\r\n     * @zh 判断精灵计算的矩形区域是否越界。\r\n     * @param texture @en Texture resources for sprite frame. @zh SpriteFrame 的贴图资源。\r\n     * @returns @en Out of the texture boundary or not. @zh 矩形区域是否越界。\r\n     */\r\n    public checkRect (texture: TextureBase): boolean {\r\n        const rect = this._rect;\r\n        let maxX = rect.x;\r\n        let maxY = rect.y;\r\n        if (this._rotated) {\r\n            maxX += rect.height;\r\n            maxY += rect.width;\r\n        } else {\r\n            maxX += rect.width;\r\n            maxY += rect.height;\r\n        }\r\n\r\n        if (maxX > texture.width) {\r\n            errorID(3300, `${this.name}/${texture.name}`, maxX, texture.width);\r\n            return false;\r\n        }\r\n\r\n        if (maxY > texture.height) {\r\n            errorID(3301, `${this.name}/${texture.name}`, maxY, texture.height);\r\n            return false;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    private _calcTrimmedBorder (): void {\r\n        const self = this;\r\n        const ow = self._originalSize.width;\r\n        const oh = self._originalSize.height;\r\n        const rw = self._rect.width;\r\n        const rh = self._rect.height;\r\n        const halfTrimmedWidth = (ow - rw) * 0.5;\r\n        const halfTrimmedHeight = (oh - rh) * 0.5;\r\n        const thisOffset = self._offset;\r\n        const thisTrimmedBorder = self._trimmedBorder;\r\n        // left\r\n        thisTrimmedBorder.x = thisOffset.x + halfTrimmedWidth;\r\n        // right\r\n        thisTrimmedBorder.y = thisOffset.x - halfTrimmedWidth;\r\n        // bottom\r\n        thisTrimmedBorder.z = thisOffset.y + halfTrimmedHeight;\r\n        // top\r\n        thisTrimmedBorder.w = thisOffset.y - halfTrimmedHeight;\r\n    }\r\n\r\n    /**\r\n     * @en Make sure the mesh is available, you should call it before using the mesh.\r\n     * @zh 确保 mesh 可用，你应该在使用 mesh 之前调用它。\r\n     */\r\n    public ensureMeshData (): void {\r\n        if (this._mesh) return;\r\n        // If SpriteFrame from load, we need init vertices when use mesh\r\n        this._initVertices();\r\n        this._createMesh();\r\n    }\r\n\r\n    public destroy (): boolean {\r\n        if (this._packable && dynamicAtlasManager) {\r\n            dynamicAtlasManager.deleteAtlasSpriteFrame(this);\r\n        }\r\n        return super.destroy();\r\n    }\r\n\r\n    /**\r\n     * Calculate UV for sliced\r\n     * @deprecated since v3.5.0, this is an engine private interface that will be removed in the future.\r\n     * @engineInternal\r\n     * @mangle\r\n     */\r\n    public _calculateSlicedUV (): void {\r\n        const self = this;\r\n        const rect = self._rect;\r\n        // const texture = self._getCalculateTarget()!;\r\n        const tex = self.texture;\r\n        const capInsets = self._capInsets;\r\n        const atlasWidth = tex.width;\r\n        const atlasHeight = tex.height;\r\n        const leftWidth = capInsets[INSET_LEFT];\r\n        const rightWidth = capInsets[INSET_RIGHT];\r\n        const centerWidth = rect.width - leftWidth - rightWidth;\r\n        const topHeight = capInsets[INSET_TOP];\r\n        const bottomHeight = capInsets[INSET_BOTTOM];\r\n        const centerHeight = rect.height - topHeight - bottomHeight;\r\n\r\n        const uvSliced = self.uvSliced;\r\n        uvSliced.length = 0;\r\n        if (self._rotated) {\r\n            temp_uvs[0].u = rect.x / atlasWidth;\r\n            temp_uvs[1].u = (rect.x + bottomHeight) / atlasWidth;\r\n            temp_uvs[2].u = (rect.x + bottomHeight + centerHeight) / atlasWidth;\r\n            temp_uvs[3].u = (rect.x + rect.height) / atlasWidth;\r\n            temp_uvs[3].v = rect.y / atlasHeight;\r\n            temp_uvs[2].v = (rect.y + leftWidth) / atlasHeight;\r\n            temp_uvs[1].v = (rect.y + leftWidth + centerWidth) / atlasHeight;\r\n            temp_uvs[0].v = (rect.y + rect.width) / atlasHeight;\r\n\r\n            for (let row = 0; row < 4; ++row) {\r\n                const rowD = temp_uvs[row];\r\n                for (let col = 0; col < 4; ++col) {\r\n                    const colD = temp_uvs[3 - col];\r\n                    uvSliced.push({\r\n                        u: rowD.u,\r\n                        v: colD.v,\r\n                    });\r\n                }\r\n            }\r\n        } else {\r\n            temp_uvs[0].u = rect.x / atlasWidth;\r\n            temp_uvs[1].u = (rect.x + leftWidth) / atlasWidth;\r\n            temp_uvs[2].u = (rect.x + leftWidth + centerWidth) / atlasWidth;\r\n            temp_uvs[3].u = (rect.x + rect.width) / atlasWidth;\r\n            temp_uvs[3].v = rect.y / atlasHeight;\r\n            temp_uvs[2].v = (rect.y + topHeight) / atlasHeight;\r\n            temp_uvs[1].v = (rect.y + topHeight + centerHeight) / atlasHeight;\r\n            temp_uvs[0].v = (rect.y + rect.height) / atlasHeight;\r\n\r\n            for (let row = 0; row < 4; ++row) {\r\n                const rowD = temp_uvs[row];\r\n                for (let col = 0; col < 4; ++col) {\r\n                    const colD = temp_uvs[col];\r\n                    uvSliced.push({\r\n                        u: colD.u,\r\n                        v: rowD.v,\r\n                    });\r\n                }\r\n            }\r\n        }\r\n\r\n        // UV update event for components to update uv buffer\r\n        // CalculateUV will trigger _calculateSlicedUV so it's enough to emit here\r\n        this.emit(SpriteFrameEvent.UV_UPDATED, this);\r\n    }\r\n\r\n    /**\r\n     * Calculate UV\r\n     * @deprecated since v3.5.0, this is an engine private interface that will be removed in the future.\r\n     * @engineInternal\r\n     * @mangle\r\n     */\r\n    public _calculateUV (): void {\r\n        const arrayFill = js.array.fillItems;\r\n        const self = this;\r\n        const rect = self._rect;\r\n        const uv = self.uv;\r\n        const unbiasUV = self.unbiasUV;\r\n        const tex = self.texture;\r\n        const texw = tex.width;\r\n        const texh = tex.height;\r\n\r\n        if (self._rotated) {\r\n            const l = texw === 0 ? 0 : rect.x / texw;\r\n            const r = texw === 0 ? 1 : (rect.x + rect.height) / texw;\r\n            const t = texh === 0 ? 0 : rect.y / texh;\r\n            const b = texh === 0 ? 1 : (rect.y + rect.width) / texh;\r\n\r\n            if (self._isFlipUVX && self._isFlipUVY) {\r\n                /*\r\n                3 - 1\r\n                |   |\r\n                2 - 0\r\n                */\r\n                arrayFill(uv, r, b, r, t, l, b, l, t);\r\n            } else if (self._isFlipUVX) {\r\n                /*\r\n                2 - 0\r\n                |   |\r\n                3 - 1\r\n                */\r\n                arrayFill(uv, r, t, r, b, l, t, l, b);\r\n            } else if (self._isFlipUVY) {\r\n                /*\r\n                1 - 3\r\n                |   |\r\n                0 - 2\r\n                */\r\n                arrayFill(uv, l, b, l, t, r, b, r, t);\r\n            } else {\r\n                /*\r\n                0 - 2\r\n                |   |\r\n                1 - 3\r\n                */\r\n                arrayFill(uv, l, t, l, b, r, t, r, b);\r\n            }\r\n\r\n            const ul = texw === 0 ? 0 : rect.x / texw;\r\n            const ur = texw === 0 ? 1 : (rect.x + rect.height) / texw;\r\n            const ut = texh === 0 ? 0 : rect.y / texh;\r\n            const ub = texh === 0 ? 1 : (rect.y + rect.width) / texh;\r\n            if (self._isFlipUVX && self._isFlipUVY) {\r\n                arrayFill(unbiasUV, ur, ub, ur, ut, ul, ub, ul, ut);\r\n            } else if (self._isFlipUVX) {\r\n                arrayFill(unbiasUV, ur, ut, ur, ub, ul, ut, ul, ub);\r\n            } else if (self._isFlipUVY) {\r\n                arrayFill(unbiasUV, ul, ub, ul, ut, ur, ub, ur, ut);\r\n            } else {\r\n                arrayFill(unbiasUV, ul, ut, ul, ub, ur, ut, ur, ub);\r\n            }\r\n        } else {\r\n            const l = texw === 0 ? 0 : rect.x / texw;\r\n            const r = texw === 0 ? 1 : (rect.x + rect.width) / texw;\r\n            const b = texh === 0 ? 1 : (rect.y + rect.height) / texh;\r\n            const t = texh === 0 ? 0 : rect.y / texh;\r\n            if (self._isFlipUVX && self._isFlipUVY) {\r\n                /*\r\n                1 - 0\r\n                |   |\r\n                3 - 2\r\n                */\r\n                arrayFill(uv, r, t, l, t, r, b, l, b);\r\n            } else if (self._isFlipUVX) {\r\n                /*\r\n                3 - 2\r\n                |   |\r\n                1 - 0\r\n                */\r\n                arrayFill(uv, r, b, l, b, r, t, l, t);\r\n            } else if (self._isFlipUVY) {\r\n                /*\r\n                0 - 1\r\n                |   |\r\n                2 - 3\r\n                */\r\n                arrayFill(uv, l, t, r, t, l, b, r, b);\r\n            } else {\r\n                /*\r\n                2 - 3\r\n                |   |\r\n                0 - 1\r\n                */\r\n                arrayFill(uv, l, b, r, b, l, t, r, t);\r\n            }\r\n            const ul = texw === 0 ? 0 : rect.x / texw;\r\n            const ur = texw === 0 ? 1 : (rect.x + rect.width) / texw;\r\n            const ub = texh === 0 ? 1 : (rect.y + rect.height) / texh;\r\n            const ut = texh === 0 ? 0 : rect.y / texh;\r\n            if (self._isFlipUVX && self._isFlipUVY) {\r\n                arrayFill(unbiasUV, ur, ut, ul, ut, ur, ub, ul, ub);\r\n            } else if (self._isFlipUVX) {\r\n                arrayFill(unbiasUV, ur, ub, ul, ub, ur, ut, ul, ut);\r\n            } else if (self._isFlipUVY) {\r\n                arrayFill(unbiasUV, ul, ut, ur, ut, ul, ub, ur, ub);\r\n            } else {\r\n                arrayFill(unbiasUV, ul, ub, ur, ub, ul, ut, ur, ut);\r\n            }\r\n        }\r\n\r\n        self._calculateSlicedUV();\r\n    }\r\n\r\n    /**\r\n     * @deprecated since v3.5.0, this is an engine private interface that will be removed in the future.\r\n     * @engineInternal\r\n     * @mangle\r\n     */\r\n    public _setDynamicAtlasFrame (frame): void {\r\n        if (!frame) return;\r\n\r\n        this._original = {\r\n            _texture: this._texture,\r\n            _x: this._rect.x,\r\n            _y: this._rect.y,\r\n        };\r\n\r\n        this._texture = frame.texture;\r\n        this._rect.x = frame.x;\r\n        this._rect.y = frame.y;\r\n        this._calculateUV();\r\n    }\r\n\r\n    /**\r\n     * @deprecated since v3.5.0, this is an engine private interface that will be removed in the future.\r\n     * @engineInternal\r\n     * @mangle\r\n     */\r\n    public _resetDynamicAtlasFrame (): void {\r\n        if (!this._original) return;\r\n        this._rect.x = this._original._x;\r\n        this._rect.y = this._original._y;\r\n        this._texture = this._original._texture;\r\n        this._original = null;\r\n        this._calculateUV();\r\n    }\r\n\r\n    /**\r\n     * @deprecated since v3.5.0, this is an engine private interface that will be removed in the future.\r\n     * @engineInternal\r\n     * @mangle\r\n     */\r\n    public _checkPackable (): void {\r\n        const dynamicAtlas = dynamicAtlasManager;\r\n        if (!dynamicAtlas) return;\r\n        const texture = this._texture;\r\n\r\n        if (!(texture instanceof Texture2D) || texture.isCompressed) {\r\n            this._packable = false;\r\n            return;\r\n        }\r\n\r\n        const w = this.width;\r\n        const h = this.height;\r\n        if (!texture.image\r\n            || w > dynamicAtlas.maxFrameSize || h > dynamicAtlas.maxFrameSize) {\r\n            this._packable = false;\r\n            return;\r\n        }\r\n        const CanvasElement = ccwindow.HTMLCanvasElement;\r\n\r\n        if (texture.image && texture.image instanceof CanvasElement) {\r\n            this._packable = true;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @deprecated since v3.5.0, this is an engine private interface that will be removed in the future.\r\n     */\r\n    public _serialize (ctxForExporting: any): any {\r\n        if (EDITOR || TEST) {\r\n            const rect = { x: this._rect.x, y: this._rect.y, width: this._rect.width, height: this._rect.height };\r\n            const offset = { x: this._offset.x, y: this._offset.y };\r\n            const originalSize = this._originalSize;\r\n            let texture;\r\n            if (this._texture) {\r\n                texture = this._texture._uuid;\r\n                if (ctxForExporting) {\r\n                    ctxForExporting.dependsOn('_textureSource', texture);\r\n                }\r\n            }\r\n\r\n            let vertices;\r\n            if (this.vertices) {\r\n                const posArray = [];\r\n                for (let i = 0; i < this.vertices.rawPosition.length; i++) {\r\n                    const pos = this.vertices.rawPosition[i];\r\n                    vec3ToArray(posArray, pos, 3 * i);\r\n                }\r\n                vertices = {\r\n                    rawPosition: posArray,\r\n                    indexes: this.vertices.indexes,\r\n                    uv: this.vertices.uv,\r\n                    nuv: this.vertices.nuv,\r\n                    minPos: { x: this.vertices.minPos.x, y: this.vertices.minPos.y, z: this.vertices.minPos.z },\r\n                    maxPos: { x: this.vertices.maxPos.x, y: this.vertices.maxPos.y, z: this.vertices.maxPos.z },\r\n                };\r\n            }\r\n\r\n            const serialize = {\r\n                name: this._name,\r\n                atlas: ctxForExporting ? undefined : this._atlasUuid,  // strip from json if exporting\r\n                rect,\r\n                offset,\r\n                originalSize,\r\n                rotated: this._rotated,\r\n                capInsets: this._capInsets,\r\n                vertices,\r\n                texture: (!ctxForExporting && texture) || undefined,\r\n                packable: this._packable,\r\n                pixelsToUnit: this._pixelsToUnit,\r\n                pivot: this._pivot,\r\n                meshType: this._meshType,\r\n            };\r\n\r\n            // 为 underfined 的数据则不在序列化文件里显示\r\n            return serialize;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * @deprecated since v3.5.0, this is an engine private interface that will be removed in the future.\r\n     */\r\n    public _deserialize (serializeData: any, handle: any): void {\r\n        const self = this;\r\n        const data = serializeData as ISpriteFramesSerializeData;\r\n        const rect = data.rect;\r\n        if (rect) {\r\n            self._rect = new Rect(rect.x, rect.y, rect.width, rect.height);\r\n        }\r\n\r\n        const offset = data.offset;\r\n        if (data.offset) {\r\n            self._offset = v2(offset.x, offset.y);\r\n        }\r\n\r\n        const originalSize = data.originalSize;\r\n        if (data.originalSize) {\r\n            self._originalSize = size(originalSize.width, originalSize.height);\r\n        }\r\n        self._rotated = !!data.rotated;\r\n        self._name = data.name;\r\n        self._packable = !!data.packable;\r\n\r\n        self._pixelsToUnit = data.pixelsToUnit;\r\n        const pivot = data.pivot;\r\n        if (pivot) {\r\n            self._pivot = v2(pivot.x, pivot.y);\r\n        }\r\n        self._meshType = data.meshType;\r\n\r\n        const capInsets = data.capInsets;\r\n        if (capInsets) {\r\n            const thisCapInsets = self._capInsets;\r\n            thisCapInsets[INSET_LEFT] = capInsets[INSET_LEFT];\r\n            thisCapInsets[INSET_TOP] = capInsets[INSET_TOP];\r\n            thisCapInsets[INSET_RIGHT] = capInsets[INSET_RIGHT];\r\n            thisCapInsets[INSET_BOTTOM] = capInsets[INSET_BOTTOM];\r\n        }\r\n\r\n        if (!BUILD) {\r\n            // manually load texture via _textureSetter\r\n            if (data.texture) {\r\n                handle.result.push(self, '_textureSource', data.texture, js.getClassId(Texture2D));\r\n            }\r\n        }\r\n\r\n        if (EDITOR) {\r\n            self._atlasUuid = data.atlas ? data.atlas : '';\r\n        }\r\n\r\n        const vertices = data.vertices;\r\n        if (vertices) {\r\n            if (!self.vertices) {\r\n                self.vertices = {\r\n                    rawPosition: [],\r\n                    positions: [],\r\n                    indexes: vertices.indexes,\r\n                    uv: vertices.uv,\r\n                    nuv: vertices.nuv,\r\n                    minPos: v3(vertices.minPos.x, vertices.minPos.y, vertices.minPos.z),\r\n                    maxPos: v3(vertices.maxPos.x, vertices.maxPos.y, vertices.maxPos.z),\r\n                };\r\n            }\r\n            self.vertices.rawPosition.length = 0;\r\n            const rawPosition = vertices.rawPosition;\r\n            for (let i = 0; i < rawPosition.length; i += 3) {\r\n                self.vertices.rawPosition.push(v3(rawPosition[i], rawPosition[i + 1], rawPosition[i + 2]));\r\n            }\r\n            self._updateMeshVertices();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @en clone a sprite frame.\r\n     * @zh 克隆当前 sprite frame。\r\n     */\r\n    public clone (): SpriteFrame {\r\n        const self = this;\r\n        const sp = new SpriteFrame();\r\n        const v = self.vertices;\r\n        sp.vertices = v ? {\r\n            rawPosition: v.rawPosition.slice(0),\r\n            positions: v.positions.slice(0),\r\n            indexes: v.indexes.slice(0),\r\n            uv: v.uv.slice(0),\r\n            nuv: v.nuv.slice(0),\r\n            minPos: v.minPos.clone(),\r\n            maxPos: v.maxPos.clone(),\r\n        } : null as any;\r\n        sp.uv.splice(0, sp.uv.length, ...self.uv);\r\n        sp.unbiasUV.splice(0, sp.unbiasUV.length, ...self.unbiasUV);\r\n        sp.uvSliced.splice(0, sp.uvSliced.length, ...self.uvSliced);\r\n        sp._rect.set(self._rect);\r\n        sp._trimmedBorder.set(self._trimmedBorder);\r\n        sp._offset.set(self._offset);\r\n        sp._originalSize.set(self._originalSize);\r\n        sp._rotated = self._rotated;\r\n        sp._capInsets.splice(0, sp._capInsets.length, ...self._capInsets);\r\n        sp._atlasUuid = self._atlasUuid;\r\n        sp._texture = self._texture;\r\n        sp._isFlipUVX = self._isFlipUVX;\r\n        sp._isFlipUVY = self._isFlipUVY;\r\n        if (self._original) {\r\n            sp._original = {\r\n                _texture: self._original._texture,\r\n                _x: self._original._x,\r\n                _y: self._original._y,\r\n            };\r\n        } else {\r\n            sp._original = null;\r\n        }\r\n        sp._packable = self._packable;\r\n        sp._pixelsToUnit = self._pixelsToUnit;\r\n        sp._pivot.set(self._pivot);\r\n        sp._meshType = self._meshType;\r\n        sp._extrude = self._extrude;\r\n        sp._customOutLine.splice(0, sp._customOutLine.length, ...self._customOutLine);\r\n        sp._minPos = self._minPos;\r\n        sp._maxPos = self._maxPos;\r\n        if (self._mesh) {\r\n            // Creates a new mesh, and 'this' creates the mesh in the same way. So we can make a copy like this.\r\n            // It must be placed last because the mesh will depend on some of its members when it is created.\r\n            sp._createMesh();\r\n        }\r\n        return sp;\r\n    }\r\n\r\n    protected _refreshTexture (texture: TextureBase): void {\r\n        const self = this;\r\n        self._texture = texture;\r\n        const tex = self._texture;\r\n        const config: ISpriteFrameInitInfo = {};\r\n        let isReset = false;\r\n        if (self._rect.width === 0 || self._rect.height === 0 || !self.checkRect(tex)) {\r\n            config.rect = rect(0, 0, tex.width, tex.height);\r\n            isReset = true;\r\n        }\r\n\r\n        // If original size is not set or rect check failed, we should reset the original size\r\n        if (self._originalSize.width === 0\r\n            || self._originalSize.height === 0\r\n            || isReset\r\n        ) {\r\n            config.originalSize = size(tex.width, tex.height);\r\n            isReset = true;\r\n        }\r\n\r\n        if (isReset) {\r\n            self.reset(config);\r\n        }\r\n\r\n        self._checkPackable();\r\n        if (self._mesh) {\r\n            self._updateMesh();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @en complete loading callback.\r\n     * @zh 加载完成回调。\r\n     * @deprecated since v3.7.0, this is an engine private interface that will be removed in the future.\r\n     */\r\n    public onLoaded (): void {\r\n        this._calcTrimmedBorder();\r\n    }\r\n\r\n    /**\r\n     * @en default init.\r\n     * @zh 默认初始化。\r\n     * @param uuid @en Asset uuid. @zh 资源 uuid。\r\n     * @deprecated since v3.7.0, this is an engine private interface that will be removed in the future.\r\n     */\r\n    public initDefault (uuid?: string): void {\r\n        super.initDefault(uuid);\r\n        const texture = new Texture2D();\r\n        texture.initDefault();\r\n        this._refreshTexture(texture);\r\n        this._calculateUV();\r\n    }\r\n\r\n    /**\r\n     * @en Check whether the sprite frame is validate.\r\n     * @zh 检查当前 sprite frame 对象是否是有效的。\r\n     * @returns @en validate or not. @zh 是否有效。\r\n     * @deprecated since v3.7.0, this is an engine private interface that will be removed in the future.\r\n     */\r\n    public validate (): boolean {\r\n        return this._texture && this._rect && this._rect.width !== 0 && this._rect.height !== 0;\r\n    }\r\n\r\n    protected _initVertices (): void {\r\n        const self = this;\r\n        if (!self.vertices) {\r\n            self.vertices = {\r\n                rawPosition: [],\r\n                positions: [],\r\n                indexes: [],\r\n                uv: [],\r\n                nuv: [],\r\n                minPos: v3(),\r\n                maxPos: v3(),\r\n            };\r\n        } else {\r\n            const vertices = self.vertices;\r\n            vertices.rawPosition.length = 0;\r\n            vertices.positions.length = 0;\r\n            vertices.indexes.length = 0;\r\n            vertices.uv.length = 0;\r\n            vertices.nuv.length = 0;\r\n            vertices.minPos.set(0, 0, 0);\r\n            vertices.maxPos.set(0, 0, 0);\r\n        }\r\n\r\n        const thisVertices = self.vertices;\r\n\r\n        if (self._meshType === MeshType.POLYGON) {\r\n            // Use Bayazit to generate vertices and assign values\r\n        } else { // Rect mode\r\n            // default center is 0.5，0.5\r\n            const tex = self.texture;\r\n            const texw = tex.width;\r\n            const texh = tex.height;\r\n            const rect = self.rect;\r\n            const width = rect.width;\r\n            const height = rect.height;\r\n            const rectX = rect.x;\r\n            const rectY = texh - rect.y - height;\r\n            const halfWidth = width / 2;\r\n            const halfHeight = height / 2;\r\n\r\n            const l = texw === 0 ? 0 : rectX / texw;\r\n            const r = texw === 0 ? 1 : (rectX + width) / texw;\r\n            const t = texh === 0 ? 1 : (rectY + height) / texh;\r\n            const b = texh === 0 ? 0 : rectY / texh;\r\n\r\n            const uv = thisVertices.uv;\r\n            const nuv = thisVertices.nuv;\r\n            const rawPosition = thisVertices.rawPosition;\r\n            const indexes = thisVertices.indexes;\r\n\r\n            // left bottom\r\n            temp_vec3.set(-halfWidth, -halfHeight, 0);\r\n            rawPosition.push(temp_vec3.clone());\r\n            uv.push(rectX, rectY + height);\r\n            nuv.push(l, b);\r\n            thisVertices.minPos.set(temp_vec3);\r\n            // right bottom\r\n            temp_vec3.set(halfWidth, -halfHeight, 0);\r\n            rawPosition.push(temp_vec3.clone());\r\n            uv.push(rectX + width, rectY + height);\r\n            nuv.push(r, b);\r\n            // left top\r\n            temp_vec3.set(-halfWidth, halfHeight, 0);\r\n            rawPosition.push(temp_vec3.clone());\r\n            uv.push(rectX, rectY);\r\n            nuv.push(l, t);\r\n            // right top\r\n            temp_vec3.set(halfWidth, halfHeight, 0);\r\n            rawPosition.push(temp_vec3.clone());\r\n            uv.push(rectX + width, rectY);\r\n            nuv.push(r, t);\r\n            thisVertices.maxPos.set(temp_vec3);\r\n\r\n            indexes.push(0, 1, 2, 2, 1, 3);\r\n        }\r\n        this._updateMeshVertices();\r\n    }\r\n\r\n    // Combine vertex information, unit information, anchor points, extrude and even customOutline to generate the actual vertices used\r\n    protected _updateMeshVertices (): void {\r\n        // Start generating the Geometry information to generate the mesh\r\n        temp_matrix.identity();\r\n        const units = 1 / this._pixelsToUnit;\r\n        const PosX = -(this._pivot.x - 0.5) * this.rect.width * units;\r\n        const PosY = -(this._pivot.y - 0.5) * this.rect.height * units;\r\n        const temp_vec3 = v3(PosX, PosY, 0);\r\n        temp_matrix.transform(temp_vec3);\r\n        temp_vec3.set(units, units, 1);\r\n        temp_matrix.scale(temp_vec3);\r\n        const vertices = this.vertices!;\r\n\r\n        for (let i = 0; i < vertices.rawPosition.length; i++) {\r\n            const pos = vertices.rawPosition[i];\r\n            vec3TransformMat4(temp_vec3, pos, temp_matrix);\r\n            vec3ToArray(vertices.positions, temp_vec3, 3 * i);\r\n        }\r\n        vec3TransformMat4(this._minPos, vertices.minPos, temp_matrix);\r\n        vec3TransformMat4(this._maxPos, vertices.maxPos, temp_matrix);\r\n    }\r\n\r\n    protected _createMesh (): void {\r\n        this._mesh = createMesh({\r\n            primitiveMode: PrimitiveMode.TRIANGLE_LIST,\r\n            positions: this.vertices!.positions,\r\n            uvs: this.vertices!.nuv,\r\n            indices: this.vertices!.indexes,\r\n            minPos: this._minPos,\r\n            maxPos: this._maxPos,\r\n\r\n            // colors: [\r\n            //     Color.WHITE.r, Color.WHITE.g, Color.WHITE.b, Color.WHITE.a,\r\n            //     Color.WHITE.r, Color.WHITE.g, Color.WHITE.b, Color.WHITE.a,\r\n            //     Color.WHITE.r, Color.WHITE.g, Color.WHITE.b, Color.WHITE.a,\r\n            //     Color.WHITE.r, Color.WHITE.g, Color.WHITE.b, Color.WHITE.a],\r\n            attributes: [\r\n                new Attribute(AttributeName.ATTR_POSITION, Format.RGB32F),\r\n                new Attribute(AttributeName.ATTR_TEX_COORD, Format.RG32F),\r\n                // new Attribute(AttributeName.ATTR_COLOR, Format.RGBA8UI, true),\r\n            ],\r\n        });\r\n    }\r\n\r\n    protected _updateMesh (): void {\r\n        if (this._mesh) {\r\n            this._mesh.destroy();\r\n        }\r\n        this._initVertices();\r\n        this._createMesh();\r\n    }\r\n}\r\n\r\ncclegacy.SpriteFrame = SpriteFrame;\r\n"],"names":["drawTextureAt","texture","image","x","y","Atlas","width","height","this","_innerTextureInfos","_innerSpriteFrames","_count","DynamicAtlasTexture","initWithSize","_texture","_width","_height","_x","_y","_nextY","_proto","prototype","insertSpriteFrame","spriteFrame","rect","info","getId","sx","sy","thisTexture","cclegacy","internal","dynamicAtlasManager","textureBleeding","frame","push","removeSpriteFrame","js","deleteInnerTexture","isEmpty","reset","frames","i","l","length","isValid","_resetDynamicAtlasFrame","destroy","_Texture2D","apply","arguments","_inheritsLoose","_proto2","format","PixelFormat","RGBA8888","gfxTexture","getGFXTexture","gfxDevice","_getGFXDevice","region","BufferTextureCopy","texOffset","texExtent","copyTexImagesToTexture","data","warnID","Texture2D","DynamicAtlasManager","exports","_System","_this","call","_atlases","_atlasIndex","_maxAtlasCount","_textureSize","_maxFrameSize","_textureBleeding","_enabled","newAtlas","atlas","maxAtlasCount","beforeSceneLoad","init","enabled","macro","CLEANUP_IMAGE_CACHE","original","packable","sampler","getSamplerInfo","minFilter","Filter","LINEAR","magFilter","mipFilter","NONE","deleteAtlasSpriteFrame","deleteAtlasTexture","splice","packToDynamicAtlas","comp","packedFrame","_setDynamicAtlasFrame","_createClass","key","get","set","value","director","on","DirectorEvent","BEFORE_SCENE_LAUNCH","off","enable","System","instance","registerSystem","MeshType","temp_vec3","v3","temp_matrix","mat4","vec3TransformMat4","Vec3","transformMat4","vec3ToArray","toArray","SpriteFrameEvent","temp_uvs","u","v","SpriteFrame","ccclass","_dec","_class2","_Asset","name","vertices","uv","unbiasUV","uvSliced","_rect","_trimmedBorder","v4","_offset","v2","_originalSize","size","_rotated","_capInsets","_atlasUuid","_isFlipUVY","_isFlipUVX","_original","_packable","_pixelsToUnit","_pivot","_meshType","RECT","_extrude","_customOutLine","_mesh","_minPos","_maxPos","createWithImage","imageSourceOrImageAsset","img","ImageAsset","tex","spf","textureLoaded","isRotated","setRotated","rotated","getRect","out","clone","setRect","getOriginalSize","setOriginalSize","originalSize","getOffset","setOffset","offset","getGFXSampler","getHash","clearData","self","calUV","_refreshTexture","checkRect","thisCapInsets","undefined","borderTop","borderBottom","borderLeft","borderRight","isRotate","isFlipUv","_calculateUV","_calcTrimmedBorder","maxX","maxY","errorID","ow","oh","halfTrimmedWidth","halfTrimmedHeight","thisOffset","thisTrimmedBorder","z","w","ensureMeshData","_initVertices","_createMesh","_calculateSlicedUV","capInsets","atlasWidth","atlasHeight","leftWidth","rightWidth","centerWidth","topHeight","bottomHeight","centerHeight","row","rowD","col","colD","emit","UV_UPDATED","arrayFill","texw","texh","r","t","b","ul","ur","ut","ub","_checkPackable","dynamicAtlas","isCompressed","h","maxFrameSize","CanvasElement","ccwindow","HTMLCanvasElement","_serialize","_deserialize","serializeData","Rect","_name","pixelsToUnit","pivot","meshType","rawPosition","positions","indexes","nuv","minPos","maxPos","_updateMeshVertices","_sp$uv","_sp$unbiasUV","_sp$uvSliced","_sp$_capInsets","_sp$_customOutLine","sp","slice","config","isReset","_updateMesh","onLoaded","initDefault","uuid","validate","thisVertices","POLYGON","rectX","rectY","halfWidth","halfHeight","identity","units","PosX","PosY","transform","scale","pos","createMesh","primitiveMode","PrimitiveMode","TRIANGLE_LIST","uvs","indices","attributes","Attribute","AttributeName","ATTR_POSITION","Format","RGB32F","ATTR_TEX_COORD","RG32F","equals","globalThis","Build","Asset","EVENT_UV_UPDATED","_class"],"mappings":"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"}