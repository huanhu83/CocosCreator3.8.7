{"version":3,"file":"tiled-map.js","sources":["../../../cocos/tiledmap/tiled-types.ts","../../../cocos/tiledmap/tmx-xml-parser.ts","../../../cocos/tiledmap/tiled-tile.ts","../../../cocos/tiledmap/tiled-utils.ts","../../../cocos/tiledmap/tiled-layer.ts","../../../cocos/tiledmap/assembler/simple.ts","../../../cocos/tiledmap/tiled-object-group.ts","../../../cocos/tiledmap/tiled-map-asset.ts","../../../cocos/tiledmap/tiled-map.ts","../../../cocos/tiledmap/assembler/index.ts"],"sourcesContent":["/*\r\n Copyright (c) 2020-2023 Xiamen Yaji Software Co., Ltd.\r\n\r\n https://www.cocos.com/\r\n\r\n Permission is hereby granted, free of charge, to any person obtaining a copy\r\n of this software and associated documentation files (the \"Software\"), to deal\r\n in the Software without restriction, including without limitation the rights to\r\n use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\r\n of the Software, and to permit persons to whom the Software is furnished to do so,\r\n subject to the following conditions:\r\n\r\n The above copyright notice and this permission notice shall be included in\r\n all copies or substantial portions of the Software.\r\n\r\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n THE SOFTWARE.\r\n*/\r\n\r\nimport { Color, Rect, Size, Vec2 } from '../core';\r\nimport { SpriteFrame } from '../2d/assets';\r\nimport { ccenum } from '../core/value-types/enum';\r\nimport { HorizontalTextAlignment, VerticalTextAlignment } from '../2d/components/label';\r\nimport { Texture2D } from '../asset/assets';\r\n\r\nexport interface PropertiesInfo { [key: string]: number | string }\r\nexport type TiledAnimationType = Map<GID, TiledAnimation>;\r\n\r\nexport interface TiledAnimation {\r\n    frames: { grid: TiledGrid | null, tileid: GID, duration: number }[];\r\n    dt: number;\r\n    frameIdx: number;\r\n}\r\n\r\n/**\r\n * @en The orientation of tiled map.\r\n * @zh Tiled Map 地图方向。\r\n * @enum TiledMap.Orientation\r\n * @static\r\n */\r\nexport enum Orientation {\r\n    /**\r\n     * @en Orthogonal orientation.\r\n     * @zh 直角鸟瞰地图（90°地图）。\r\n     * @property ORTHO\r\n     * @type {Number}\r\n     * @static\r\n     */\r\n    ORTHO = 0,\r\n\r\n    /**\r\n     * @en Hexagonal orientation.\r\n     * @zh 六边形地图\r\n     * @property HEX\r\n     * @type {Number}\r\n     * @static\r\n     */\r\n    HEX = 1,\r\n\r\n    /**\r\n     * Isometric orientation.\r\n     * 等距斜视地图（斜45°地图）。\r\n     * @property ISO\r\n     * @type {Number}\r\n     * @static\r\n     */\r\n    ISO = 2\r\n}\r\n\r\nccenum(Orientation);\r\n\r\n/**\r\n * The property type of tiled map.\r\n * @enum TiledMap.Property\r\n * @static\r\n */\r\nexport enum Property {\r\n    /**\r\n     * @property NONE\r\n     * @type {Number}\r\n     * @static\r\n     */\r\n    NONE = 0,\r\n\r\n    /**\r\n     * @property MAP\r\n     * @type {Number}\r\n     * @static\r\n     */\r\n    MAP = 1,\r\n\r\n    /**\r\n     * @property LAYER\r\n     * @type {Number}\r\n     * @static\r\n     */\r\n    LAYER = 2,\r\n\r\n    /**\r\n     * @property OBJECTGROUP\r\n     * @type {Number}\r\n     * @static\r\n     */\r\n    OBJECTGROUP = 3,\r\n\r\n    /**\r\n     * @property OBJECT\r\n     * @type {Number}\r\n     * @static\r\n     */\r\n    OBJECT = 4,\r\n\r\n    /**\r\n     * @property TILE\r\n     * @type {Number}\r\n     * @static\r\n     */\r\n    TILE = 5\r\n}\r\n\r\nccenum(Property);\r\n\r\n/**\r\n * The tile flags of tiled map.\r\n * @enum TiledMap.TileFlag\r\n * @static\r\n */\r\nexport enum TileFlag {\r\n    /**\r\n     * @property HORIZONTAL\r\n     * @type {Number}\r\n     * @static\r\n     */\r\n    HORIZONTAL = 0x80000000,\r\n\r\n    /**\r\n     * @property VERTICAL\r\n     * @type {Number}\r\n     * @static\r\n     */\r\n    VERTICAL = 0x40000000,\r\n\r\n    /**\r\n     * @property DIAGONAL\r\n     * @type {Number}\r\n     * @static\r\n     */\r\n    DIAGONAL = 0x20000000,\r\n\r\n    /**\r\n     * @property FLIPPED_ALL\r\n     * @type {Number}\r\n     * @static\r\n     */\r\n    FLIPPED_ALL = (0x80000000 | 0x40000000 | 0x20000000 | 0x10000000) >>> 0,\r\n\r\n    /**\r\n     * @property FLIPPED_MASK\r\n     * @type {Number}\r\n     * @static\r\n     */\r\n    FLIPPED_MASK = (~(0x80000000 | 0x40000000 | 0x20000000 | 0x10000000)) >>> 0\r\n}\r\n\r\nccenum(TileFlag);\r\n\r\n/**\r\n * @en The stagger axis of Hex tiled map.\r\n * @zh 六边形地图的 stagger axis 值\r\n * @enum TiledMap.StaggerAxis\r\n * @static\r\n */\r\nexport enum StaggerAxis {\r\n    /**\r\n     * @property STAGGERAXIS_X\r\n     * @type {Number}\r\n     * @static\r\n     */\r\n    STAGGERAXIS_X = 0,\r\n\r\n    /**\r\n     * @property STAGGERAXIS_Y\r\n     * @type {Number}\r\n     * @static\r\n     */\r\n    STAGGERAXIS_Y = 1\r\n}\r\n\r\nccenum(StaggerAxis);\r\n\r\n/**\r\n * @en The stagger index of Hex tiled map.\r\n * @zh 六边形地图的 stagger index 值\r\n * @enum TiledMap.RenderOrder\r\n * @static\r\n */\r\nexport enum StaggerIndex {\r\n    /**\r\n     * @property STAGGERINDEX_ODD\r\n     * @type {Number}\r\n     * @static\r\n     */\r\n    STAGGERINDEX_ODD = 0,\r\n\r\n    /**\r\n     * @property STAGGERINDEX_EVEN\r\n     * @type {Number}\r\n     * @static\r\n     */\r\n    STAGGERINDEX_EVEN = 1\r\n}\r\nccenum(StaggerIndex);\r\n\r\n/**\r\n * @en The render order of tiled map.\r\n * @zh 地图的渲染顺序\r\n * @enum TiledMap.RenderOrder\r\n * @static\r\n */\r\nexport enum RenderOrder {\r\n    /**\r\n     * @property RightDown\r\n     * @type {Number}\r\n     * @static\r\n     */\r\n    RightDown = 0,\r\n    /**\r\n     * @property RightUp\r\n     * @type {Number}\r\n     * @static\r\n     */\r\n    RightUp = 1,\r\n    /**\r\n     * @property LeftDown\r\n     * @type {Number}\r\n     * @static\r\n     */\r\n    LeftDown = 2,\r\n    /**\r\n     * @property LeftUp\r\n     * @type {Number}\r\n     * @static\r\n     */\r\n    LeftUp = 3,\r\n}\r\n\r\nccenum(RenderOrder);\r\n\r\n/**\r\n * @en TiledMap Object Type\r\n * @zh 地图物体类型\r\n * @enum TiledMap.TMXObjectType\r\n * @static\r\n */\r\nexport enum TMXObjectType {\r\n    /**\r\n     * @property RECT\r\n     * @type {Number}\r\n     * @static\r\n     */\r\n    RECT = 0,\r\n\r\n    /**\r\n     * @property ELLIPSE\r\n     * @type {Number}\r\n     * @static\r\n     */\r\n    ELLIPSE = 1,\r\n\r\n    /**\r\n     * @property POLYGON\r\n     * @type {Number}\r\n     * @static\r\n     */\r\n    POLYGON = 2,\r\n\r\n    /**\r\n     * @property POLYLINE\r\n     * @type {Number}\r\n     * @static\r\n     */\r\n    POLYLINE = 3,\r\n\r\n    /**\r\n     * @property IMAGE\r\n     * @type {Number}\r\n     * @static\r\n     */\r\n    IMAGE = 4,\r\n\r\n    /**\r\n     * @property TEXT\r\n     * @type {Number}\r\n     * @static\r\n     */\r\n    TEXT = 5,\r\n}\r\n\r\nccenum(TMXObjectType);\r\n\r\n// --- DEBUG types\r\n// export interface MixedGID extends Number {\r\n//     _mixed: string\r\n// }\r\n// export interface GID extends Number {\r\n//     _gid: string;\r\n// }\r\n// export interface GIDFlags extends Number {\r\n//     _flags: number;\r\n// }\r\n\r\nexport type MixedGID = number;\r\nexport type GID = number;\r\nexport type GIDFlags = number;\r\n\r\n/**\r\n * Size in pixels of the image\r\n * @property {cc.Size} imageSize\r\n */\r\n\r\n/**\r\n * <p>cc.TMXTilesetInfo contains the information about the tilesets like: <br />\r\n * - Tileset name<br />\r\n * - Tileset spacing<br />\r\n * - Tileset margin<br />\r\n * - size of the tiles<br />\r\n * - Image used for the tiles<br />\r\n * - Image size<br />\r\n *\r\n * This information is obtained from the TMX file. </p>\r\n * @class TMXTilesetInfo\r\n */\r\nexport class TMXTilesetInfo {\r\n    /**\r\n     * Tileset name\r\n     * @property {string} name\r\n     */\r\n    name = '';\r\n    /**\r\n     * First grid\r\n     * @property {number} firstGid\r\n     */\r\n    firstGid: GID = 0;\r\n\r\n    /**\r\n     * Spacing\r\n     * @property {number} spacing\r\n     */\r\n    spacing = 0;\r\n\r\n    /**\r\n     * Margin\r\n     * @property {number} margin\r\n     */\r\n\r\n    margin = 0;\r\n    /**\r\n     * Texture containing the tiles (should be sprite sheet / texture atlas)\r\n     * @property {cc.SpriteFrame} sourceImage\r\n     */\r\n    sourceImage?: SpriteFrame;\r\n    // Size in pixels of the image\r\n\r\n    imageName: string | null = null;\r\n\r\n    imageOffset: Vec2 | null = null;\r\n\r\n    imageSize = new Size(0, 0);\r\n\r\n    tileOffset = new Vec2(0, 0);\r\n\r\n    _tileSize = new Size(0, 0);\r\n\r\n    collection = false;\r\n\r\n    rectForGID (gid_: number, result?: TiledGrid): Rect | TiledGrid {\r\n        const rect = result || new Rect(0, 0, 0, 0);\r\n        rect.width = this._tileSize.width;\r\n        rect.height = this._tileSize.height;\r\n        let gid = gid_ as unknown as number;\r\n        gid &= TileFlag.FLIPPED_MASK;\r\n        gid -= (this.firstGid as unknown as number);\r\n        if (this.imageOffset) {\r\n            rect.x = this.imageOffset.x;\r\n            rect.y = this.imageOffset.y;\r\n        } else {\r\n            const max_x = Math.floor((this.imageSize.width - this.margin * 2 + this.spacing) / (this._tileSize.width + this.spacing));\r\n            rect.x = Math.round((gid % max_x) * (this._tileSize.width + this.spacing) + this.margin);\r\n            rect.y = Math.round(Math.floor(gid / max_x) * (this._tileSize.height + this.spacing) + this.margin);\r\n        }\r\n        return rect;\r\n    }\r\n}\r\n\r\n/**\r\n * <p>cc.TMXObjectGroupInfo contains the information about the object group like:\r\n * - group name\r\n * - group size\r\n * - group opacity at creation time (it can be modified at runtime)\r\n * - Whether the group is visible\r\n *\r\n * This information is obtained from the TMX file.</p>\r\n * @class TMXObjectGroupInfo\r\n */\r\n\r\nexport class TMXObjectGroupInfo {\r\n    /**\r\n     * Properties of the ObjectGroup info.\r\n     * @property {Array} properties\r\n     */\r\n    properties: PropertiesInfo = {} as any;\r\n    name = '';\r\n    objects: TMXObject[] = [];\r\n    visible = true;\r\n    opacity = 0;\r\n    color: Color = new Color(255, 255, 255, 255);\r\n    offset: Vec2 = new Vec2(0, 0);\r\n    draworder: DrawOrder = 'topdown';\r\n\r\n    tintColor: Color | null = null;\r\n    /**\r\n     * Gets the Properties.\r\n     * @return {Array}\r\n     */\r\n    getProperties (): PropertiesInfo {\r\n        return this.properties;\r\n    }\r\n\r\n    /**\r\n     * Set the Properties.\r\n     * @param {object} value\r\n     */\r\n    setProperties (value: PropertiesInfo): void {\r\n        this.properties = value;\r\n    }\r\n}\r\n\r\nexport interface TMXObject {\r\n    properties: PropertiesInfo;\r\n    id: number | string;\r\n    name: string;\r\n    width: number;\r\n    height: number;\r\n    x: number;\r\n    y: number;\r\n    rotation: number;\r\n    type: TMXObjectType;\r\n    visible: boolean;\r\n    wrap: boolean;\r\n    color: Color;\r\n    halign: HorizontalTextAlignment;\r\n    valign: VerticalTextAlignment;\r\n    pixelsize: number;\r\n    text: string;\r\n    gid: MixedGID;\r\n    points: { x: number, y: number }[];\r\n    polylinePoints: { x: number, y: number }[] | null;\r\n\r\n    offset?: Vec2;\r\n}\r\n\r\n/**\r\n * cc.TMXLayerInfo contains the information about the layers like:\r\n * - Layer name\r\n * - Layer size\r\n * - Layer opacity at creation time (it can be modified at runtime)\r\n * - Whether the layer is visible (if it's not visible, then the CocosNode won't be created)\r\n * This information is obtained from the TMX file.\r\n * @class TMXLayerInfo\r\n */\r\nexport class TMXLayerInfo {\r\n    /**\r\n     * Properties of the layer info.\r\n     * @property {Object} properties\r\n     */\r\n    properties: PropertiesInfo = {} as any;\r\n    name = '';\r\n    layerSize: Size | null = null;\r\n    tiles: number[] | Uint32Array = [];\r\n    visible = true;\r\n    opacity = 0;\r\n    ownTiles = true;\r\n    minGID: GID = 100000 as unknown as GID;\r\n    maxGID: GID = 0 as unknown as GID;\r\n    offset: Vec2 = new Vec2(0, 0);\r\n    tintColor: Color | null = null;\r\n\r\n    /**\r\n     * Gets the Properties.\r\n     * @return {Object}\r\n     */\r\n    getProperties (): PropertiesInfo {\r\n        return this.properties;\r\n    }\r\n\r\n    /**\r\n     * Set the Properties.\r\n     * @param {object} value\r\n     */\r\n    setProperties (value: PropertiesInfo): void {\r\n        this.properties = value;\r\n    }\r\n\r\n    /**\r\n     * @property ATTRIB_NONE\r\n     * @constant\r\n     * @static\r\n     * @type {Number}\r\n     * @default 1\r\n     */\r\n    static ATTRIB_NONE = 1 << 0;\r\n    /**\r\n     * @property ATTRIB_BASE64\r\n     * @constant\r\n     * @static\r\n     * @type {Number}\r\n     * @default 2\r\n     */\r\n    static ATTRIB_BASE64 = 1 << 1;\r\n    /**\r\n     * @property ATTRIB_GZIP\r\n     * @constant\r\n     * @static\r\n     * @type {Number}\r\n     * @default 4\r\n     */\r\n    static ATTRIB_GZIP = 1 << 2;\r\n    /**\r\n     * @property ATTRIB_ZLIB\r\n     * @constant\r\n     * @static\r\n     * @type {Number}\r\n     * @default 8\r\n     */\r\n    static ATTRIB_ZLIB = 1 << 3;\r\n}\r\n\r\n/**\r\n * cc.TMXImageLayerInfo contains the information about the image layers.\r\n * This information is obtained from the TMX file.\r\n * @class TMXImageLayerInfo\r\n */\r\nexport class TMXImageLayerInfo {\r\n    name = '';\r\n    visible = true;\r\n    width = 0;\r\n    height = 0;\r\n    offset: Vec2 = new Vec2(0, 0);\r\n    opacity = 0;\r\n    trans = new Color(255, 255, 255, 255);\r\n    sourceImage?: SpriteFrame;\r\n\r\n    tintColor: Color | null = null;\r\n}\r\n\r\ntype DrawOrder = 'topdown' | 'bottomup';\r\n\r\nexport interface TiledGrid {\r\n\r\n    // record texture id\r\n    // texId: TexID;\r\n    // record belong to which tileset\r\n    tileset: TMXTilesetInfo;\r\n    x: number;\r\n    y: number;\r\n    width: number;\r\n    height: number;\r\n    t: number;\r\n    l: number;\r\n    r: number;\r\n    b: number;\r\n    cx: number;\r\n    cy: number;\r\n    offsetX: number;\r\n    offsetY: number;\r\n    rotated: boolean;\r\n    gid: GID;\r\n    spriteFrame: SpriteFrame;\r\n    texture: Texture2D;\r\n\r\n    _name?: string;\r\n    _rect?: Rect;\r\n    _rotated?: boolean;\r\n}\r\n\r\nexport type TiledTextureGrids = Map<GID, TiledGrid>;\r\n","/*\r\n Copyright (c) 2020-2023 Xiamen Yaji Software Co., Ltd.\r\n\r\n https://www.cocos.com/\r\n\r\n Permission is hereby granted, free of charge, to any person obtaining a copy\r\n of this software and associated documentation files (the \"Software\"), to deal\r\n in the Software without restriction, including without limitation the rights to\r\n use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\r\n of the Software, and to permit persons to whom the Software is furnished to do so,\r\n subject to the following conditions:\r\n\r\n The above copyright notice and this permission notice shall be included in\r\n all copies or substantial portions of the Software.\r\n\r\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n THE SOFTWARE.\r\n*/\r\n\r\nimport { Label, HorizontalTextAlignment, VerticalTextAlignment } from '../2d/components/label';\r\nimport codec from '../../external/compression/ZipUtils';\r\nimport zlib from '../../external/compression/zlib.min';\r\nimport { SAXParser } from '../asset/asset-manager/plist-parser';\r\nimport {\r\n    GID, MixedGID, Orientation, PropertiesInfo, RenderOrder, StaggerAxis, StaggerIndex, TiledAnimation, TiledAnimationType,\r\n    TileFlag, TMXImageLayerInfo, TMXLayerInfo, TMXObject, TMXObjectGroupInfo, TMXObjectType, TMXTilesetInfo,\r\n} from './tiled-types';\r\nimport { Color, error, errorID, logID, Size, Vec2, warn } from '../core';\r\nimport { SpriteFrame } from '../2d/assets';\r\n\r\nfunction uint8ArrayToUint32Array (uint8Arr: Uint8Array): null | Uint32Array | number[] {\r\n    if (uint8Arr.length % 4 !== 0) return null;\r\n    const arrLen = uint8Arr.length / 4;\r\n    const retArr = window.Uint32Array ? new Uint32Array(arrLen) : [];\r\n    for (let i = 0; i < arrLen; i++) {\r\n        const offset = i * 4;\r\n        retArr[i] = uint8Arr[offset] + uint8Arr[offset + 1] * (1 << 8) + uint8Arr[offset + 2] * (1 << 16) + uint8Arr[offset + 3] * (1 << 24);\r\n    }\r\n    return retArr;\r\n}\r\n\r\nfunction strToHAlign (value): HorizontalTextAlignment {\r\n    const hAlign = Label.HorizontalAlign;\r\n    switch (value) {\r\n    case 'center':\r\n        return hAlign.CENTER;\r\n    case 'right':\r\n        return hAlign.RIGHT;\r\n    default:\r\n        return hAlign.LEFT;\r\n    }\r\n}\r\n\r\nfunction strToVAlign (value): VerticalTextAlignment {\r\n    const vAlign = Label.VerticalAlign;\r\n    switch (value) {\r\n    case 'center':\r\n        return vAlign.CENTER;\r\n    case 'bottom':\r\n        return vAlign.BOTTOM;\r\n    default:\r\n        return vAlign.TOP;\r\n    }\r\n}\r\n\r\nfunction strToColor (value: string): Color {\r\n    if (!value) {\r\n        return new Color(0, 0, 0, 255);\r\n    }\r\n    value = (value.indexOf('#') !== -1) ? value.substring(1) : value;\r\n    if (value.length === 8) {\r\n        const a = parseInt(value.substr(0, 2), 16) || 255;\r\n        const r = parseInt(value.substr(2, 2), 16) || 0;\r\n        const g = parseInt(value.substr(4, 2), 16) || 0;\r\n        const b = parseInt(value.substr(6, 2), 16) || 0;\r\n        return new Color(r, g, b, a);\r\n    } else {\r\n        const r = parseInt(value.substr(0, 2), 16) || 0;\r\n        const g = parseInt(value.substr(2, 2), 16) || 0;\r\n        const b = parseInt(value.substr(4, 2), 16) || 0;\r\n        return new Color(r, g, b, 255);\r\n    }\r\n}\r\n\r\nfunction getPropertyList (node: Element, map?: PropertiesInfo): PropertiesInfo {\r\n    const res: any[] = [];\r\n    const properties = Array.from(node.getElementsByTagName('properties')).filter((element) => element.parentNode === node);\r\n    for (let i = 0; i < properties.length; ++i) {\r\n        const property = properties[i].getElementsByTagName('property');\r\n        for (let j = 0; j < property.length; ++j) {\r\n            res.push(property[j]);\r\n        }\r\n    }\r\n\r\n    map = map || ({} as any);\r\n    for (let i = 0; i < res.length; i++) {\r\n        const element = res[i];\r\n        const name = element.getAttribute('name');\r\n        const type = element.getAttribute('type') || 'string';\r\n\r\n        let value = element.getAttribute('value');\r\n        if (type === 'int') {\r\n            value = parseInt(value as string);\r\n        } else if (type === 'float') {\r\n            value = parseFloat(value as string);\r\n        } else if (type === 'bool') {\r\n            value = value === 'true';\r\n        } else if (type === 'color') {\r\n            value = strToColor(value as string);\r\n        }\r\n\r\n        map![name] = value;\r\n    }\r\n\r\n    return map!;\r\n}\r\n\r\n/**\r\n * <p>cc.TMXMapInfo contains the information about the map like: <br/>\r\n * - Map orientation (hexagonal, isometric or orthogonal)<br/>\r\n * - Tile size<br/>\r\n * - Map size</p>\r\n *\r\n * <p>And it also contains: <br/>\r\n * - Layers (an array of TMXLayerInfo objects)<br/>\r\n * - Tilesets (an array of TMXTilesetInfo objects) <br/>\r\n * - ObjectGroups (an array of TMXObjectGroupInfo objects) </p>\r\n *\r\n * <p>This information is obtained from the TMX file. </p>\r\n * @class TMXMapInfo\r\n */\r\n\r\nexport class TMXMapInfo {\r\n    /**\r\n     * Properties of the map info.\r\n     * @property {Array}    properties\r\n     */\r\n    properties: PropertiesInfo = {} as any;\r\n\r\n    /**\r\n     * Map orientation.\r\n     * @property {Number}   orientation\r\n     */\r\n    orientation: Orientation | null = null;\r\n\r\n    /**\r\n     * Parent element.\r\n     * @property {Object}   parentElement\r\n     */\r\n    parentElement: Record<string, unknown> | null = null;\r\n\r\n    /**\r\n     * Parent GID.\r\n     * @property {Number}   parentGID\r\n     */\r\n    parentGID: MixedGID = 0 as unknown as any;\r\n\r\n    /**\r\n     * Layer attributes.\r\n     * @property {Object}   layerAttrs\r\n     */\r\n    layerAttrs = 0;\r\n\r\n    /**\r\n     * Is reading storing characters stream.\r\n     * @property {Boolean}  storingCharacters\r\n     */\r\n    storingCharacters = false;\r\n\r\n    /**\r\n     * Current string stored from characters stream.\r\n     * @property {String}   currentString\r\n     */\r\n    currentString: string | null = null;\r\n    renderOrder: RenderOrder = RenderOrder.RightDown;\r\n\r\n    protected _supportVersion = [1, 4, 0];\r\n    protected _objectGroups: TMXObjectGroupInfo[] = [];\r\n    protected _allChildren: (TMXLayerInfo | TMXImageLayerInfo | TMXObjectGroupInfo)[] = [];\r\n    protected _mapSize = new Size(0, 0);\r\n    get mapSize (): Size { return this._mapSize; }\r\n    protected _tileSize = new Size(0, 0);\r\n    get tileSize (): Size { return this._tileSize; }\r\n    protected _layers: TMXLayerInfo[] = [];\r\n    protected _tilesets: TMXTilesetInfo[] = [];\r\n    protected _imageLayers: TMXImageLayerInfo[] = [];\r\n    protected _tileProperties: Map<GID, PropertiesInfo> = new Map();\r\n    protected _tileAnimations: TiledAnimationType = {} as any;\r\n    protected _tsxContentMap: { [key: string]: string } | null = null;\r\n\r\n    // map of textures indexed by name\r\n    protected _spriteFrameMap: { [key: string]: SpriteFrame } | null = null;\r\n    protected _spfSizeMap: { [key: string]: Size } = {};\r\n\r\n    // hex map values\r\n    protected _staggerAxis: StaggerAxis | null = null;\r\n    protected _staggerIndex: StaggerIndex | null = null;\r\n    protected _hexSideLength = 0;\r\n\r\n    protected _imageLayerSPF: { [key: string]: SpriteFrame } | null = null;\r\n\r\n    constructor (\r\n        tmxFile: string,\r\n        tsxContentMap: { [key: string]: string },\r\n        spfTexturesMap: { [key: string]: SpriteFrame },\r\n        textureSizes: { [key: string]: Size },\r\n        imageLayerTextures: { [key: string]: SpriteFrame },\r\n    ) {\r\n        this.initWithXML(tmxFile, tsxContentMap, spfTexturesMap, textureSizes, imageLayerTextures);\r\n    }\r\n\r\n    /* Gets Map orientation.\r\n     * @return {Number}\r\n     */\r\n    getOrientation (): Orientation | null {\r\n        return this.orientation;\r\n    }\r\n\r\n    /**\r\n     * Set the Map orientation.\r\n     * @param {Number} value\r\n     */\r\n    setOrientation (value: Orientation): void {\r\n        this.orientation = value;\r\n    }\r\n    /**\r\n     * Gets the staggerAxis of map.\r\n     * @return {TiledMap.StaggerAxis}\r\n     */\r\n    getStaggerAxis (): StaggerAxis | null {\r\n        return this._staggerAxis;\r\n    }\r\n\r\n    /**\r\n     * Set the staggerAxis of map.\r\n     * @param {TiledMap.StaggerAxis} value\r\n     */\r\n    setStaggerAxis (value: StaggerAxis): void {\r\n        this._staggerAxis = value;\r\n    }\r\n\r\n    /**\r\n     * Gets stagger index\r\n     * @return {TiledMap.StaggerIndex}\r\n     */\r\n    getStaggerIndex (): StaggerIndex | null {\r\n        return this._staggerIndex;\r\n    }\r\n\r\n    /**\r\n     * Set the stagger index.\r\n     * @param {TiledMap.StaggerIndex} value\r\n     */\r\n    setStaggerIndex (value): void {\r\n        this._staggerIndex = value;\r\n    }\r\n\r\n    /**\r\n     * Gets Hex side length.\r\n     * @return {Number}\r\n     */\r\n    getHexSideLength (): number {\r\n        return this._hexSideLength;\r\n    }\r\n\r\n    /**\r\n     * Set the Hex side length.\r\n     * @param {Number} value\r\n     */\r\n    setHexSideLength (value: number): void {\r\n        this._hexSideLength = value;\r\n    }\r\n\r\n    /**\r\n     * Map width & height\r\n     * @return {Size}\r\n     */\r\n    getMapSize (): Size {\r\n        return new Size(this._mapSize.width, this._mapSize.height);\r\n    }\r\n\r\n    /**\r\n     * Map width & height\r\n     * @param {Size} value\r\n     */\r\n    setMapSize (value: Size): void {\r\n        this._mapSize.width = value.width;\r\n        this._mapSize.height = value.height;\r\n    }\r\n\r\n    get mapWidth (): number {\r\n        return this._mapSize.width;\r\n    }\r\n    set mapWidth (width: number) {\r\n        this._mapSize.width = width;\r\n    }\r\n\r\n    get mapHeight (): number {\r\n        return this._mapSize.height;\r\n    }\r\n    set mapHeight (height: number) {\r\n        this._mapSize.height = height;\r\n    }\r\n\r\n    /**\r\n     * Tiles width & height\r\n     * @return {Size}\r\n     */\r\n    getTileSize (): Size {\r\n        return new Size(this._tileSize.width, this._tileSize.height);\r\n    }\r\n\r\n    /**\r\n     * Tiles width & height\r\n     * @param {Size} value\r\n     */\r\n    setTileSize (value: Size): void {\r\n        this._tileSize.width = value.width;\r\n        this._tileSize.height = value.height;\r\n    }\r\n\r\n    get tileWidth (): number {\r\n        return this._tileSize.width;\r\n    }\r\n\r\n    set tileWidth (width) {\r\n        this._tileSize.width = width;\r\n    }\r\n\r\n    /**\r\n     * Height of a tile\r\n     */\r\n    get tileHeight (): number {\r\n        return this._tileSize.height;\r\n    }\r\n\r\n    set tileHeight (height: number) {\r\n        this._tileSize.height = height;\r\n    }\r\n\r\n    /**\r\n     * Layers\r\n     * @return {Array}\r\n     */\r\n    getLayers (): TMXLayerInfo[] {\r\n        return this._layers;\r\n    }\r\n\r\n    /**\r\n     * Layers\r\n     * @param {cc.TMXLayerInfo} value\r\n     */\r\n    setLayers (value: TMXLayerInfo): void {\r\n        this._allChildren.push(value);\r\n        this._layers.push(value);\r\n    }\r\n\r\n    /**\r\n     * ImageLayers\r\n     * @return {Array}\r\n     */\r\n    getImageLayers (): TMXImageLayerInfo[] {\r\n        return this._imageLayers;\r\n    }\r\n\r\n    /**\r\n     * ImageLayers\r\n     * @param {cc.TMXImageLayerInfo} value\r\n     */\r\n    setImageLayers (value: TMXImageLayerInfo): void {\r\n        this._allChildren.push(value);\r\n        this._imageLayers.push(value);\r\n    }\r\n\r\n    /**\r\n     * tilesets\r\n     * @return {Array}\r\n     */\r\n    getTilesets (): TMXTilesetInfo[] {\r\n        return this._tilesets;\r\n    }\r\n\r\n    /**\r\n     * tilesets\r\n     * @param {cc.TMXTilesetInfo} value\r\n     */\r\n    setTilesets (value: TMXTilesetInfo): void {\r\n        this._tilesets.push(value);\r\n    }\r\n\r\n    /**\r\n     * ObjectGroups\r\n     * @return {Array}\r\n     */\r\n    getObjectGroups (): TMXObjectGroupInfo[] {\r\n        return this._objectGroups;\r\n    }\r\n\r\n    /**\r\n     * ObjectGroups\r\n     * @param {cc.TMXObjectGroup} value\r\n     */\r\n    setObjectGroups (value: TMXObjectGroupInfo): void {\r\n        this._allChildren.push(value);\r\n        this._objectGroups.push(value);\r\n    }\r\n\r\n    getAllChildren (): (TMXObjectGroupInfo | TMXLayerInfo | TMXImageLayerInfo)[] {\r\n        return this._allChildren;\r\n    }\r\n\r\n    /**\r\n     * parent element\r\n     * @return {Object}\r\n     */\r\n    getParentElement (): Record<string, unknown> | null {\r\n        return this.parentElement;\r\n    }\r\n\r\n    /**\r\n     * parent element\r\n     * @param {Object} value\r\n     */\r\n    setParentElement (value): void {\r\n        this.parentElement = value;\r\n    }\r\n\r\n    /**\r\n     * parent GID\r\n     * @return {Number}\r\n     */\r\n    getParentGID (): number {\r\n        return this.parentGID;\r\n    }\r\n\r\n    /**\r\n     * parent GID\r\n     * @param {Number} value\r\n     */\r\n    setParentGID (value): void {\r\n        this.parentGID = value;\r\n    }\r\n\r\n    /**\r\n     * Layer attribute\r\n     * @return {Object}\r\n     */\r\n    getLayerAttribs (): number {\r\n        return this.layerAttrs;\r\n    }\r\n\r\n    /**\r\n     * Layer attribute\r\n     * @param {Object} value\r\n     */\r\n    setLayerAttribs (value): void {\r\n        this.layerAttrs = value;\r\n    }\r\n\r\n    /**\r\n     * Is reading storing characters stream\r\n     * @return {Boolean}\r\n     */\r\n    getStoringCharacters (): boolean {\r\n        return this.storingCharacters;\r\n    }\r\n\r\n    /**\r\n     * Is reading storing characters stream\r\n     * @param {Boolean} value\r\n     */\r\n    setStoringCharacters (value): void {\r\n        this.storingCharacters = value;\r\n    }\r\n\r\n    /**\r\n     * Properties\r\n     * @return {Array}\r\n     */\r\n    getProperties (): PropertiesInfo {\r\n        return this.properties;\r\n    }\r\n\r\n    /**\r\n     * Properties\r\n     * @param {object} value\r\n     */\r\n    setProperties (value): void {\r\n        this.properties = value;\r\n    }\r\n\r\n    /**\r\n     * initializes a TMX format with an XML string and a TMX resource path\r\n     * @param {String} tmxString\r\n     * @param {Object} tsxMap\r\n     * @param {Object} spfTextureMap\r\n     * @return {Boolean}\r\n     */\r\n    initWithXML (\r\n        tmxString: string,\r\n        tsxMap: { [key: string]: string },\r\n        spfTextureMap: { [key: string]: SpriteFrame },\r\n        textureSizes: { [key: string]: Size },\r\n        imageLayerTextures: { [key: string]: SpriteFrame },\r\n    ): HTMLElement {\r\n        this._tilesets.length = 0;\r\n        this._layers.length = 0;\r\n        this._imageLayers.length = 0;\r\n\r\n        this._tsxContentMap = tsxMap;\r\n        this._spriteFrameMap = spfTextureMap;\r\n        this._imageLayerSPF = imageLayerTextures;\r\n        this._spfSizeMap = textureSizes;\r\n\r\n        this._objectGroups.length = 0;\r\n        this._allChildren.length = 0;\r\n        this.properties = {} as any;\r\n        this._tileProperties = new Map();\r\n        this._tileAnimations = new Map();\r\n\r\n        // tmp vars\r\n        this.currentString = '';\r\n        this.storingCharacters = false;\r\n        this.layerAttrs = TMXLayerInfo.ATTRIB_NONE;\r\n        this.parentElement = null;\r\n\r\n        return this.parseXMLString(tmxString);\r\n    }\r\n\r\n    /**\r\n     * Initializes parsing of an XML string, either a tmx (Map) string or tsx (Tileset) string\r\n     * @param {String} xmlString\r\n     * @param {Number} tilesetFirstGid\r\n     * @return {Element}\r\n     */\r\n    parseXMLString (xmlStr: string, tilesetFirstGid?: number): HTMLElement {\r\n        const parser = new SAXParser();\r\n        const mapXML: Document = parser.parse(xmlStr);\r\n        let i: number;\r\n\r\n        // PARSE <map>\r\n        const map = mapXML.documentElement;\r\n\r\n        const orientationStr = map.getAttribute('orientation');\r\n        const staggerAxisStr = map.getAttribute('staggeraxis');\r\n        const staggerIndexStr = map.getAttribute('staggerindex');\r\n        const hexSideLengthStr = map.getAttribute('hexsidelength');\r\n        const renderorderStr = map.getAttribute('renderorder');\r\n        const version = map.getAttribute('version') || '1.0.0';\r\n\r\n        if (map.nodeName === 'map') {\r\n            const versionArr = version.split('.');\r\n            const supportVersion = this._supportVersion;\r\n            for (i = 0; i < supportVersion.length; i++) {\r\n                const v = parseInt(versionArr[i]) || 0;\r\n                const sv = supportVersion[i];\r\n                if (sv < v) {\r\n                    logID(7216, version);\r\n                    break;\r\n                }\r\n            }\r\n\r\n            if (orientationStr === 'orthogonal') this.orientation = Orientation.ORTHO;\r\n            else if (orientationStr === 'isometric') this.orientation = Orientation.ISO;\r\n            else if (orientationStr === 'hexagonal') this.orientation = Orientation.HEX;\r\n            else if (orientationStr !== null) logID(7217, orientationStr);\r\n\r\n            if (renderorderStr === 'right-up') {\r\n                this.renderOrder = RenderOrder.RightUp;\r\n            } else if (renderorderStr === 'left-up') {\r\n                this.renderOrder = RenderOrder.LeftUp;\r\n            } else if (renderorderStr === 'left-down') {\r\n                this.renderOrder = RenderOrder.LeftDown;\r\n            } else {\r\n                this.renderOrder = RenderOrder.RightDown;\r\n            }\r\n\r\n            if (staggerAxisStr === 'x') {\r\n                this.setStaggerAxis(StaggerAxis.STAGGERAXIS_X);\r\n            } else if (staggerAxisStr === 'y') {\r\n                this.setStaggerAxis(StaggerAxis.STAGGERAXIS_Y);\r\n            }\r\n\r\n            if (staggerIndexStr === 'odd') {\r\n                this.setStaggerIndex(StaggerIndex.STAGGERINDEX_ODD);\r\n            } else if (staggerIndexStr === 'even') {\r\n                this.setStaggerIndex(StaggerIndex.STAGGERINDEX_EVEN);\r\n            }\r\n\r\n            if (hexSideLengthStr) {\r\n                this.setHexSideLength(parseFloat(hexSideLengthStr));\r\n            }\r\n\r\n            let mapSize = new Size(0, 0);\r\n            mapSize.width = parseFloat(map.getAttribute('width')!);\r\n            mapSize.height = parseFloat(map.getAttribute('height')!);\r\n            this.setMapSize(mapSize);\r\n\r\n            mapSize = new Size(0, 0);\r\n            mapSize.width = parseFloat(map.getAttribute('tilewidth')!);\r\n            mapSize.height = parseFloat(map.getAttribute('tileheight')!);\r\n            this.setTileSize(mapSize);\r\n\r\n            // The parent element is the map\r\n            this.properties = getPropertyList(map);\r\n        }\r\n\r\n        // PARSE <tileset>\r\n        let tilesets: Element[] = map.getElementsByTagName('tileset') as unknown as Element[];\r\n        if (map.nodeName !== 'map') {\r\n            tilesets = [];\r\n            tilesets.push(map);\r\n        }\r\n\r\n        for (i = 0; i < tilesets.length; i++) {\r\n            const curTileset = tilesets[i];\r\n            // If this is an external tileset then start parsing that\r\n            const tsxName = curTileset.getAttribute('source');\r\n            if (tsxName) {\r\n                const currentFirstGID = parseInt(curTileset.getAttribute('firstgid')!);\r\n                const tsxXmlString = this._tsxContentMap![tsxName];\r\n                if (tsxXmlString) {\r\n                    this.parseXMLString(tsxXmlString, currentFirstGID);\r\n                }\r\n            } else {\r\n                const images = curTileset.getElementsByTagName('image');\r\n                const collection = images.length > 1;\r\n                const firstImage = images[0];\r\n                let firstImageName: string = firstImage.getAttribute('source')!;\r\n                firstImageName = firstImageName.replace(/\\\\/g, '/');\r\n\r\n                const tiles = curTileset.getElementsByTagName('tile');\r\n                const tileCount = tiles && tiles.length || 1;\r\n                let tile: Element | null = null;\r\n\r\n                const tilesetName = curTileset.getAttribute('name') || '';\r\n                const tilesetSpacing = parseInt(curTileset.getAttribute('spacing')!) || 0;\r\n                const tilesetMargin = parseInt(curTileset.getAttribute('margin')!) || 0;\r\n                const fgid = tilesetFirstGid || (parseInt(curTileset.getAttribute('firstgid')!) || 0);\r\n\r\n                const tilesetSize = new Size(0, 0);\r\n                tilesetSize.width = parseFloat(curTileset.getAttribute('tilewidth')!);\r\n                tilesetSize.height = parseFloat(curTileset.getAttribute('tileheight')!);\r\n\r\n                // parse tile offset\r\n                const curTileOffset = curTileset.getElementsByTagName('tileoffset')[0];\r\n                let tileOffsetX = 0;\r\n                let tileOffsetY = 0;\r\n                if (curTileOffset) {\r\n                    tileOffsetX = parseFloat(curTileOffset.getAttribute('x')!) || 0;\r\n                    tileOffsetY = parseFloat(curTileOffset.getAttribute('y')!) || 0;\r\n                }\r\n\r\n                let tileset: TMXTilesetInfo | null = null;\r\n                for (let tileIdx = 0; tileIdx < tileCount; tileIdx++) {\r\n                    const curImage = images[tileIdx] ? images[tileIdx] : firstImage;\r\n                    if (!curImage) continue;\r\n                    let curImageName: string = curImage.getAttribute('source')!;\r\n                    curImageName = curImageName.replace(/\\\\/g, '/');\r\n\r\n                    if (!tileset || collection) {\r\n                        tileset = new TMXTilesetInfo();\r\n                        tileset.name = tilesetName;\r\n                        tileset.firstGid = fgid & TileFlag.FLIPPED_MASK;\r\n                        tileset.tileOffset.x = tileOffsetX;\r\n                        tileset.tileOffset.y = tileOffsetY;\r\n\r\n                        tileset.collection = collection;\r\n                        if (!collection) {\r\n                            tileset.imageName = curImageName;\r\n                            tileset.imageSize.width = parseFloat(curImage.getAttribute('width')!) || 0;\r\n                            tileset.imageSize.height = parseFloat(curImage.getAttribute('height')!) || 0;\r\n                            tileset.sourceImage = this._spriteFrameMap![curImageName];\r\n                            if (!tileset.sourceImage) {\r\n                                const nameWithPostfix = TMXMapInfo.getNameWithPostfix(curImageName);\r\n                                tileset.imageName = nameWithPostfix;\r\n                                tileset.sourceImage = this._spriteFrameMap![nameWithPostfix];\r\n                                if (!tileset.sourceImage) {\r\n                                    const shortName = TMXMapInfo.getShortName(curImageName);\r\n                                    tileset.imageName = shortName;\r\n                                    tileset.sourceImage = this._spriteFrameMap![shortName];\r\n                                    if (!tileset.sourceImage) {\r\n                                        error(`[error]: ${shortName} not find in [${Object.keys(this._spriteFrameMap!).join(', ')}]`);\r\n                                        errorID(7221, curImageName);\r\n                                        warn(`Please try asset type of ${curImageName} to 'sprite-frame'`);\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n                        tileset.spacing = tilesetSpacing;\r\n                        tileset.margin = tilesetMargin;\r\n                        tileset._tileSize.width = tilesetSize.width;\r\n                        tileset._tileSize.height = tilesetSize.height;\r\n                        this.setTilesets(tileset);\r\n                    }\r\n\r\n                    // parse tiles by tileIdx\r\n                    tile = tiles && tiles[tileIdx];\r\n                    if (!tile) {\r\n                        continue;\r\n                    }\r\n\r\n                    this.parentGID = (fgid + (parseInt(tile.getAttribute('id')!) || 0)) as any;\r\n                    const tileImages = tile.getElementsByTagName('image');\r\n                    if (tile.hasAttribute('x') && tile.hasAttribute('y')) {\r\n                        tileset.imageOffset = new Vec2(parseFloat(tile.getAttribute('x')!) || 0, parseFloat(tile.getAttribute('y')!) || 0);\r\n                    }\r\n                    const hastilesize = tile.hasAttribute('width') && tile.hasAttribute('height');\r\n                    if (hastilesize) {\r\n                        tileset._tileSize.width = parseFloat(tile.getAttribute('width')!) || 0;\r\n                        tileset._tileSize.height = parseFloat(tile.getAttribute('height')!) || 0;\r\n                    }\r\n                    if (tileImages && tileImages.length > 0) {\r\n                        const image = tileImages[0];\r\n                        let imageName = image.getAttribute('source')!;\r\n                        imageName = imageName.replace(/\\\\/g, '/');\r\n\r\n                        tileset.imageName = imageName;\r\n                        tileset.imageSize.width = parseFloat(image.getAttribute('width')!) || 0;\r\n                        tileset.imageSize.height = parseFloat(image.getAttribute('height')!) || 0;\r\n\r\n                        if (!hastilesize) {\r\n                            tileset._tileSize.width = tileset.imageSize.width;\r\n                            tileset._tileSize.height = tileset.imageSize.height;\r\n                        }\r\n\r\n                        tileset.sourceImage = this._spriteFrameMap![imageName];\r\n                        if (!tileset.sourceImage) {\r\n                            const nameWithPostfix = TMXMapInfo.getNameWithPostfix(imageName);\r\n                            tileset.imageName = nameWithPostfix;\r\n                            tileset.sourceImage = this._spriteFrameMap![nameWithPostfix];\r\n                            if (!tileset.sourceImage) {\r\n                                const shortName = TMXMapInfo.getShortName(imageName);\r\n                                tileset.imageName = shortName;\r\n                                tileset.sourceImage = this._spriteFrameMap![shortName];\r\n                                if (!tileset.sourceImage) {\r\n                                    errorID(7221, imageName);\r\n                                    warn(`Please try asset type of ${imageName} to 'sprite-frame'`);\r\n                                }\r\n                            }\r\n                        }\r\n\r\n                        tileset.firstGid = this.parentGID & TileFlag.FLIPPED_MASK;\r\n                    }\r\n                    const pid = ((TileFlag.FLIPPED_MASK & this.parentGID as unknown as number) >>> 0) as unknown as GID;\r\n                    this._tileProperties.set(pid, getPropertyList(tile));\r\n                    const animations = tile.getElementsByTagName('animation');\r\n                    if (animations && animations.length > 0) {\r\n                        const animation = animations[0];\r\n                        const framesData = animation.getElementsByTagName('frame');\r\n                        const animationProp: TiledAnimation = { frames: [], dt: 0, frameIdx: 0 };\r\n                        this._tileAnimations.set(pid, animationProp);\r\n                        const frames = animationProp.frames;\r\n                        for (let frameIdx = 0; frameIdx < framesData.length; frameIdx++) {\r\n                            const frame = framesData[frameIdx];\r\n                            const tileid = fgid + (parseInt(frame.getAttribute('tileid')!) || 0);\r\n                            const duration = parseFloat(frame.getAttribute('duration')!) || 0;\r\n                            frames.push({ tileid: tileid as unknown as GID, duration: duration / 1000, grid: null });\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        // PARSE <layer> & <objectgroup> in order\r\n        const childNodes = map.childNodes;\r\n        for (i = 0; i < childNodes.length; i++) {\r\n            const childNode = childNodes[i];\r\n            if (this._shouldIgnoreNode(childNode)) {\r\n                continue;\r\n            }\r\n\r\n            if (childNode.nodeName === 'imagelayer') {\r\n                const imageLayer = this._parseImageLayer(childNode as Element);\r\n                if (imageLayer) {\r\n                    this.setImageLayers(imageLayer);\r\n                }\r\n            }\r\n\r\n            if (childNode.nodeName === 'layer') {\r\n                const layer = this._parseLayer(childNode as Element);\r\n                this.setLayers(layer!);\r\n            }\r\n\r\n            if (childNode.nodeName === 'objectgroup') {\r\n                const objectGroup = this._parseObjectGroup(childNode as Element);\r\n                this.setObjectGroups(objectGroup);\r\n            }\r\n        }\r\n\r\n        return map;\r\n    }\r\n\r\n    protected _shouldIgnoreNode (node: ChildNode): boolean {\r\n        return node.nodeType === 3 // text\r\n            || node.nodeType === 8   // comment\r\n            || node.nodeType === 4;  // cdata\r\n    }\r\n\r\n    protected _parseImageLayer (selLayer: Element): TMXImageLayerInfo | null {\r\n        const datas = selLayer.getElementsByTagName('image');\r\n        if (!datas || datas.length === 0) return null;\r\n\r\n        const imageLayer = new TMXImageLayerInfo();\r\n        imageLayer.name = selLayer.getAttribute('name')!;\r\n        imageLayer.offset.x = parseFloat(selLayer.getAttribute('offsetx')!) || 0;\r\n        imageLayer.offset.y = parseFloat(selLayer.getAttribute('offsety')!) || 0;\r\n        const visible = selLayer.getAttribute('visible');\r\n        imageLayer.visible = !(visible === '0');\r\n\r\n        const opacity = selLayer.getAttribute('opacity');\r\n        imageLayer.opacity = opacity ? Math.round(255 * parseFloat(opacity)) : 255;\r\n\r\n        const tintColor = selLayer.getAttribute('tintcolor');\r\n        imageLayer.tintColor = tintColor ? strToColor(tintColor) : null;\r\n\r\n        const data = datas[0];\r\n        const source = data.getAttribute('source');\r\n        imageLayer.sourceImage = this._imageLayerSPF![source!];\r\n        imageLayer.width = parseInt(data.getAttribute('width')!) || 0;\r\n        imageLayer.height = parseInt(data.getAttribute('height')!) || 0;\r\n        imageLayer.trans = strToColor(data.getAttribute('trans')!);\r\n\r\n        if (!imageLayer.sourceImage) {\r\n            errorID(7221, source!);\r\n            warn(`Please try asset type of ${source} to 'sprite-frame'`);\r\n            return null;\r\n        }\r\n        return imageLayer;\r\n    }\r\n\r\n    protected _parseLayer (selLayer: Element): TMXLayerInfo | null {\r\n        const data = selLayer.getElementsByTagName('data')[0];\r\n\r\n        const layer = new TMXLayerInfo();\r\n        layer.name = selLayer.getAttribute('name')!;\r\n\r\n        const layerSize = new Size(0, 0);\r\n        layerSize.width = parseFloat(selLayer.getAttribute('width')!);\r\n        layerSize.height = parseFloat(selLayer.getAttribute('height')!);\r\n        layer.layerSize = layerSize;\r\n\r\n        const visible = selLayer.getAttribute('visible');\r\n        layer.visible = !(visible === '0');\r\n\r\n        const opacity = selLayer.getAttribute('opacity');\r\n        if (opacity) layer.opacity = Math.round(255 * parseFloat(opacity));\r\n        else layer.opacity = 255;\r\n        layer.offset = new Vec2(parseFloat(selLayer.getAttribute('offsetx')!) || 0, parseFloat(selLayer.getAttribute('offsety')!) || 0);\r\n\r\n        const tintColor = selLayer.getAttribute('tintcolor');\r\n        layer.tintColor = tintColor ? strToColor(tintColor) : null;\r\n\r\n        let nodeValue = '';\r\n        for (let j = 0; j < data.childNodes.length; j++) {\r\n            nodeValue += data.childNodes[j].nodeValue;\r\n        }\r\n        nodeValue = nodeValue.trim();\r\n\r\n        // Unpack the tilemap data\r\n        const compression = data.getAttribute('compression');\r\n        const encoding = data.getAttribute('encoding');\r\n        if (compression && compression !== 'gzip' && compression !== 'zlib') {\r\n            logID(7218);\r\n            return null;\r\n        }\r\n        let tiles;\r\n        switch (compression) {\r\n        case 'gzip':\r\n            tiles = codec.unzipBase64AsArray(nodeValue, 4);\r\n            break;\r\n        case 'zlib': {\r\n            const inflator = new zlib.Inflate(codec.Base64.decodeAsArray(nodeValue, 1));\r\n            tiles = uint8ArrayToUint32Array(inflator.decompress() as Uint8Array);\r\n            break;\r\n        }\r\n        case null:\r\n        case '':\r\n            // Uncompressed\r\n            if (encoding === 'base64') tiles = codec.Base64.decodeAsArray(nodeValue, 4);\r\n            else if (encoding === 'csv') {\r\n                tiles = [];\r\n                const csvTiles = nodeValue.split(',');\r\n                for (let csvIdx = 0; csvIdx < csvTiles.length; csvIdx++) tiles.push(parseInt(csvTiles[csvIdx]));\r\n            } else {\r\n                // XML format\r\n                const selDataTiles = data.getElementsByTagName('tile');\r\n                tiles = [];\r\n                for (let xmlIdx = 0; xmlIdx < selDataTiles.length; xmlIdx++) tiles.push(parseInt(selDataTiles[xmlIdx].getAttribute('gid')!));\r\n            }\r\n            break;\r\n        default:\r\n            if (this.layerAttrs === TMXLayerInfo.ATTRIB_NONE) logID(7219);\r\n            break;\r\n        }\r\n        if (tiles) {\r\n            layer.tiles = new Uint32Array(tiles as Iterable<number>);\r\n        }\r\n\r\n        // The parent element is the last layer\r\n        layer.properties = getPropertyList(selLayer);\r\n\r\n        return layer;\r\n    }\r\n\r\n    protected _parseObjectGroup (selGroup: Element): TMXObjectGroupInfo {\r\n        const objectGroup = new TMXObjectGroupInfo();\r\n        objectGroup.name = selGroup.getAttribute('name') || '';\r\n        objectGroup.offset = new Vec2(parseFloat(selGroup.getAttribute('offsetx')!), parseFloat(selGroup.getAttribute('offsety')!));\r\n\r\n        const opacity = selGroup.getAttribute('opacity');\r\n        if (opacity) objectGroup.opacity = Math.round(255 * parseFloat(opacity));\r\n        else objectGroup.opacity = 255;\r\n\r\n        const tintColor = selGroup.getAttribute('tintcolor');\r\n        objectGroup.tintColor = tintColor ? strToColor(tintColor) : null;\r\n\r\n        const visible = selGroup.getAttribute('visible');\r\n        if (visible && parseInt(visible) === 0) objectGroup.visible = false;\r\n\r\n        const color = selGroup.getAttribute('color');\r\n        if (color) objectGroup.color.fromHEX(color);\r\n\r\n        const draworder = selGroup.getAttribute('draworder');\r\n        if (draworder) objectGroup.draworder = draworder as any;\r\n\r\n        // set the properties to the group\r\n        objectGroup.setProperties(getPropertyList(selGroup));\r\n\r\n        const objects = selGroup.getElementsByTagName('object');\r\n        if (objects) {\r\n            for (let j = 0; j < objects.length; j++) {\r\n                const selObj = objects[j];\r\n                // The value for \"type\" was blank or not a valid class name\r\n                // Create an instance of TMXObjectInfo to store the object and its properties\r\n                const objectProp: TMXObject = {} as any;\r\n\r\n                // Set the id of the object\r\n                objectProp.id = selObj.getAttribute('id') || j;\r\n\r\n                // Set the name of the object to the value for \"name\"\r\n                objectProp.name = selObj.getAttribute('name') || '';\r\n\r\n                // Assign all the attributes as key/name pairs in the properties dictionary\r\n                objectProp.width = parseFloat(selObj.getAttribute('width')!) || 0;\r\n                objectProp.height = parseFloat(selObj.getAttribute('height')!) || 0;\r\n\r\n                objectProp.x = parseFloat(selObj.getAttribute('x')!) || 0;\r\n                objectProp.y = parseFloat(selObj.getAttribute('y')!) || 0;\r\n\r\n                objectProp.rotation = parseFloat(selObj.getAttribute('rotation')!) || 0;\r\n\r\n                objectProp.properties = getPropertyList(selObj);\r\n\r\n                // visible\r\n                const visibleAttr = selObj.getAttribute('visible');\r\n                objectProp.visible = !(visibleAttr && parseInt(visibleAttr) === 0);\r\n\r\n                // text\r\n                const texts = selObj.getElementsByTagName('text');\r\n                if (texts && texts.length > 0) {\r\n                    const text = texts[0];\r\n                    objectProp.type = TMXObjectType.TEXT;\r\n                    objectProp.wrap = text.getAttribute('wrap') === '1';\r\n                    objectProp.color = strToColor(text.getAttribute('color')!);\r\n                    objectProp.halign = strToHAlign(text.getAttribute('halign'));\r\n                    objectProp.valign = strToVAlign(text.getAttribute('valign'));\r\n                    objectProp.pixelsize = parseInt(text.getAttribute('pixelsize')!) || 16;\r\n                    objectProp.text = text.childNodes[0].nodeValue!;\r\n                }\r\n\r\n                // image\r\n                const gid = selObj.getAttribute('gid');\r\n                if (gid) {\r\n                    objectProp.gid = parseInt(gid) as any;\r\n                    objectProp.type = TMXObjectType.IMAGE;\r\n                }\r\n\r\n                // ellipse\r\n                const ellipse = selObj.getElementsByTagName('ellipse');\r\n                if (ellipse && ellipse.length > 0) {\r\n                    objectProp.type = TMXObjectType.ELLIPSE;\r\n                }\r\n\r\n                // polygon\r\n                const polygonProps = selObj.getElementsByTagName('polygon');\r\n                if (polygonProps && polygonProps.length > 0) {\r\n                    objectProp.type = TMXObjectType.POLYGON;\r\n                    const selPgPointStr = polygonProps[0].getAttribute('points');\r\n                    if (selPgPointStr) objectProp.points = this._parsePointsString(selPgPointStr)!;\r\n                }\r\n\r\n                // polyline\r\n                const polylineProps = selObj.getElementsByTagName('polyline');\r\n                if (polylineProps && polylineProps.length > 0) {\r\n                    objectProp.type = TMXObjectType.POLYLINE;\r\n                    const selPlPointStr = polylineProps[0].getAttribute('points');\r\n                    if (selPlPointStr) objectProp.polylinePoints = this._parsePointsString(selPlPointStr)!;\r\n                }\r\n\r\n                if (!objectProp.type) {\r\n                    objectProp.type = TMXObjectType.RECT;\r\n                }\r\n\r\n                // Add the object to the objectGroup\r\n                objectGroup.objects.push(objectProp);\r\n            }\r\n\r\n            if (draworder !== 'index') {\r\n                objectGroup.objects.sort((a, b) => a.y - b.y);\r\n            }\r\n        }\r\n        return objectGroup;\r\n    }\r\n\r\n    protected _parsePointsString (pointsString?: string): {\r\n        x: number;\r\n        y: number;\r\n    }[] | null {\r\n        if (!pointsString) return null;\r\n\r\n        const points: { x: number, y: number }[] = [];\r\n        const pointsStr = pointsString.split(' ');\r\n        for (let i = 0; i < pointsStr.length; i++) {\r\n            const selPointStr = pointsStr[i].split(',');\r\n            points.push({ x: parseFloat(selPointStr[0]), y: parseFloat(selPointStr[1]) });\r\n        }\r\n        return points;\r\n    }\r\n\r\n    /**\r\n     * Sets the tile animations.\r\n     * @return {Object}\r\n     */\r\n    setTileAnimations (animations: TiledAnimationType): void {\r\n        this._tileAnimations = animations;\r\n    }\r\n\r\n    /**\r\n     * Gets the tile animations.\r\n     * @return {Object}\r\n     */\r\n    getTileAnimations (): TiledAnimationType {\r\n        return this._tileAnimations;\r\n    }\r\n\r\n    /**\r\n     * Gets the tile properties.\r\n     * @return {Object}\r\n     */\r\n    getTileProperties (): Map<number, PropertiesInfo> {\r\n        return this._tileProperties;\r\n    }\r\n\r\n    /**\r\n     * Set the tile properties.\r\n     * @param {Object} tileProperties\r\n     */\r\n    setTileProperties (tileProperties: Map<GID, PropertiesInfo>): void {\r\n        this._tileProperties = tileProperties;\r\n    }\r\n\r\n    /**\r\n     * Gets the currentString\r\n     * @return {String}\r\n     */\r\n    getCurrentString (): string | null {\r\n        return this.currentString;\r\n    }\r\n\r\n    /**\r\n     * Set the currentString\r\n     * @param {String} currentString\r\n     */\r\n    setCurrentString (currentString: string): void {\r\n        this.currentString = currentString;\r\n    }\r\n\r\n    static getNameWithPostfix (name: string): string {\r\n        name = name.replace(/\\\\/g, '/');\r\n        const slashIndex = name.lastIndexOf('/') + 1;\r\n        const strLen = name.length;\r\n        return name.substring(slashIndex, strLen);\r\n    }\r\n\r\n    static getShortName (name: string): string {\r\n        name = name.replace(/\\\\/g, '/');\r\n        const slashIndex = name.lastIndexOf('/') + 1;\r\n        let dotIndex = name.lastIndexOf('.');\r\n        dotIndex = dotIndex < 0 ? name.length : dotIndex;\r\n        return name.substring(slashIndex, dotIndex);\r\n    }\r\n}\r\n","/*\r\n Copyright (c) 2013-2016 Chukong Technologies Inc.\r\n Copyright (c) 2017-2023 Xiamen Yaji Software Co., Ltd.\r\n\r\n https://www.cocos.com/\r\n\r\n Permission is hereby granted, free of charge, to any person obtaining a copy\r\n of this software and associated documentation files (the \"Software\"), to deal\r\n in the Software without restriction, including without limitation the rights to\r\n use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\r\n of the Software, and to permit persons to whom the Software is furnished to do so,\r\n subject to the following conditions:\r\n\r\n The above copyright notice and this permission notice shall be included in\r\n all copies or substantial portions of the Software.\r\n\r\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n THE SOFTWARE.\r\n*/\r\n\r\n/**\r\n * @en TiledTile can control the specified map tile.\r\n * It will apply the node rotation, scale, translate to the map tile.\r\n * You can change the TiledTile's gid to change the map tile's style.\r\n * @zh TiledTile 可以单独对某一个地图块进行操作。\r\n * 他会将节点的旋转，缩放，平移操作应用在这个地图块上，并可以通过更换当前地图块的 gid 来更换地图块的显示样式。\r\n * @class TiledTile\r\n * @extends Component\r\n */\r\n\r\nimport { ccclass, executeInEditMode, help, menu, requireComponent, type } from 'cc.decorator';\r\nimport { Component } from '../scene-graph/component';\r\nimport { TiledLayer } from './tiled-layer';\r\nimport { CCInteger, warn } from '../core';\r\nimport { UITransform } from '../2d/framework';\r\nimport { NodeEventType } from '../scene-graph/node-event';\r\n\r\n@ccclass('cc.TiledTile')\r\n@help('i18n:cc.TiledTile')\r\n@menu('TiledMap/TiledTile')\r\n@requireComponent(UITransform)\r\n@executeInEditMode\r\nexport class TiledTile extends Component {\r\n    _layer: TiledLayer | null = null;\r\n\r\n    constructor () {\r\n        super();\r\n    }\r\n\r\n    @type(CCInteger)\r\n    _x = 0;\r\n    @type(CCInteger)\r\n    _y = 0;\r\n\r\n    /**\r\n     * @en Specify the TiledTile horizontal coordinate，use map tile as the unit.\r\n     * @zh 指定 TiledTile 的横向坐标，以地图块为单位\r\n     * @property {Number} x\r\n     * @default 0\r\n     */\r\n\r\n    @type(CCInteger)\r\n    get x (): number {\r\n        return this._x;\r\n    }\r\n    set x (value) {\r\n        if (value === this._x) return;\r\n        if (this._layer && this._layer.isInvalidPosition(value, this._y)) {\r\n            warn(`Invalid x, the valid value is between [%s] ~ [%s]`, 0, this._layer.layerSize.width);\r\n            return;\r\n        }\r\n        this._resetTile();\r\n        this._x = value;\r\n        this.updateInfo();\r\n    }\r\n\r\n    /**\r\n     * @en Specify the TiledTile vertical coordinate，use map tile as the unit.\r\n     * @zh 指定 TiledTile 的纵向坐标，以地图块为单位\r\n     * @property {Number} y\r\n     * @default 0\r\n     */\r\n    @type(CCInteger)\r\n    get y (): number {\r\n        return this._y;\r\n    }\r\n    set y (value: number) {\r\n        if (value === this._y) return;\r\n        if (this._layer && this._layer.isInvalidPosition(this._x, value)) {\r\n            warn(`Invalid y, the valid value is between [%s] ~ [%s]`, 0, this._layer.layerSize.height);\r\n            return;\r\n        }\r\n        this._resetTile();\r\n        this._y = value;\r\n        this.updateInfo();\r\n    }\r\n    /**\r\n     * @en Specify the TiledTile gid.\r\n     * @zh 指定 TiledTile 的 gid 值\r\n     * @property {Number} gid\r\n     * @default 0\r\n     */\r\n    @type(CCInteger)\r\n    get grid (): number {\r\n        if (this._layer) {\r\n            return this._layer.getTileGIDAt(this._x, this._y) as unknown as number;\r\n        }\r\n        return 0;\r\n    }\r\n    set grid (value: number) {\r\n        if (this._layer) {\r\n            this._layer.setTileGIDAt(value, this._x, this._y);\r\n        }\r\n    }\r\n\r\n    onEnable (): void {\r\n        const parent = this.node.parent!;\r\n        this._layer = parent.getComponent('cc.TiledLayer') as TiledLayer;\r\n        this.node.on(NodeEventType.TRANSFORM_CHANGED, this._updatePosition, this);\r\n        this.node.on(NodeEventType.SIZE_CHANGED, this._updatePosition, this);\r\n        this._resetTile();\r\n        this.updateInfo();\r\n    }\r\n\r\n    onDisable (): void {\r\n        this._resetTile();\r\n        this.node.off(NodeEventType.TRANSFORM_CHANGED, this._updatePosition, this);\r\n        this.node.off(NodeEventType.SIZE_CHANGED, this._updatePosition, this);\r\n    }\r\n\r\n    private _resetTile (): void {\r\n        if (this._layer && this._layer.getTiledTileAt(this._x, this._y) === this) {\r\n            this._layer.setTiledTileAt(this._x, this._y, null);\r\n        }\r\n    }\r\n\r\n    public updateInfo (): void {\r\n        if (!this._layer) return;\r\n\r\n        const x = this._x;\r\n        const y = this._y;\r\n        if (this._layer.getTiledTileAt(x, y)) {\r\n            warn('There is already a TiledTile at [%s, %s]', x, y);\r\n            return;\r\n        }\r\n        const p = this._layer.getPositionAt(x, y);\r\n        this.node.setPosition(p!.x, p!.y);\r\n        this._layer.setTiledTileAt(x, y, this);\r\n        this._layer._markForUpdateRenderData();\r\n    }\r\n\r\n    private _updatePosition (): void {\r\n        this._layer!._markForUpdateRenderData();\r\n    }\r\n}\r\n","/*\r\n Copyright (c) 2020-2023 Xiamen Yaji Software Co., Ltd.\r\n\r\n https://www.cocos.com/\r\n\r\n Permission is hereby granted, free of charge, to any person obtaining a copy\r\n of this software and associated documentation files (the \"Software\"), to deal\r\n in the Software without restriction, including without limitation the rights to\r\n use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\r\n of the Software, and to permit persons to whom the Software is furnished to do so,\r\n subject to the following conditions:\r\n\r\n The above copyright notice and this permission notice shall be included in\r\n all copies or substantial portions of the Software.\r\n\r\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n THE SOFTWARE.\r\n*/\r\n\r\nimport { SpriteFrame } from '../2d/assets';\r\nimport { Texture2D } from '../asset/assets';\r\nimport { Rect } from '../core';\r\nimport { GID, TiledGrid, TiledTextureGrids, TMXTilesetInfo } from './tiled-types';\r\n\r\nlet _enableTexelOffset = false;\r\n\r\nexport function enableTexelOffsetUtils (enable: boolean): void {\r\n    _enableTexelOffset = enable;\r\n}\r\n\r\nexport function fillTextureGrids (tileset: TMXTilesetInfo, texGrids: TiledTextureGrids, spFrame?: SpriteFrame): void {\r\n    const spf: SpriteFrame = spFrame || tileset.sourceImage!;\r\n    const tex: Texture2D = spf.texture as Texture2D;\r\n\r\n    const collection = tileset.collection;\r\n\r\n    if (!tileset.imageSize.width || !tileset.imageSize.height) {\r\n        const sourceImage = tileset.sourceImage!;\r\n        tileset.imageSize.width = sourceImage.width;\r\n        tileset.imageSize.height = sourceImage.height;\r\n    }\r\n\r\n    const imageWidth = tileset.imageSize.width;\r\n    const imageHeight = tileset.imageSize.height;\r\n\r\n    const tw = tileset._tileSize.width;\r\n    const th = tileset._tileSize.height;\r\n    const texWidth = spf.width;\r\n    const texHeight = spf.height;\r\n    const spacing = tileset.spacing;\r\n    const margin = tileset.margin;\r\n\r\n    let count = 1;\r\n    if (!collection) {\r\n        const cols = Math.floor((imageWidth - margin * 2 + spacing) / (tw + spacing));\r\n        const rows = Math.floor((imageHeight - margin * 2 + spacing) / (th + spacing));\r\n        count = Math.max(1, rows * cols);\r\n    }\r\n\r\n    const firstGid = tileset.firstGid;\r\n    let grid: TiledGrid | null = null;\r\n    let override = !!texGrids.get(firstGid);\r\n\r\n    // Tiledmap may not be partitioned into blocks, resulting in a count value of 0\r\n\r\n    const maxGid = (tileset.firstGid as unknown as number) + count;\r\n    let gid = firstGid as unknown as number;\r\n    for (; gid < maxGid; ++gid) {\r\n        // Avoid overlapping\r\n        if (override && !texGrids.get(gid as unknown as GID)) {\r\n            override = false;\r\n        }\r\n        if (!override && texGrids.get(gid as unknown as GID)) {\r\n            break;\r\n        }\r\n\r\n        grid = {\r\n            tileset,\r\n            x: 0,\r\n            y: 0,\r\n            width: tw,\r\n            height: th,\r\n            t: 0,\r\n            l: 0,\r\n            r: 0,\r\n            b: 0,\r\n            cx: 0,\r\n            cy: 0,\r\n            offsetX: 0,\r\n            offsetY: 0,\r\n            rotated: false,\r\n            gid: gid as unknown as GID,\r\n            spriteFrame: spf,\r\n            texture: tex,\r\n        };\r\n\r\n        tileset.rectForGID(gid as unknown as GID, grid);\r\n\r\n        if (!spFrame || count > 1 || tileset.imageOffset) {\r\n            if (spFrame) {\r\n                grid._name = spFrame.name;\r\n                const lm = spFrame.unbiasUV[0];\r\n                const bm = spFrame.rotated ? spFrame.unbiasUV[1] : spFrame.unbiasUV[5];\r\n\r\n                if (_enableTexelOffset) {\r\n                    grid.l = lm + (grid.x + 0.5) / texWidth;\r\n                    grid.t = bm + (grid.y + 0.5) / texHeight;\r\n                    grid.r = lm + (grid.x + grid.width - 0.5) / texWidth;\r\n                    grid.b = bm + (grid.y + grid.height - 0.5) / texHeight;\r\n                } else {\r\n                    grid.l = lm + (grid.x) / texWidth;\r\n                    grid.t = bm + (grid.y) / texHeight;\r\n                    grid.r = lm + (grid.x + grid.width) / texWidth;\r\n                    grid.b = bm + (grid.y + grid.height) / texHeight;\r\n                }\r\n\r\n                grid._rect = new Rect(grid.x, grid.y, grid.width, grid.height);\r\n            } else {\r\n                grid.l = grid.x / texWidth;\r\n                grid.t = grid.y / texHeight;\r\n                grid.r = (grid.x + grid.width) / texWidth;\r\n                grid.b = (grid.y + grid.height) / texHeight;\r\n                grid._rect = new Rect(grid.x, grid.y, grid.width, grid.height);\r\n            }\r\n        } else if (spFrame.rotated) {\r\n            grid._rotated = true;\r\n            grid._name = spFrame.name;\r\n            grid._rect = spFrame.getRect();\r\n            grid.l = spFrame.unbiasUV[0];\r\n            grid.t = spFrame.unbiasUV[1];\r\n            grid.r = spFrame.unbiasUV[4];\r\n            grid.b = spFrame.unbiasUV[3];\r\n        } else {\r\n            grid._name = spFrame.name;\r\n            grid._rect = spFrame.getRect();\r\n            grid.l = spFrame.unbiasUV[0];\r\n            grid.t = spFrame.unbiasUV[5];\r\n            grid.r = spFrame.unbiasUV[2];\r\n            grid.b = spFrame.unbiasUV[1];\r\n        }\r\n        grid.cx = (grid.l + grid.r) / 2;\r\n        grid.cy = (grid.t + grid.b) / 2;\r\n\r\n        texGrids.set(gid as unknown as GID, grid);\r\n    }\r\n}\r\n","/* eslint-disable default-case */\r\n/*\r\n Copyright (c) 2013-2016 Chukong Technologies Inc.\r\n Copyright (c) 2017-2023 Xiamen Yaji Software Co., Ltd.\r\n\r\n https://www.cocos.com/\r\n\r\n Permission is hereby granted, free of charge, to any person obtaining a copy\r\n of this software and associated documentation files (the \"Software\"), to deal\r\n in the Software without restriction, including without limitation the rights to\r\n use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\r\n of the Software, and to permit persons to whom the Software is furnished to do so,\r\n subject to the following conditions:\r\n\r\n The above copyright notice and this permission notice shall be included in\r\n all copies or substantial portions of the Software.\r\n\r\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n THE SOFTWARE.\r\n*/\r\n\r\nimport { ccclass } from 'cc.decorator';\r\n\r\nimport { EDITOR_NOT_IN_PREVIEW } from 'internal:constants';\r\nimport { screenAdapter } from 'pal/screen-adapter';\r\nimport { UIRenderer } from '../2d/framework/ui-renderer';\r\nimport { SpriteFrame } from '../2d/assets/sprite-frame';\r\nimport { Component, Node } from '../scene-graph';\r\nimport { TMXMapInfo } from './tmx-xml-parser';\r\nimport { Color, IVec2Like, Mat4, Size, Vec2, Vec3, logID, warnID } from '../core';\r\nimport { TiledTile } from './tiled-tile';\r\nimport { RenderData } from '../2d/renderer/render-data';\r\nimport { IBatcher } from '../2d/renderer/i-batcher';\r\nimport {\r\n    MixedGID, GID, Orientation, TiledTextureGrids, TMXTilesetInfo, RenderOrder, StaggerAxis, StaggerIndex, TileFlag,\r\n    GIDFlags, TiledAnimationType, PropertiesInfo, TMXLayerInfo,\r\n} from './tiled-types';\r\nimport { fillTextureGrids } from './tiled-utils';\r\nimport { NodeEventType } from '../scene-graph/node-event';\r\nimport { RenderEntity, RenderEntityType } from '../2d/renderer/render-entity';\r\nimport { RenderDrawInfo, RenderDrawInfoType } from '../2d/renderer/render-draw-info';\r\nimport { Texture2D } from '../asset/assets';\r\nimport { director } from '../game';\r\nimport { Camera } from '../render-scene/scene';\r\nimport { View } from '../ui/view';\r\n\r\nconst _mat4_temp = new Mat4();\r\nconst _vec2_temp = new Vec2();\r\nconst _vec3_temp = new Vec3();\r\nconst _vec3_temp2 = new Vec3();\r\nconst _tempRowCol = { row: 0, col: 0 };\r\n\r\nfunction isTiledSubNodeData (data: TiledRenderData | TiledSubNodeData): data is TiledSubNodeData {\r\n    return 'subNodes' in data;\r\n}\r\n\r\n@ccclass('cc.TiledUserNodeData')\r\nexport class TiledUserNodeData extends Component {\r\n    _index = -1;\r\n    _row = -1;\r\n    _col = -1;\r\n    _tiledLayer: TiledLayer | null = null;\r\n    constructor () {\r\n        super();\r\n    }\r\n}\r\n\r\nexport interface TiledRenderData {\r\n    renderData: RenderData | null;\r\n    texture: Texture2D | null;\r\n}\r\n\r\ninterface TiledSubNodeData {\r\n    subNodes: (null | TiledUserNodeData)[];\r\n}\r\n\r\ntype TiledDataArray = (TiledRenderData | TiledSubNodeData)[];\r\n\r\nexport interface ITiledLayerCullingRect {\r\n    leftDown: {\r\n        row: number;\r\n        col: number;\r\n    };\r\n    rightTop: {\r\n        row: number;\r\n        col: number;\r\n    };\r\n}\r\n\r\n/**\r\n  * @en Render the TMX layer.\r\n  * @zh 渲染 TMX layer。\r\n  * @class TiledLayer\r\n  * @extends Component\r\n  */\r\n@ccclass('cc.TiledLayer')\r\nexport class TiledLayer extends UIRenderer {\r\n    // [row][col] = {count: 0, nodesList: []};\r\n    protected _userNodeGrid: SafeRecord<number, { count: number; } & SafeRecord<number, { count: number, list: (TiledUserNodeData | null)[] } >> = {};\r\n    protected _userNodeMap: { [key: string]: TiledUserNodeData } = {};// [id] = node;\r\n    protected _userNodeDirty = false;\r\n\r\n    // store the layer tiles node, index is caculated by 'x + width * y', format likes '[0]=tileNode0,[1]=tileNode1, ...'\r\n    public tiledTiles: (TiledTile | null)[] = [];\r\n\r\n    // // store the layer tilesets index array\r\n    // _tilesetIndexArr: number[] = [];\r\n    // // tileset index to array index\r\n    // _tilesetIndexToArrIndex: { [key: number]: number } = {};\r\n\r\n    protected _viewPort = { x: -1, y: -1, width: -1, height: -1 };\r\n    protected _cullingRect: ITiledLayerCullingRect = {\r\n        leftDown: { row: -1, col: -1 },\r\n        rightTop: { row: -1, col: -1 },\r\n    };\r\n    get cullingRect (): ITiledLayerCullingRect {\r\n        return this._cullingRect;\r\n    }\r\n\r\n    protected _cullingDirty = true;\r\n    protected _rightTop = { row: -1, col: -1 };\r\n    get rightTop (): {\r\n        row: number;\r\n        col: number;\r\n        } { return this._rightTop; }\r\n\r\n    protected _layerInfo: TMXLayerInfo | null = null;\r\n    protected _mapInfo: TMXMapInfo | null = null;\r\n\r\n    // record max or min tile texture offset,\r\n    // it will make culling rect more large, which insure culling rect correct.\r\n    protected _topOffset = 0;\r\n    protected _downOffset = 0;\r\n    protected _leftOffset = 0;\r\n    protected _rightOffset = 0;\r\n\r\n    // store the layer tiles, index is caculated by 'x + width * y', format likes '[0]=gid0,[1]=gid1, ...'\r\n    public tiles: MixedGID[] = [];\r\n\r\n    // vertex array\r\n    public vertices: SafeArray<{ minCol: number, maxCol: number } & SafeRecord<number, { left: number, bottom: number, index: number }>> = [];\r\n    // vertices dirty\r\n    protected _verticesDirty = true;\r\n\r\n    protected _layerName = '';\r\n    protected _layerSize?: Size;\r\n\r\n    get layerSize (): Size { return this._layerSize!; }\r\n\r\n    protected _minGID?: GID;\r\n    protected _maxGID?: GID;\r\n    protected _layerOrientation: null | Orientation = null;\r\n\r\n    protected _opacity?: number;\r\n    protected _tintColor?: Color;\r\n\r\n    // store all layer gid corresponding texture info, index is gid, format likes '[gid0]=tex-info,[gid1]=tex-info, ...'\r\n    public texGrids: TiledTextureGrids | null = null;\r\n    // store all tileset texture, index is tileset index, format likes '[0]=texture0, [1]=texture1, ...'\r\n    protected _textures: SpriteFrame[] = [];\r\n    protected _tilesets: TMXTilesetInfo[] = [];\r\n\r\n    protected _leftDownToCenterX = 0;\r\n    protected _leftDownToCenterY = 0;\r\n\r\n    protected _hasTiledNodeGrid = false;\r\n    protected _hasAniGrid = false;\r\n    protected _animations: TiledAnimationType | null = null;\r\n\r\n    // switch of culling\r\n    protected _enableCulling?: boolean;\r\n\r\n    public colorChanged = false;\r\n\r\n    protected _properties?: PropertiesInfo;\r\n    public renderOrder?: RenderOrder;\r\n    protected _staggerAxis?: StaggerAxis;\r\n    protected _staggerIndex?: StaggerIndex;\r\n    protected _hexSideLength?: number;\r\n\r\n    protected _mapTileSize?: Size;\r\n    protected _odd_even?: number;\r\n    protected _diffX1?: number;\r\n    protected _diffY1?: number;\r\n    protected _useAutomaticVertexZ?: boolean;\r\n    protected _vertexZvalue?: number;\r\n    protected _offset?: Vec2;\r\n\r\n    protected _tiledDataArray: TiledDataArray = [];\r\n\r\n    protected _cameraNode?: Node;\r\n\r\n    get tiledDataArray (): TiledDataArray { return this._tiledDataArray; }\r\n    get leftDownToCenterX (): number { return this._leftDownToCenterX; }\r\n    get leftDownToCenterY (): number { return this._leftDownToCenterY; }\r\n\r\n    private _drawInfoList: RenderDrawInfo[] = [];\r\n    private requestDrawInfo (idx: number): RenderDrawInfo {\r\n        if (!this._drawInfoList[idx]) {\r\n            this._drawInfoList[idx] = new RenderDrawInfo();\r\n            this._drawInfoList[idx].setDrawInfoType(RenderDrawInfoType.MIDDLEWARE);\r\n        }\r\n        return this._drawInfoList[idx];\r\n    }\r\n\r\n    constructor () {\r\n        super();\r\n    }\r\n\r\n    public hasTiledNode (): boolean {\r\n        return this._hasTiledNodeGrid;\r\n    }\r\n\r\n    public hasAnimation (): boolean {\r\n        return this._hasAniGrid;\r\n    }\r\n\r\n    /**\r\n      * @en enable or disable culling\r\n      * @zh 开启或关闭裁剪。\r\n      * @method enableCulling\r\n      * @param value\r\n      */\r\n    set enableCulling (value: boolean) {\r\n        if (this._enableCulling !== value) {\r\n            this._enableCulling = value;\r\n            this._cullingDirty = true;\r\n            this._markForUpdateRenderData();\r\n        }\r\n    }\r\n    get enableCulling (): boolean { return this._enableCulling!; }\r\n\r\n    /**\r\n      * @en Adds user's node into layer.\r\n      * @zh 添加用户节点。\r\n      * @method addUserNode\r\n      * @param {cc.Node} node\r\n      * @return {Boolean}\r\n      */\r\n    public addUserNode (node: Node): boolean {\r\n        let dataComp = node.getComponent(TiledUserNodeData);\r\n        if (dataComp) {\r\n            warnID(7242);\r\n            return false;\r\n        }\r\n\r\n        dataComp = node.addComponent(TiledUserNodeData);\r\n        node.parent = this.node;\r\n        this._userNodeMap[node.uuid] = dataComp;\r\n\r\n        dataComp._row = -1;\r\n        dataComp._col = -1;\r\n        dataComp._tiledLayer = this;\r\n\r\n        this._nodeLocalPosToLayerPos(node.getPosition(), _vec2_temp);\r\n        this._positionToRowCol(_vec2_temp.x, _vec2_temp.y, _tempRowCol);\r\n        this._addUserNodeToGrid(dataComp, _tempRowCol);\r\n        this._updateCullingOffsetByUserNode(node);\r\n        node.on(NodeEventType.TRANSFORM_CHANGED, this._userNodePosChange, dataComp);\r\n        node.on(NodeEventType.SIZE_CHANGED, this._userNodeSizeChange, dataComp);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n      * @en Removes user's node.\r\n      * @zh 移除用户节点。\r\n      * @method removeUserNode\r\n      * @param {cc.Node} node\r\n      * @return {Boolean}\r\n      */\r\n    public removeUserNode (node: Node): boolean {\r\n        const dataComp = node.getComponent(TiledUserNodeData);\r\n        if (!dataComp) {\r\n            warnID(7243);\r\n            return false;\r\n        }\r\n        node.off(NodeEventType.TRANSFORM_CHANGED, this._userNodePosChange, dataComp);\r\n        node.off(NodeEventType.SIZE_CHANGED, this._userNodeSizeChange, dataComp);\r\n        this._removeUserNodeFromGrid(dataComp);\r\n        delete this._userNodeMap[node.uuid];\r\n        node._removeComponent(dataComp);\r\n        dataComp.destroy();\r\n        node.removeFromParent();\r\n        // node._renderFlag &= ~RenderFlow.FLAG_BREAK_FLOW;\r\n        return true;\r\n    }\r\n\r\n    /**\r\n      * @en Destroy user's node.\r\n      * @zh 销毁用户节点。\r\n      * @method destroyUserNode\r\n      * @param {cc.Node} node\r\n      */\r\n    public destroyUserNode (node: Node): void {\r\n        this.removeUserNode(node);\r\n        node.destroy();\r\n    }\r\n\r\n    // acording layer anchor point to calculate node layer pos\r\n    protected _nodeLocalPosToLayerPos (nodePos: IVec2Like, out: IVec2Like): void {\r\n        out.x = nodePos.x + this._leftDownToCenterX;\r\n        out.y = nodePos.y + this._leftDownToCenterY;\r\n    }\r\n\r\n    public getNodesByRowCol (row: number, col: number): {\r\n        count: number;\r\n        list: (TiledUserNodeData | null)[];\r\n    } | null | undefined {\r\n        const rowData = this._userNodeGrid[row];\r\n        if (!rowData) return null;\r\n        return rowData[col];\r\n    }\r\n\r\n    public getNodesCountByRow (row): number {\r\n        const rowData = this._userNodeGrid[row];\r\n        if (!rowData) return 0;\r\n        return rowData.count;\r\n    }\r\n\r\n    protected _updateAllUserNode (): void {\r\n        this._userNodeGrid = {};\r\n        for (const dataId in this._userNodeMap) {\r\n            const dataComp = this._userNodeMap[dataId];\r\n            this._nodeLocalPosToLayerPos(dataComp.node.getPosition(), _vec2_temp);\r\n            this._positionToRowCol(_vec2_temp.x, _vec2_temp.y, _tempRowCol);\r\n            this._addUserNodeToGrid(dataComp, _tempRowCol);\r\n            this._updateCullingOffsetByUserNode(dataComp.node);\r\n        }\r\n    }\r\n\r\n    protected _updateCullingOffsetByUserNode (node_: Node): void {\r\n        const node = node_._getUITransformComp()!.contentSize;\r\n        if (this._topOffset < node.height) {\r\n            this._topOffset = node.height;\r\n        }\r\n        if (this._downOffset < node.height) {\r\n            this._downOffset = node.height;\r\n        }\r\n        if (this._leftOffset < node.width) {\r\n            this._leftOffset = node.width;\r\n        }\r\n        if (this._rightOffset < node.width) {\r\n            this._rightOffset = node.width;\r\n        }\r\n    }\r\n\r\n    protected _userNodeSizeChange (): void {\r\n        const dataComp: TiledUserNodeData = this as unknown as any;\r\n        const node = dataComp.node;\r\n        const self = dataComp._tiledLayer!;\r\n        self._updateCullingOffsetByUserNode(node);\r\n        self._userNodeDirty = true;\r\n        self._markForUpdateRenderData();\r\n    }\r\n\r\n    protected _userNodePosChange (): void {\r\n        const dataComp: TiledUserNodeData = this as unknown as any;\r\n        const node = dataComp.node;\r\n        const self = dataComp._tiledLayer!;\r\n        self._nodeLocalPosToLayerPos(node.getPosition(), _vec2_temp);\r\n        self._positionToRowCol(_vec2_temp.x, _vec2_temp.y, _tempRowCol);\r\n        self._limitInLayer(_tempRowCol);\r\n        // users pos not change\r\n        if (_tempRowCol.row === dataComp._row && _tempRowCol.col === dataComp._col) return;\r\n\r\n        self._removeUserNodeFromGrid(dataComp);\r\n        self._addUserNodeToGrid(dataComp, _tempRowCol);\r\n    }\r\n\r\n    protected _removeUserNodeFromGrid (dataComp: TiledUserNodeData): void {\r\n        const row = dataComp._row;\r\n        const col = dataComp._col;\r\n        const index = dataComp._index;\r\n\r\n        const rowData = this._userNodeGrid[row];\r\n        const colData = rowData && rowData[col];\r\n        if (colData) {\r\n            rowData.count--;\r\n            colData.count--;\r\n            colData.list[index] = null;\r\n            if (colData.count <= 0) {\r\n                colData.list.length = 0;\r\n                colData.count = 0;\r\n            }\r\n        }\r\n\r\n        dataComp._row = -1;\r\n        dataComp._col = -1;\r\n        dataComp._index = -1;\r\n        this._userNodeDirty = true;\r\n        this._markForUpdateRenderData();\r\n    }\r\n\r\n    protected _limitInLayer (rowCol: { row: number, col: number }): void {\r\n        const row = rowCol.row;\r\n        const col = rowCol.col;\r\n        if (row < 0) rowCol.row = 0;\r\n        if (row > this._rightTop.row) rowCol.row = this._rightTop.row;\r\n        if (col < 0) rowCol.col = 0;\r\n        if (col > this._rightTop.col) rowCol.col = this._rightTop.col;\r\n    }\r\n\r\n    protected _addUserNodeToGrid (dataComp: TiledUserNodeData, tempRowCol: { col: number, row: number }): void {\r\n        const row = tempRowCol.row;\r\n        const col = tempRowCol.col;\r\n        const rowData = this._userNodeGrid[row] = this._userNodeGrid[row] || { count: 0 };\r\n        const colData = rowData[col] = rowData[col] || { count: 0, list: [] };\r\n        dataComp._row = row;\r\n        dataComp._col = col;\r\n        dataComp._index = colData.list.length;\r\n        rowData.count++;\r\n        colData.count++;\r\n        colData.list.push(dataComp);\r\n        this._userNodeDirty = true;\r\n        this._markForUpdateRenderData();\r\n    }\r\n\r\n    public isUserNodeDirty (): boolean {\r\n        return this._userNodeDirty;\r\n    }\r\n\r\n    public setUserNodeDirty (value): void {\r\n        this._userNodeDirty = value;\r\n    }\r\n\r\n    protected _reinstallCamera (): Camera | null {\r\n        const camera = director.root!.batcher2D.getFirstRenderCamera(this.node);\r\n        const cameraNode = camera?.node;\r\n        if (this._cameraNode !== cameraNode) {\r\n            this._uninstallCamera();\r\n            if (cameraNode) {\r\n                cameraNode.on(NodeEventType.TRANSFORM_CHANGED, this.updateCulling, this);\r\n                cameraNode.on(NodeEventType.SIZE_CHANGED, this.updateCulling, this);\r\n                this._cameraNode = cameraNode;\r\n            }\r\n        }\r\n        return camera;\r\n    }\r\n\r\n    protected _uninstallCamera (): void {\r\n        if (this._cameraNode) {\r\n            this._cameraNode.off(NodeEventType.TRANSFORM_CHANGED, this.updateCulling, this);\r\n            this._cameraNode.off(NodeEventType.SIZE_CHANGED, this.updateCulling, this);\r\n            delete this._cameraNode;\r\n        }\r\n    }\r\n\r\n    onEnable (): void {\r\n        super.onEnable();\r\n        this.node.on(NodeEventType.ANCHOR_CHANGED, this._syncAnchorPoint, this);\r\n        this.node.on(NodeEventType.TRANSFORM_CHANGED, this.updateCulling, this);\r\n        this.node.on(NodeEventType.SIZE_CHANGED, this.updateCulling, this);\r\n        this.node.parent!.on(NodeEventType.TRANSFORM_CHANGED, this.updateCulling, this);\r\n        this.node.parent!.on(NodeEventType.SIZE_CHANGED, this.updateCulling, this);\r\n        View.instance.on('canvas-resize', this._resize, this);\r\n        screenAdapter.on('window-resize', this._resize, this);\r\n        this._markForUpdateRenderData();\r\n        // delay 1 frame, since camera's matrix data is dirty\r\n        this.scheduleOnce(this.updateCulling.bind(this));\r\n    }\r\n\r\n    onDisable (): void {\r\n        super.onDisable();\r\n        this.node.parent?.off(NodeEventType.SIZE_CHANGED, this.updateCulling, this);\r\n        this.node.parent?.off(NodeEventType.TRANSFORM_CHANGED, this.updateCulling, this);\r\n        this.node.off(NodeEventType.SIZE_CHANGED, this.updateCulling, this);\r\n        this.node.off(NodeEventType.TRANSFORM_CHANGED, this.updateCulling, this);\r\n        this.node.off(NodeEventType.ANCHOR_CHANGED, this._syncAnchorPoint, this);\r\n        View.instance.off('canvas-resize', this._resize, this);\r\n        screenAdapter.off('window-resize', this._resize, this);\r\n        this._uninstallCamera();\r\n    }\r\n\r\n    protected _syncAnchorPoint (): void {\r\n        const node = this.node;\r\n        const trans = node._getUITransformComp()!;\r\n        const scale = node.getScale();\r\n        this._leftDownToCenterX = trans.width * trans.anchorX * scale.x;\r\n        this._leftDownToCenterY = trans.height * trans.anchorY * scale.y;\r\n        this._cullingDirty = true;\r\n        this._markForUpdateRenderData();\r\n    }\r\n\r\n    protected _resize(): void {\r\n        this._markForUpdateRenderData();\r\n    }\r\n\r\n    /**\r\n      * @en Gets the layer name.\r\n      * @zh 获取层的名称。\r\n      * @method getLayerName\r\n      * @return {String}\r\n      * @example\r\n      * let layerName = tiledLayer.getLayerName();\r\n      * cc.log(layerName);\r\n      */\r\n    public getLayerName (): string {\r\n        return this._layerName;\r\n    }\r\n\r\n    /**\r\n      * @en Set the layer name.\r\n      * @zh 设置层的名称\r\n      * @method setLayerName\r\n      * @param {String} layerName\r\n      * @example\r\n      * tiledLayer.setLayerName(\"New Layer\");\r\n      */\r\n    public setLayerName (layerName: string): void {\r\n        this._layerName = layerName;\r\n    }\r\n\r\n    /**\r\n      * @en Return the value for the specific property name.\r\n      * @zh 获取指定属性名的值。\r\n      * @method getProperty\r\n      * @param {String} propertyName\r\n      * @return {*}\r\n      * @example\r\n      * let property = tiledLayer.getProperty(\"info\");\r\n      * cc.log(property);\r\n      */\r\n    public getProperty (propertyName: string): string | number {\r\n        return this._properties![propertyName];\r\n    }\r\n\r\n    /**\r\n      * @en Returns the position in pixels of a given tile coordinate.\r\n      * @zh 获取指定 tile 的像素坐标。\r\n      * @method getPositionAt\r\n      * @param {Vec2|Number} pos position or x\r\n      * @param {Number} [y]\r\n      * @return {Vec2}\r\n      * @example\r\n      * let pos = tiledLayer.getPositionAt(cc.v2(0, 0));\r\n      * cc.log(\"Pos: \" + pos);\r\n      * let pos = tiledLayer.getPositionAt(0, 0);\r\n      * cc.log(\"Pos: \" + pos);\r\n      */\r\n    public getPositionAt (pos: IVec2Like | number, y?: number): Vec2 | null {\r\n        let x: number;\r\n        if (y !== undefined) {\r\n            x = Math.floor(pos as number);\r\n            y = Math.floor(y);\r\n        } else {\r\n            x = Math.floor((pos as IVec2Like).x);\r\n            y = Math.floor((pos as IVec2Like).y);\r\n        }\r\n\r\n        switch (this._layerOrientation) {\r\n        case Orientation.ORTHO:\r\n            return this._positionForOrthoAt(x, y);\r\n        case Orientation.ISO:\r\n            return this._positionForIsoAt(x, y);\r\n        case Orientation.HEX:\r\n            return this._positionForHexAt(x, y);\r\n        }\r\n        return null;\r\n    }\r\n\r\n    public isInvalidPosition (x: number, y: number): boolean {\r\n        return x >= this._layerSize!.width || y >= this._layerSize!.height || x < 0 || y < 0;\r\n    }\r\n\r\n    protected _positionForIsoAt (x: number, y: number): Vec2 {\r\n        let offsetX = 0;\r\n        let offsetY = 0;\r\n        const index = Math.floor(x) + Math.floor(y) * this._layerSize!.width;\r\n        const gidAndFlags = this.tiles[index];\r\n        if (gidAndFlags) {\r\n            const gid = (((gidAndFlags as unknown as number) & TileFlag.FLIPPED_MASK) >>> 0);\r\n            const tileset = this.texGrids!.get(gid as unknown as GID)!.tileset;\r\n            const offset = tileset.tileOffset;\r\n            offsetX = offset.x;\r\n            offsetY = offset.y;\r\n        }\r\n\r\n        return new Vec2(\r\n            this._mapTileSize!.width * 0.5 * (this._layerSize!.height + x - y - 1) + offsetX,\r\n            this._mapTileSize!.height * 0.5 * (this._layerSize!.width - x + this._layerSize!.height - y - 2) - offsetY,\r\n        );\r\n    }\r\n\r\n    protected _positionForOrthoAt (x: number, y: number): Vec2 {\r\n        let offsetX = 0;\r\n        let offsetY = 0;\r\n        const index = Math.floor(x) + Math.floor(y) * this._layerSize!.width;\r\n        const gidAndFlags = this.tiles[index];\r\n        if (gidAndFlags) {\r\n            const gid = (((gidAndFlags as unknown as number) & TileFlag.FLIPPED_MASK) >>> 0) as unknown as GID;\r\n            const tileset = this.texGrids!.get(gid)!.tileset;\r\n            const offset = tileset.tileOffset;\r\n            offsetX = offset.x;\r\n            offsetY = offset.y;\r\n        }\r\n\r\n        return new Vec2(\r\n            x * this._mapTileSize!.width + offsetX,\r\n            (this._layerSize!.height - y - 1) * this._mapTileSize!.height - offsetY,\r\n        );\r\n    }\r\n\r\n    protected _positionForHexAt (col: number, row: number): Vec2 {\r\n        const tileWidth = this._mapTileSize!.width;\r\n        const tileHeight = this._mapTileSize!.height;\r\n        const rows = this._layerSize!.height;\r\n\r\n        const index = Math.floor(col) + Math.floor(row) * this._layerSize!.width;\r\n        const gid = ((this.tiles[index] as unknown as number) & TileFlag.FLIPPED_MASK) >>> 0;\r\n        let offset: IVec2Like;\r\n        if (this.texGrids!.get(gid as unknown as GID)) {\r\n            offset = this.texGrids!.get(gid as unknown as GID)!.tileset.tileOffset;\r\n        } else {\r\n            offset = { x: 0, y: 0 };\r\n        }\r\n\r\n        const odd_even = (this._staggerIndex === StaggerIndex.STAGGERINDEX_ODD) ? 1 : -1;\r\n        let x = 0;\r\n        let y = 0;\r\n        let diffX = 0;\r\n        let diffY = 0;\r\n        switch (this._staggerAxis) {\r\n        case StaggerAxis.STAGGERAXIS_Y:\r\n            diffX = 0;\r\n            if (row % 2 === 1) {\r\n                diffX = tileWidth / 2 * odd_even;\r\n            }\r\n            x = col * tileWidth + diffX + offset.x;\r\n            y = (rows - row - 1) * (tileHeight - (tileHeight - this._hexSideLength!) / 2) - offset.y;\r\n            break;\r\n        case StaggerAxis.STAGGERAXIS_X:\r\n            diffY = 0;\r\n            if (col % 2 === 1) {\r\n                diffY = tileHeight / 2 * -odd_even;\r\n            }\r\n            x = col * (tileWidth - (tileWidth - this._hexSideLength!) / 2) + offset.x;\r\n            y = (rows - row - 1) * tileHeight + diffY - offset.y;\r\n            break;\r\n        }\r\n        return new Vec2(x, y);\r\n    }\r\n\r\n    /**\r\n      * @en\r\n      * Sets the tiles gid (gid = tile global id) at a given tiles rect.\r\n      * @zh\r\n      * 设置给定区域的 tile 的 gid (gid = tile 全局 id)，\r\n      * @method setTilesGIDAt\r\n      * @param {Array} gids an array contains gid\r\n      * @param {Number} beginCol begin col number\r\n      * @param {Number} beginRow begin row number\r\n      * @param {Number} totalCols count of column\r\n      * @example\r\n      * tiledLayer.setTilesGIDAt([1, 1, 1, 1], 10, 10, 2)\r\n      */\r\n    public setTilesGIDAt (gids: number[], beginCol: number, beginRow: number, totalCols: number): void {\r\n        if (!gids || gids.length === 0 || totalCols <= 0) return;\r\n        if (beginRow < 0) beginRow = 0;\r\n        if (beginCol < 0) beginCol = 0;\r\n        let gidsIdx = 0;\r\n        const endCol = beginCol + totalCols;\r\n        for (let row = beginRow; ; row++) {\r\n            for (let col = beginCol; col < endCol; col++) {\r\n                if (gidsIdx >= gids.length) return;\r\n                this._updateTileForGID(gids[gidsIdx] as unknown as MixedGID, col, row);\r\n                gidsIdx++;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n      * @en\r\n      * Sets the tile gid (gid = tile global id) at a given tile coordinate.<br />\r\n      * The Tile GID can be obtained by using the method \"tileGIDAt\" or by using the TMX editor . Tileset Mgr +1.<br />\r\n      * If a tile is already placed at that position, then it will be removed.\r\n      * @zh\r\n      * 设置给定坐标的 tile 的 gid (gid = tile 全局 id)，\r\n      * tile 的 GID 可以使用方法 “tileGIDAt” 来获得。<br />\r\n      * 如果一个 tile 已经放在那个位置，那么它将被删除。\r\n      * @method setTileGIDAt\r\n      * @param {Number} gid\r\n      * @param {Vec2|Number} posOrX position or x\r\n      * @param {Number} flagsOrY flags or y\r\n      * @param {Number} [flags]\r\n      * @example\r\n      * tiledLayer.setTileGIDAt(1001, 10, 10, 1)\r\n      */\r\n    public setTileGIDAt (gid: MixedGID, x: number, y: number, flags?: number): void {\r\n        const ugid = (gid & TileFlag.FLIPPED_MASK) >>> 0;\r\n\r\n        x = Math.floor(x);\r\n        y = Math.floor(y);\r\n        if (this.isInvalidPosition(x, y)) {\r\n            throw new Error('cc.TiledLayer.setTileGIDAt(): invalid position');\r\n        }\r\n        if (!this.tiles || !this._tilesets || this._tilesets.length === 0) {\r\n            logID(7238);\r\n            return;\r\n        }\r\n        if (ugid !== 0 && ugid < this._tilesets[0].firstGid) {\r\n            logID(7239, gid);\r\n            return;\r\n        }\r\n\r\n        flags = flags || 0;\r\n        this._updateTileForGID(((ugid | flags) >>> 0) as unknown as MixedGID, x, y);\r\n    }\r\n\r\n    protected _updateTileForGID (gidAndFlags: MixedGID, x: number, y: number): void {\r\n        const idx = 0 | (x + y * this._layerSize!.width);\r\n        if (idx >= this.tiles.length) return;\r\n\r\n        const oldGIDAndFlags = this.tiles[idx];\r\n        if (gidAndFlags === oldGIDAndFlags) return;\r\n\r\n        const gid = ((gidAndFlags & TileFlag.FLIPPED_MASK) >>> 0);\r\n        const grid = this.texGrids!.get(gid);\r\n\r\n        if (grid) {\r\n            this.tiles[idx] = gidAndFlags;\r\n            this._updateVertex(x, y);\r\n        } else {\r\n            this.tiles[idx] = 0;\r\n        }\r\n        this._cullingDirty = true;\r\n    }\r\n\r\n    /**\r\n      * @en\r\n      * Returns the tile gid at a given tile coordinate. <br />\r\n      * if it returns 0, it means that the tile is empty. <br />\r\n      * @zh\r\n      * 通过给定的 tile 坐标、flags（可选）返回 tile 的 GID. <br />\r\n      * 如果它返回 0，则表示该 tile 为空。<br />\r\n      * @method getTileGIDAt\r\n      * @param {Vec2} pos\r\n      * @return {Number}\r\n      * @example\r\n      * let tileGid = tiledLayer.getTileGIDAt(0, 0);\r\n      */\r\n    public getTileGIDAt (x: number, y: number): number | null {\r\n        if (this.isInvalidPosition(x, y)) {\r\n            throw new Error('cc.TiledLayer.getTileGIDAt(): invalid position');\r\n        }\r\n        if (!this.tiles) {\r\n            logID(7237);\r\n            return null;\r\n        }\r\n\r\n        const index = Math.floor(x) + Math.floor(y) * this._layerSize!.width;\r\n        // Bits on the far end of the 32-bit global tile ID are used for tile flags\r\n        const tile = this.tiles[index] as unknown as number;\r\n\r\n        return ((tile & TileFlag.FLIPPED_MASK) >>> 0);\r\n    }\r\n    /**\r\n      * @en\r\n      * Returns the tile flags at a given tile coordinate. <br />\r\n      * @zh\r\n      * 通过给定的 tile 坐标, 返回 tile 的 flags. <br />\r\n      * 如果它返回 null，则表示该 tile 为空。<br />\r\n      * @method getTileGIDAt\r\n      * @param {number}} x\r\n      * @param {number}} y\r\n      * @return {Number}\r\n      * @example\r\n      * let tileGid = tiledLayer.getTileGIDAt(0, 0);\r\n      */\r\n    public getTileFlagsAt (x: number, y: number): number | null {\r\n        if (this.isInvalidPosition(x, y)) {\r\n            throw new Error('TiledLayer.getTileFlagsAt: invalid position');\r\n        }\r\n        if (!this.tiles) {\r\n            logID(7240);\r\n            return null;\r\n        }\r\n\r\n        const idx = Math.floor(x) + Math.floor(y) * this._layerSize!.width;\r\n        // Bits on the far end of the 32-bit global tile ID are used for tile flags\r\n        const tile = this.tiles[idx] as unknown as number;\r\n\r\n        return ((tile & TileFlag.FLIPPED_ALL) >>> 0) as unknown as GIDFlags;\r\n    }\r\n\r\n    public setCullingDirty (value: boolean): void {\r\n        this._cullingDirty = value;\r\n    }\r\n\r\n    public isCullingDirty (): boolean {\r\n        return this._cullingDirty;\r\n    }\r\n\r\n    // 'x, y' is the position of viewPort, which's anchor point is at the center of rect.\r\n    // 'width, height' is the size of viewPort.\r\n    public updateViewPort (x: number, y: number, width: number, height: number): void {\r\n        if (this._viewPort.width === width\r\n             && this._viewPort.height === height\r\n             && this._viewPort.x === x\r\n             && this._viewPort.y === y) {\r\n            return;\r\n        }\r\n        this._viewPort.x = x;\r\n        this._viewPort.y = y;\r\n        this._viewPort.width = width;\r\n        this._viewPort.height = height;\r\n\r\n        // if map's type is iso, reserve bottom line is 2 to avoid show empty grid because of iso grid arithmetic\r\n        let reserveLine = 1;\r\n        if (this._layerOrientation === Orientation.ISO) {\r\n            reserveLine = 2;\r\n        }\r\n\r\n        const vpx = this._viewPort.x - this._offset!.x + this._leftDownToCenterX;\r\n        const vpy = this._viewPort.y - this._offset!.y + this._leftDownToCenterY;\r\n\r\n        let leftDownX = vpx - this._leftOffset;\r\n        let leftDownY = vpy - this._downOffset;\r\n        const rightTopX = vpx + width + this._rightOffset;\r\n        const rightTopY = vpy + height + this._topOffset;\r\n\r\n        const leftDown = this._cullingRect.leftDown;\r\n        const rightTop = this._cullingRect.rightTop;\r\n\r\n        if (leftDownX < 0) leftDownX = 0;\r\n        if (leftDownY < 0) leftDownY = 0;\r\n\r\n        // calc left down\r\n        this._positionToRowCol(leftDownX, leftDownY, _tempRowCol);\r\n        // make range large\r\n        _tempRowCol.row -= reserveLine;\r\n        _tempRowCol.col -= reserveLine;\r\n        // insure left down row col greater than 0\r\n        _tempRowCol.row = _tempRowCol.row > 0 ? _tempRowCol.row : 0;\r\n        _tempRowCol.col = _tempRowCol.col > 0 ? _tempRowCol.col : 0;\r\n\r\n        if (_tempRowCol.row !== leftDown.row || _tempRowCol.col !== leftDown.col) {\r\n            leftDown.row = _tempRowCol.row;\r\n            leftDown.col = _tempRowCol.col;\r\n            this._cullingDirty = true;\r\n        }\r\n\r\n        // show nothing\r\n        if (rightTopX < 0 || rightTopY < 0) {\r\n            _tempRowCol.row = -1;\r\n            _tempRowCol.col = -1;\r\n        } else {\r\n            // calc right top\r\n            this._positionToRowCol(rightTopX, rightTopY, _tempRowCol);\r\n            // make range large\r\n            _tempRowCol.row++;\r\n            _tempRowCol.col++;\r\n        }\r\n\r\n        if (_tempRowCol.row !== rightTop.row || _tempRowCol.col !== rightTop.col) {\r\n            rightTop.row = _tempRowCol.row;\r\n            rightTop.col = _tempRowCol.col;\r\n            this._cullingDirty = true;\r\n        }\r\n\r\n        if (this._cullingDirty) this._markForUpdateRenderData();\r\n    }\r\n\r\n    // the result may not precise, but it dose't matter, it just uses to be got range\r\n    protected _positionToRowCol (x: number, y: number, result: { col: number, row: number }): { col: number, row: number } {\r\n        const maptw = this._mapTileSize!.width;\r\n        const mapth = this._mapTileSize!.height;\r\n        const maptw2 = maptw * 0.5;\r\n        const mapth2 = mapth * 0.5;\r\n        let row = 0;\r\n        let col = 0;\r\n        let diffX2 = 0;\r\n        let diffY2 = 0;\r\n        const axis = this._staggerAxis;\r\n\r\n        switch (this._layerOrientation) {\r\n        // left top to right dowm\r\n        case Orientation.ORTHO:\r\n            col = Math.floor(x / maptw);\r\n            row = Math.floor(y / mapth);\r\n            break;\r\n            // right top to left down\r\n            // iso can be treat as special hex whose hex side length is 0\r\n        case Orientation.ISO:\r\n            col = Math.floor(x / maptw2);\r\n            row = Math.floor(y / mapth2);\r\n            break;\r\n            // left top to right dowm\r\n        case Orientation.HEX:\r\n            if (axis === StaggerAxis.STAGGERAXIS_Y) {\r\n                row = Math.floor(y / (mapth - this._diffY1!));\r\n                diffX2 = row % 2 === 1 ? maptw2 * this._odd_even! : 0;\r\n                col = Math.floor((x - diffX2) / maptw);\r\n            } else {\r\n                col = Math.floor(x / (maptw - this._diffX1!));\r\n                diffY2 = col % 2 === 1 ? mapth2 * -this._odd_even! : 0;\r\n                row = Math.floor((y - diffY2) / mapth);\r\n            }\r\n            break;\r\n        }\r\n        result.row = row;\r\n        result.col = col;\r\n        return result;\r\n    }\r\n\r\n    public updateCulling (): void {\r\n        if (EDITOR_NOT_IN_PREVIEW) {\r\n            this.enableCulling = false;\r\n        } else if (this._enableCulling) {\r\n            this.node.updateWorldTransform();\r\n            Mat4.invert(_mat4_temp, this.node.getWorldMatrix());\r\n            const camera = this._reinstallCamera(); // developer should call updateCalling if the camera has changed\r\n            if (camera) {\r\n                _vec3_temp.x = 0;\r\n                _vec3_temp.y = 0;\r\n                _vec3_temp.z = 0;\r\n                _vec3_temp2.x = camera.width;\r\n                _vec3_temp2.y = camera.height;\r\n                _vec3_temp2.z = 0;\r\n                camera.screenToWorld(_vec3_temp, _vec3_temp);\r\n                camera.screenToWorld(_vec3_temp2, _vec3_temp2);\r\n                // camera.getScreenToWorldPoint(_vec2_temp, _vec2_temp);\r\n                // camera.getScreenToWorldPoint(_vec2_temp2, _vec2_temp2);\r\n                Vec3.transformMat4(_vec3_temp, _vec3_temp, _mat4_temp);\r\n                Vec3.transformMat4(_vec3_temp2, _vec3_temp2, _mat4_temp);\r\n                this.updateViewPort(_vec3_temp.x, _vec3_temp.y, _vec3_temp2.x - _vec3_temp.x, _vec3_temp2.y - _vec3_temp.y);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n      * @en Layer orientation, which is the same as the map orientation.\r\n      * @zh 获取 Layer 方向(同地图方向)。\r\n      * @method getLayerOrientation\r\n      * @return {Number}\r\n      * @example\r\n      * let orientation = tiledLayer.getLayerOrientation();\r\n      * cc.log(\"Layer Orientation: \" + orientation);\r\n      */\r\n    public getLayerOrientation (): Orientation | null {\r\n        return this._layerOrientation;\r\n    }\r\n\r\n    /**\r\n      * @en properties from the layer. They can be added using Tiled.\r\n      * @zh 获取 layer 的属性，可以使用 Tiled 编辑器添加属性。\r\n      * @method getProperties\r\n      * @return {Object}\r\n      * @example\r\n      * let properties = tiledLayer.getProperties();\r\n      * cc.log(\"Properties: \" + properties);\r\n      */\r\n    public getProperties (): PropertiesInfo | undefined {\r\n        return this._properties;\r\n    }\r\n\r\n    protected _updateVertex (col: number, row: number): void {\r\n        const FLIPPED_MASK = TileFlag.FLIPPED_MASK;\r\n\r\n        const vertices = this.vertices;\r\n\r\n        const layerOrientation = this._layerOrientation;\r\n        const tiles = this.tiles;\r\n\r\n        if (!tiles) {\r\n            return;\r\n        }\r\n\r\n        const rightTop = this._rightTop;\r\n        const maptw = this._mapTileSize!.width;\r\n        const mapth = this._mapTileSize!.height;\r\n        const maptw2 = maptw * 0.5;\r\n        const mapth2 = mapth * 0.5;\r\n        const rows = this._layerSize!.height;\r\n        const cols = this._layerSize!.width;\r\n        const grids = this.texGrids!;\r\n\r\n        let left = 0;\r\n        let bottom = 0;\r\n        let axis: StaggerAxis;\r\n        let diffX1: number;\r\n        let diffY1: number;\r\n        let odd_even: number;\r\n        let diffX2: number;\r\n        let diffY2: number;\r\n\r\n        if (layerOrientation === Orientation.HEX) {\r\n            axis = this._staggerAxis!;\r\n            diffX1 = this._diffX1!;\r\n            diffY1 = this._diffY1!;\r\n            odd_even = this._odd_even!;\r\n        }\r\n\r\n        let cullingCol = 0;\r\n        let cullingRow = 0;\r\n        let gridGID: GID = 0 as unknown as GID;\r\n\r\n        // grid border\r\n        let topBorder = 0;\r\n        let downBorder = 0; let leftBorder = 0;\r\n        let rightBorder = 0;\r\n        const index = row * cols + col;\r\n        const gid = tiles[index];\r\n        gridGID = (((gid as unknown as number) & FLIPPED_MASK) >>> 0) as unknown as GID;\r\n        const grid = grids.get(gridGID)!;\r\n        if (!grid) {\r\n            return;\r\n        }\r\n\r\n        // if has animation, grid must be updated per frame\r\n        if (this._animations!.get(gridGID)) {\r\n            this._hasAniGrid = this._hasAniGrid || true;\r\n        }\r\n\r\n        switch (layerOrientation) {\r\n        // left top to right dowm\r\n        case Orientation.ORTHO:\r\n            cullingCol = col;\r\n            cullingRow = rows - row - 1;\r\n            left = cullingCol * maptw;\r\n            bottom = cullingRow * mapth;\r\n            break;\r\n            // right top to left down\r\n        case Orientation.ISO:\r\n            // if not consider about col, then left is 'w/2 * (rows - row - 1)'\r\n            // if consider about col then left must add 'w/2 * col'\r\n            // so left is 'w/2 * (rows - row - 1) + w/2 * col'\r\n            // combine expression is 'w/2 * (rows - row + col -1)'\r\n            cullingCol = rows + col - row - 1;\r\n            // if not consider about row, then bottom is 'h/2 * (cols - col -1)'\r\n            // if consider about row then bottom must add 'h/2 * (rows - row - 1)'\r\n            // so bottom is 'h/2 * (cols - col -1) + h/2 * (rows - row - 1)'\r\n            // combine expressionn is 'h/2 * (rows + cols - col - row - 2)'\r\n            cullingRow = rows + cols - col - row - 2;\r\n            left = maptw2 * cullingCol;\r\n            bottom = mapth2 * cullingRow;\r\n            break;\r\n            // left top to right dowm\r\n        case Orientation.HEX:\r\n            diffX2 = (axis! === StaggerAxis.STAGGERAXIS_Y && row % 2 === 1) ? maptw2 * odd_even! : 0;\r\n            diffY2 = (axis! === StaggerAxis.STAGGERAXIS_X && col % 2 === 1) ? mapth2 * -odd_even! : 0;\r\n\r\n            left = col * (maptw - diffX1!) + diffX2;\r\n            bottom = (rows - row - 1) * (mapth - diffY1!) + diffY2;\r\n            cullingCol = col;\r\n            cullingRow = rows - row - 1;\r\n            break;\r\n        }\r\n\r\n        const rowData = vertices[cullingRow] = vertices[cullingRow] || { minCol: 0, maxCol: 0 };\r\n        const colData = rowData[cullingCol] = rowData[cullingCol] || { left: 0, bottom: 0, index: 0 };\r\n\r\n        // record each row range, it will faster when culling grid\r\n        if (rowData.minCol > cullingCol) {\r\n            rowData.minCol = cullingCol;\r\n        }\r\n\r\n        if (rowData.maxCol < cullingCol) {\r\n            rowData.maxCol = cullingCol;\r\n        }\r\n\r\n        // record max rect, when viewPort is bigger than layer, can make it smaller\r\n        if (rightTop.row < cullingRow) {\r\n            rightTop.row = cullingRow;\r\n            if (layerOrientation === Orientation.ISO) {\r\n                rightTop.row += 1;\r\n            }\r\n        }\r\n\r\n        if (rightTop.col < cullingCol) {\r\n            rightTop.col = cullingCol;\r\n            if (layerOrientation === Orientation.ISO) {\r\n                rightTop.col += 1;\r\n            }\r\n        }\r\n\r\n        // _offset is whole layer offset\r\n        // tileOffset is tileset offset which is related to each grid\r\n        // tileOffset coordinate system's y axis is opposite with engine's y axis.\r\n        const tileOffset = grid.tileset.tileOffset;\r\n        left += this._offset!.x + tileOffset.x + grid.offsetX;\r\n        bottom += this._offset!.y - tileOffset.y - grid.offsetY;\r\n\r\n        topBorder = -tileOffset.y + grid.tileset._tileSize.height - mapth;\r\n        topBorder = topBorder < 0 ? 0 : topBorder;\r\n        downBorder = tileOffset.y < 0 ? 0 : tileOffset.y;\r\n        leftBorder = -tileOffset.x < 0 ? 0 : -tileOffset.x;\r\n        rightBorder = tileOffset.x + grid.tileset._tileSize.width - maptw;\r\n        rightBorder = rightBorder < 0 ? 0 : rightBorder;\r\n\r\n        if (this._rightOffset < leftBorder) {\r\n            this._rightOffset = leftBorder;\r\n        }\r\n\r\n        if (this._leftOffset < rightBorder) {\r\n            this._leftOffset = rightBorder;\r\n        }\r\n\r\n        if (this._topOffset < downBorder) {\r\n            this._topOffset = downBorder;\r\n        }\r\n\r\n        if (this._downOffset < topBorder) {\r\n            this._downOffset = topBorder;\r\n        }\r\n\r\n        colData.left = left;\r\n        colData.bottom = bottom;\r\n        // this index is tiledmap grid index\r\n        colData.index = index;\r\n\r\n        this._cullingDirty = true;\r\n    }\r\n\r\n    protected _updateVertices (): void {\r\n        const vertices = this.vertices;\r\n        vertices.length = 0;\r\n\r\n        const tiles = this.tiles;\r\n        if (!tiles) {\r\n            return;\r\n        }\r\n\r\n        const rightTop = this._rightTop;\r\n        rightTop.row = -1;\r\n        rightTop.col = -1;\r\n\r\n        const rows = this._layerSize!.height;\r\n        const cols = this._layerSize!.width;\r\n\r\n        this._topOffset = 0;\r\n        this._downOffset = 0;\r\n        this._leftOffset = 0;\r\n        this._rightOffset = 0;\r\n        this._hasAniGrid = false;\r\n\r\n        for (let row = 0; row < rows; ++row) {\r\n            for (let col = 0; col < cols; ++col) {\r\n                this._updateVertex(col, row);\r\n            }\r\n        }\r\n        this._verticesDirty = false;\r\n    }\r\n\r\n    /**\r\n      * @en\r\n      * Get the TiledTile with the tile coordinate.<br/>\r\n      * If there is no tile in the specified coordinate and forceCreate parameter is true, <br/>\r\n      * then will create a new TiledTile at the coordinate.\r\n      * The renderer will render the tile with the rotation, scale, position and color property of the TiledTile.\r\n      * @zh\r\n      * 通过指定的 tile 坐标获取对应的 TiledTile。 <br/>\r\n      * 如果指定的坐标没有 tile，并且设置了 forceCreate 那么将会在指定的坐标创建一个新的 TiledTile 。<br/>\r\n      * 在渲染这个 tile 的时候，将会使用 TiledTile 的节点的旋转、缩放、位移、颜色属性。<br/>\r\n      * @method getTiledTileAt\r\n      * @param {Integer} x\r\n      * @param {Integer} y\r\n      * @param {Boolean} forceCreate\r\n      * @return {cc.TiledTile}\r\n      * @example\r\n      * let tile = tiledLayer.getTiledTileAt(100, 100, true);\r\n      * cc.log(tile);\r\n      */\r\n    public getTiledTileAt (x: number, y: number, forceCreate?: boolean): TiledTile | null {\r\n        if (this.isInvalidPosition(x, y)) {\r\n            throw new Error('TiledLayer.getTiledTileAt: invalid position');\r\n        }\r\n        if (!this.tiles) {\r\n            logID(7236);\r\n            return null;\r\n        }\r\n\r\n        const index = Math.floor(x) + Math.floor(y) * this._layerSize!.width;\r\n        let tile = this.tiledTiles[index];\r\n        if (!tile && forceCreate) {\r\n            const node = new Node();\r\n            tile = node.addComponent(TiledTile);\r\n            tile._x = x;\r\n            tile._y = y;\r\n            tile._layer = this;\r\n            tile.updateInfo();\r\n            node.parent = this.node;\r\n            return tile;\r\n        }\r\n        return tile;\r\n    }\r\n\r\n    /**\r\n      * @en\r\n      * Change tile to TiledTile at the specified coordinate.\r\n      * @zh\r\n      * 将指定的 tile 坐标替换为指定的 TiledTile。\r\n      * @method setTiledTileAt\r\n      * @param {Integer} x\r\n      * @param {Integer} y\r\n      * @param {cc.TiledTile} tiledTile\r\n      * @return {cc.TiledTile}\r\n      */\r\n    public setTiledTileAt (x: number, y: number, tiledTile: TiledTile | null): TiledTile | null {\r\n        if (this.isInvalidPosition(x, y)) {\r\n            throw new Error('TiledLayer.setTiledTileAt: invalid position');\r\n        }\r\n        if (!this.tiles) {\r\n            logID(7236);\r\n            return null;\r\n        }\r\n\r\n        const index = Math.floor(x) + Math.floor(y) * this._layerSize!.width;\r\n        this.tiledTiles[index] = tiledTile;\r\n        this._cullingDirty = true;\r\n\r\n        if (tiledTile) {\r\n            this._hasTiledNodeGrid = true;\r\n        } else {\r\n            this._hasTiledNodeGrid = this.tiledTiles.some((tiledNode) => !!tiledNode);\r\n        }\r\n\r\n        return tiledTile;\r\n    }\r\n\r\n    /**\r\n      * @en Return texture.\r\n      * @zh 获取纹理。\r\n      * @method getTexture\r\n      * @param index The index of textures\r\n      * @return {Texture2D}\r\n      */\r\n    public getTexture (index?: number): SpriteFrame | null {\r\n        index = index || 0;\r\n        if (this._textures && index >= 0 && this._textures.length > index) {\r\n            return this._textures[index];\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n      * @en Return texture.\r\n      * @zh 获取纹理。\r\n      * @method getTextures\r\n      * @return {Texture2D}\r\n      */\r\n    public getTextures (): SpriteFrame[] {\r\n        return this._textures;\r\n    }\r\n\r\n    /**\r\n      * @en Set the texture.\r\n      * @zh 设置纹理。\r\n      * @method setTexture\r\n      * @param {SpriteFrame} texture\r\n      */\r\n    public setTexture (texture: SpriteFrame): void {\r\n        this.setTextures([texture]);\r\n    }\r\n\r\n    /**\r\n      * @en Set the texture.\r\n      * @zh 设置纹理。\r\n      * @method setTexture\r\n      * @param {SpriteFrame} textures\r\n      */\r\n    public setTextures (textures: SpriteFrame[]): void {\r\n        this._textures = textures;\r\n        this._markForUpdateRenderData();\r\n    }\r\n\r\n    /**\r\n      * @en Gets layer size.\r\n      * @zh 获得层大小。\r\n      * @method getLayerSize\r\n      * @return {Size}\r\n      * @example\r\n      * let size = tiledLayer.getLayerSize();\r\n      * cc.log(\"layer size: \" + size);\r\n      */\r\n    public getLayerSize (): Size {\r\n        return this._layerSize!;\r\n    }\r\n\r\n    /**\r\n      * @en Size of the map's tile (could be different from the tile's size).\r\n      * @zh 获取 tile 的大小( tile 的大小可能会有所不同)。\r\n      * @method getMapTileSize\r\n      * @return {Size}\r\n      * @example\r\n      * let mapTileSize = tiledLayer.getMapTileSize();\r\n      * cc.log(\"MapTile size: \" + mapTileSize);\r\n      */\r\n    public getMapTileSize (): Size {\r\n        return this._mapTileSize!;\r\n    }\r\n\r\n    /**\r\n      * @en Gets Tile set first information for the layer.\r\n      * @zh 获取 layer 索引位置为0的 Tileset 信息。\r\n      * @method getTileSet\r\n      * @param index The index of tilesets\r\n      * @return {TMXTilesetInfo}\r\n      */\r\n    public getTileSet (index: number): TMXTilesetInfo | null {\r\n        index = index || 0;\r\n        if (this._tilesets && index >= 0 && this._tilesets.length > index) {\r\n            return this._tilesets[index];\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n      * @en Gets tile set all information for the layer.\r\n      * @zh 获取 layer 所有的 Tileset 信息。\r\n      * @method getTileSet\r\n      * @return {TMXTilesetInfo}\r\n      */\r\n    public getTileSets (): TMXTilesetInfo[] {\r\n        return this._tilesets;\r\n    }\r\n\r\n    /**\r\n      * @en Sets tile set information for the layer.\r\n      * @zh 设置 layer 的 tileset 信息。\r\n      * @method setTileSet\r\n      * @param {TMXTilesetInfo} tileset\r\n      */\r\n    public setTileSet (tileset: TMXTilesetInfo): void {\r\n        this.setTileSets([tileset]);\r\n    }\r\n\r\n    /**\r\n      * @en Sets Tile set information for the layer.\r\n      * @zh 设置 layer 的 Tileset 信息。\r\n      * @method setTileSets\r\n      * @param {TMXTilesetInfo} tilesets\r\n      */\r\n    public setTileSets (tilesets: TMXTilesetInfo[]): void {\r\n        this._tilesets = tilesets;\r\n        const textures: SpriteFrame[] = this._textures = [];\r\n        const texGrids = this.texGrids!;\r\n        texGrids.clear();\r\n        for (let i = 0; i < tilesets.length; i++) {\r\n            const tileset = tilesets[i];\r\n            if (tileset) {\r\n                textures[i] = tileset.sourceImage!;\r\n            }\r\n        }\r\n\r\n        for (let i = 0, l = tilesets.length; i < l; ++i) {\r\n            const tilesetInfo = tilesets[i];\r\n            if (!tilesetInfo) continue;\r\n            fillTextureGrids(tilesetInfo, texGrids, tilesetInfo.sourceImage);\r\n        }\r\n        this._prepareToRender();\r\n    }\r\n\r\n    public init (\r\n        layerInfo: TMXLayerInfo,\r\n        mapInfo: TMXMapInfo,\r\n        tilesets: TMXTilesetInfo[],\r\n        textures: SpriteFrame[],\r\n        texGrids: TiledTextureGrids,\r\n    ): void {\r\n        const self = this;\r\n        self._cullingDirty = true;\r\n        self._layerInfo = layerInfo;\r\n        self._mapInfo = mapInfo;\r\n\r\n        const size = layerInfo.layerSize!;\r\n\r\n        // layerInfo\r\n        self._layerName = layerInfo.name;\r\n        self.tiles = layerInfo.tiles as unknown as any;\r\n        self._properties = layerInfo.properties;\r\n        self._layerSize = size;\r\n        self._minGID = layerInfo.minGID;\r\n        self._maxGID = layerInfo.maxGID;\r\n        self._opacity = layerInfo.opacity;\r\n\r\n        if (layerInfo.tintColor) {\r\n            self._tintColor = layerInfo.tintColor;\r\n            // this.node.color = this._tintColor;\r\n        }\r\n\r\n        self.renderOrder = mapInfo.renderOrder;\r\n        self._staggerAxis = mapInfo.getStaggerAxis()!;\r\n        self._staggerIndex = mapInfo.getStaggerIndex()!;\r\n        self._hexSideLength = mapInfo.getHexSideLength();\r\n        self._animations = mapInfo.getTileAnimations();\r\n\r\n        // tilesets\r\n        self._tilesets = tilesets;\r\n        // textures\r\n        self._textures = textures;\r\n        // grid texture\r\n        self.texGrids = texGrids;\r\n\r\n        // mapInfo\r\n        self._layerOrientation = mapInfo.orientation;\r\n        self._mapTileSize = mapInfo.getTileSize();\r\n\r\n        const maptw = self._mapTileSize.width;\r\n        const mapth = self._mapTileSize.height;\r\n        const layerW = self._layerSize.width;\r\n        const layerH = self._layerSize.height;\r\n        const uiTransformComp = self.node._getUITransformComp()!;\r\n\r\n        if (self._layerOrientation === Orientation.HEX) {\r\n            let width = 0;\r\n            let height = 0;\r\n            const tileWidth = maptw & ~1;\r\n            const tileHeight = mapth & ~1;\r\n\r\n            self._odd_even = (self._staggerIndex === StaggerIndex.STAGGERINDEX_ODD) ? 1 : -1;\r\n            if (self._staggerAxis === StaggerAxis.STAGGERAXIS_X) {\r\n                self._diffX1 = (tileWidth - self._hexSideLength) / 2;\r\n                self._diffY1 = 0;\r\n                width = (self._diffX1 + self._hexSideLength) * layerW + self._diffX1;\r\n                height = (tileHeight * layerH) + tileHeight / 2;\r\n            } else {\r\n                self._diffX1 = 0;\r\n                self._diffY1 = (tileHeight - self._hexSideLength) / 2;\r\n                width = (tileWidth * layerW) + tileWidth / 2;\r\n                height = (self._diffY1 + self._hexSideLength) * layerH + self._diffY1;\r\n            }\r\n            uiTransformComp.setContentSize(width, height);\r\n        } else if (self._layerOrientation === Orientation.ISO) {\r\n            const wh = layerW + layerH;\r\n            uiTransformComp.setContentSize(maptw * 0.5 * wh, mapth * 0.5 * wh);\r\n        } else {\r\n            uiTransformComp.setContentSize(layerW * maptw, layerH * mapth);\r\n        }\r\n\r\n        // offset (after layer orientation is set);\r\n        self._offset = new Vec2(layerInfo.offset.x, -layerInfo.offset.y);\r\n        self._useAutomaticVertexZ = false;\r\n        self._vertexZvalue = 0;\r\n        self._syncAnchorPoint();\r\n        self._prepareToRender();\r\n    }\r\n\r\n    protected _prepareToRender (): void {\r\n        this._updateVertices();\r\n        this._updateAllUserNode();\r\n    }\r\n\r\n    public requestTiledRenderData (): TiledRenderData {\r\n        const arr = this._tiledDataArray as any[];\r\n        while (arr.length > 0 && arr[arr.length - 1].subNodes && arr[arr.length - 1].subNodes.length === 0) {\r\n            arr.pop();\r\n        }\r\n        if (arr.length > 0) {\r\n            const last = arr[arr.length - 1];\r\n            if (last.renderData && last.renderData.vertexCount === 0) {\r\n                return last as TiledRenderData;\r\n            }\r\n        }\r\n        const comb = { renderData: null, texture: null };\r\n        this._tiledDataArray.push(comb);\r\n        return (comb as TiledRenderData);\r\n    }\r\n\r\n    public requestSubNodesData (): TiledSubNodeData {\r\n        const arr = this._tiledDataArray;\r\n        if (arr.length > 0) {\r\n            const last = arr[arr.length - 1];\r\n            if (isTiledSubNodeData(last) && last.subNodes.length === 0) {\r\n                return last;\r\n            }\r\n        }\r\n        const renderData: (TiledUserNodeData | null)[] = [];\r\n        const comb = { subNodes: renderData };\r\n        this._tiledDataArray.push(comb);\r\n        return comb;\r\n    }\r\n\r\n    public destroyRenderData (): void {\r\n        this._tiledDataArray.forEach((rd) => {\r\n            const renderData = (rd as TiledRenderData).renderData;\r\n            if (renderData) RenderData.remove(renderData);\r\n        });\r\n        this._tiledDataArray.length = 0;\r\n        super.destroyRenderData();\r\n    }\r\n\r\n    protected _flushAssembler (): void {\r\n        const assembler = TiledLayer.Assembler.getAssembler(this);\r\n        if (this._assembler !== assembler) {\r\n            this._assembler = assembler;\r\n            this._assembler.createData!(this);\r\n        }\r\n        if (this._tiledDataArray.length === 0) {\r\n            this._markForUpdateRenderData();\r\n            this._updateColor();\r\n        }\r\n    }\r\n\r\n    /**\r\n      * @en\r\n      * Index of mesh render data array\r\n      * @zh\r\n      * 网格渲染数据数组的索引\r\n      * @deprecated since v3.5.0, this is an engine private interface that will be removed in the future.\r\n      */\r\n    public _tiledDataArrayIdx = 0;\r\n    protected _render (ui: IBatcher): void {\r\n        for (let i = 0; i < this._tiledDataArray.length; i++) {\r\n            this._tiledDataArrayIdx = i;\r\n            const m = this._tiledDataArray[i];\r\n            if ((m as TiledSubNodeData).subNodes) {\r\n                // 提前处理 User Nodes\r\n                (m as TiledSubNodeData).subNodes.forEach((c) => {\r\n                    if (c) ui.walk(c.node);\r\n                });\r\n            } else {\r\n                const td = m as TiledRenderData;\r\n                if (td.texture) {\r\n                    // NOTE: 由于 commitComp 只支持单张纹理, 故分多次提交\r\n                    ui.commitComp(this, td.renderData, td.texture, this._assembler, null);\r\n                }\r\n            }\r\n        }\r\n        this.node._static = true;\r\n    }\r\n\r\n    protected createRenderEntity (): RenderEntity {\r\n        return new RenderEntity(RenderEntityType.CROSSED);\r\n    }\r\n\r\n    private fillIndicesBuffer (renderData: RenderData, drawInfo: RenderDrawInfo): void {\r\n        const iBuf = renderData.chunk.meshBuffer.iData;\r\n        let vertexId = renderData.chunk.vertexOffset;\r\n        const quadCount = renderData.vertexCount / 4;\r\n        let indexOffset = (vertexId / 4) * 6;\r\n        drawInfo.setIndexOffset(indexOffset);\r\n        for (let i = 0; i < quadCount; i += 1) {\r\n            iBuf[indexOffset] = vertexId;\r\n            iBuf[indexOffset + 1] = vertexId + 1;\r\n            iBuf[indexOffset + 2] = vertexId + 2;\r\n            iBuf[indexOffset + 3] = vertexId + 2;\r\n            iBuf[indexOffset + 4] = vertexId + 1;\r\n            iBuf[indexOffset + 5] = vertexId + 3;\r\n            indexOffset += 6;\r\n            vertexId += 4;\r\n        }\r\n        renderData.chunk.meshBuffer.indexOffset = indexOffset;\r\n        drawInfo.setIBCount(quadCount * 6);\r\n    }\r\n\r\n    public prepareDrawData (): void {\r\n        this._drawInfoList.length = 0;\r\n        const entity = this.renderEntity;\r\n        entity.clearDynamicRenderDrawInfos();\r\n        const tiledDataArray = this._tiledDataArray;\r\n        let idx = 0;\r\n        tiledDataArray.forEach((m) => {\r\n            if (isTiledSubNodeData(m)) {\r\n                // 提前处理 User Nodes\r\n                m.subNodes.forEach((c) => {\r\n                    if (c) {\r\n                        if (!this._drawInfoList[idx]) {\r\n                            this._drawInfoList[idx] = new RenderDrawInfo();\r\n                        }\r\n                        const drawInfo = this._drawInfoList[idx];\r\n                        drawInfo.setDrawInfoType(RenderDrawInfoType.SUB_NODE);\r\n                        drawInfo.setSubNode(c.node);\r\n                        entity.setDynamicRenderDrawInfo(drawInfo, idx);\r\n                        idx++;\r\n                    }\r\n                });\r\n            } else {\r\n                const td = m;\r\n                if (td.texture && td.renderData) {\r\n                    if (!this._drawInfoList[idx]) {\r\n                        this._drawInfoList[idx] = new RenderDrawInfo();\r\n                    }\r\n                    const drawInfo = this._drawInfoList[idx];\r\n                    td.renderData.fillDrawInfoAttributes(drawInfo);\r\n                    drawInfo.setTexture(td.texture.getGFXTexture());\r\n                    drawInfo.setSampler(td.texture.getGFXSampler());\r\n                    drawInfo.setMaterial(this.getRenderMaterial(0)!);\r\n                    this.fillIndicesBuffer(td.renderData, drawInfo);\r\n                    entity.setDynamicRenderDrawInfo(drawInfo, idx);\r\n                    idx++;\r\n                }\r\n            }\r\n        });\r\n    }\r\n}\r\n","/*\r\n Copyright (c) 2017-2023 Xiamen Yaji Software Co., Ltd.\r\n\r\n https://www.cocos.com/\r\n\r\n Permission is hereby granted, free of charge, to any person obtaining a copy\r\n of this software and associated documentation files (the \"Software\"), to deal\r\n in the Software without restriction, including without limitation the rights to\r\n use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\r\n of the Software, and to permit persons to whom the Software is furnished to do so,\r\n subject to the following conditions:\r\n\r\n The above copyright notice and this permission notice shall be included in\r\n all copies or substantial portions of the Software.\r\n\r\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n THE SOFTWARE.\r\n*/\r\n\r\nimport { JSB } from 'internal:constants';\r\nimport { Mat4, Size, Vec3 } from '../../core/math';\r\nimport type { IAssembler } from '../../2d/renderer/base';\r\nimport type { IBatcher } from '../../2d/renderer/i-batcher';\r\nimport { TiledLayer, TiledRenderData, TiledTile } from '..';\r\nimport { GID, MixedGID, RenderOrder, TiledGrid, TileFlag } from '../tiled-types';\r\nimport { director, DirectorEvent } from '../../game';\r\nimport { StaticVBAccessor } from '../../2d/renderer/static-vb-accessor';\r\nimport { vfmtPosUvColor } from '../../2d/renderer/vertex-format';\r\nimport { BaseRenderData, RenderData } from '../../2d/renderer/render-data';\r\nimport { RenderDrawInfoType } from '../../2d/renderer/render-draw-info';\r\nimport type { Texture2D } from '../../asset/assets';\r\nimport type { Node } from '../../scene-graph';\r\n\r\nconst MaxGridsLimit = Math.ceil(65535 / 6);\r\n\r\nconst vec3_temps: Vec3[] = [];\r\nfor (let i = 0; i < 4; i++) {\r\n    vec3_temps.push(new Vec3());\r\n}\r\n\r\nconst _mat4_temp = new Mat4();\r\nconst _vec3u_temp = new Vec3();\r\nconst _leftDown = { row: 0, col: 0 };\r\nlet _uva = { x: 0, y: 0 };\r\nlet _uvb = { x: 0, y: 0 };\r\nlet _uvc = { x: 0, y: 0 };\r\nlet _uvd = { x: 0, y: 0 };\r\n\r\nlet _vfOffset = 0;\r\nlet _moveX = 0;\r\nlet _moveY = 0;\r\n\r\nlet _fillCount = 0;\r\nlet _curTexture: Texture2D | null = null;\r\nlet _tempBuffers: Float32Array;\r\nlet _curLayer: TiledLayer;\r\n\r\nlet flipTexture: (grid: TiledGrid, gid: MixedGID) => void;\r\n\r\nlet _accessor: StaticVBAccessor = null!;\r\n/**\r\n * simple 组装器\r\n * 可通过 `UI.simple` 获取该组装器。\r\n */\r\nclass Simple implements IAssembler {\r\n    private ensureAccessor (): void {\r\n        if (!_accessor) {\r\n            const device = director.root!.device;\r\n            const batcher = director.root!.batcher2D;\r\n            _accessor = new StaticVBAccessor(device, vfmtPosUvColor);\r\n            //batcher.registerBufferAccessor(Number.parseInt('TILED-MAP', 36), _accessor);\r\n        }\r\n    }\r\n\r\n    createData (layer: TiledLayer): BaseRenderData {\r\n        if (JSB) {\r\n            this.ensureAccessor();\r\n        }\r\n\r\n        return null as unknown as BaseRenderData;\r\n    }\r\n\r\n    fillBuffers (layer: TiledLayer, renderer: IBatcher): void {\r\n        if (!layer || layer.tiledDataArray.length === 0) return;\r\n\r\n        const dataArray = layer.tiledDataArray;\r\n\r\n        // 当前渲染的数据\r\n        const data = dataArray[layer._tiledDataArrayIdx] as TiledRenderData;\r\n        const renderData = data.renderData;\r\n        if (!renderData) return;\r\n        const iBuf = renderData.chunk.meshBuffer.iData;\r\n\r\n        let indexOffset = renderData.chunk.meshBuffer.indexOffset;\r\n        let vertexId = renderData.chunk.vertexOffset;\r\n        const quadCount = renderData.vertexCount / 4;\r\n        for (let i = 0; i < quadCount; i += 1) {\r\n            iBuf[indexOffset] = vertexId;\r\n            iBuf[indexOffset + 1] = vertexId + 1;\r\n            iBuf[indexOffset + 2] = vertexId + 2;\r\n            iBuf[indexOffset + 3] = vertexId + 2;\r\n            iBuf[indexOffset + 4] = vertexId + 1;\r\n            iBuf[indexOffset + 5] = vertexId + 3;\r\n            indexOffset += 6;\r\n            vertexId += 4;\r\n        }\r\n        renderData.chunk.meshBuffer.indexOffset = indexOffset;\r\n    }\r\n\r\n    updateRenderData (comp: TiledLayer): void {\r\n        comp.updateCulling();\r\n        _moveX = comp.leftDownToCenterX;\r\n        _moveY = comp.leftDownToCenterY;\r\n        if (comp.colorChanged || comp.isCullingDirty() || comp.isUserNodeDirty() || comp.hasAnimation()\r\n            || comp.hasTiledNode() || comp.node.hasChangedFlags) {\r\n            comp.colorChanged = false;\r\n            comp.destroyRenderData();\r\n\r\n            let leftDown: { col: number, row: number };\r\n            let rightTop: { col: number, row: number };\r\n            if (comp.enableCulling) {\r\n                const cullingRect = comp.cullingRect;\r\n                leftDown = cullingRect.leftDown;\r\n                rightTop = cullingRect.rightTop;\r\n            } else {\r\n                leftDown = _leftDown;\r\n                rightTop = comp.rightTop;\r\n            }\r\n\r\n            switch (comp.renderOrder) {\r\n            // left top to right down, col add, row sub,\r\n            case RenderOrder.RightDown:\r\n                traverseGrids(leftDown, rightTop, -1, 1, comp);\r\n                break;\r\n                // right top to left down, col sub, row sub\r\n            case RenderOrder.LeftDown:\r\n                traverseGrids(leftDown, rightTop, -1, -1, comp);\r\n                break;\r\n                // left down to right up, col add, row add\r\n            case RenderOrder.RightUp:\r\n                traverseGrids(leftDown, rightTop, 1, 1, comp);\r\n                break;\r\n                // right down to left up, col sub, row add\r\n            case RenderOrder.LeftUp:\r\n            default:\r\n                traverseGrids(leftDown, rightTop, 1, -1, comp);\r\n                break;\r\n            }\r\n            comp.setCullingDirty(false);\r\n            comp.setUserNodeDirty(false);\r\n        }\r\n        if (JSB) {\r\n            comp.prepareDrawData();\r\n        }\r\n    }\r\n\r\n    updateColor (tiled: TiledLayer): void {\r\n        const color = tiled.color;\r\n        const colorV = new Float32Array(4);\r\n        colorV[0] = color.r / 255;\r\n        colorV[1] = color.g / 255;\r\n        colorV[2] = color.b / 255;\r\n        colorV[3] = color.a / 255;\r\n        const rs = tiled.tiledDataArray;\r\n        for (let index = 0; index < rs.length; index++) {\r\n            const r = rs[index];\r\n            if (!(r as any).renderData) continue;\r\n            const renderData = (r as any).renderData;\r\n            const vs = renderData.vData;\r\n            for (let i = renderData.vertexStart, l = renderData.vertexCount; i < l; i++) {\r\n                vs.set(colorV, i * 9 + 5);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nexport const simple = new Simple();\r\n\r\n/*\r\ntexture coordinate\r\na c\r\nb d\r\n*/\r\nfunction _flipTexture (inGrid: TiledGrid, gid: MixedGID): void {\r\n    if (inGrid._rotated) {\r\n        // 2:b   1:a\r\n        // 4:d   3:c\r\n        _uva.x = inGrid.r;\r\n        _uva.y = inGrid.t;\r\n        _uvb.x = inGrid.l;\r\n        _uvb.y = inGrid.t;\r\n        _uvc.x = inGrid.r;\r\n        _uvc.y = inGrid.b;\r\n        _uvd.x = inGrid.l;\r\n        _uvd.y = inGrid.b;\r\n    } else {\r\n        // 1:a  3:c\r\n        // 2:b  4:d\r\n        _uva.x = inGrid.l;\r\n        _uva.y = inGrid.t;\r\n        _uvb.x = inGrid.l;\r\n        _uvb.y = inGrid.b;\r\n        _uvc.x = inGrid.r;\r\n        _uvc.y = inGrid.t;\r\n        _uvd.x = inGrid.r;\r\n        _uvd.y = inGrid.b;\r\n    }\r\n\r\n    let tempVal;\r\n\r\n    // vice\r\n    if (((gid as unknown as number) & TileFlag.DIAGONAL) >>> 0) {\r\n        tempVal = _uvb;\r\n        _uvb = _uvc;\r\n        _uvc = tempVal;\r\n    }\r\n\r\n    // flip x\r\n    if (((gid as unknown as number) & TileFlag.HORIZONTAL) >>> 0) {\r\n        tempVal = _uva;\r\n        _uva = _uvc;\r\n        _uvc = tempVal;\r\n\r\n        tempVal = _uvb;\r\n        _uvb = _uvd;\r\n        _uvd = tempVal;\r\n    }\r\n\r\n    // flip y\r\n    if (((gid as unknown as number) & TileFlag.VERTICAL) >>> 0) {\r\n        tempVal = _uva;\r\n        _uva = _uvb;\r\n        _uvb = tempVal;\r\n\r\n        tempVal = _uvc;\r\n        _uvc = _uvd;\r\n        _uvd = tempVal;\r\n    }\r\n}\r\n\r\n/*\r\ntexture coordinate\r\n   a\r\nb     c\r\n   d\r\n*/\r\nfunction _flipDiamondTileTexture (inGrid: TiledGrid, gid: MixedGID): void {\r\n    if (inGrid._rotated) {\r\n        //       2:b\r\n        // 4:d         1:a\r\n        //       3:c\r\n        _uva.x = inGrid.r;\r\n        _uva.y = inGrid.cy;\r\n        _uvb.x = inGrid.cx;\r\n        _uvb.y = inGrid.t;\r\n        _uvc.x = inGrid.cx;\r\n        _uvc.y = inGrid.b;\r\n        _uvd.x = inGrid.l;\r\n        _uvd.y = inGrid.cy;\r\n    } else {\r\n        //       1:a\r\n        // 2:b         3:c\r\n        //       4:d\r\n        _uva.x = inGrid.cx;\r\n        _uva.y = inGrid.t;\r\n        _uvb.x = inGrid.l;\r\n        _uvb.y = inGrid.cy;\r\n        _uvc.x = inGrid.r;\r\n        _uvc.y = inGrid.cy;\r\n        _uvd.x = inGrid.cx;\r\n        _uvd.y = inGrid.b;\r\n    }\r\n\r\n    let tempVal;\r\n\r\n    // vice\r\n    if ((gid & TileFlag.DIAGONAL) >>> 0) {\r\n        tempVal = _uva;\r\n        _uva = _uvb;\r\n        _uvb = tempVal;\r\n\r\n        tempVal = _uvc;\r\n        _uvc = _uvd;\r\n        _uvd = tempVal;\r\n    }\r\n\r\n    // flip x\r\n    if ((gid & TileFlag.HORIZONTAL) >>> 0) {\r\n        tempVal = _uvb;\r\n        _uvb = _uvc;\r\n        _uvc = tempVal;\r\n    }\r\n\r\n    // flip y\r\n    if ((gid & TileFlag.VERTICAL) >>> 0) {\r\n        tempVal = _uva;\r\n        _uva = _uvd;\r\n        _uvd = tempVal;\r\n    }\r\n}\r\n\r\nfunction packRenderData (): void {\r\n    if (_fillCount < 1 || !_curTexture) return;\r\n\r\n    const vbCount = 4 * _fillCount;\r\n    const ibCount = 6 * _fillCount;\r\n    const tiledData = _curLayer.requestTiledRenderData();\r\n    if (JSB) {\r\n        tiledData.renderData = RenderData.add(vfmtPosUvColor, _accessor);\r\n        tiledData.renderData.drawInfoType = RenderDrawInfoType.MIDDLEWARE;\r\n    } else {\r\n        tiledData.renderData = RenderData.add(vfmtPosUvColor);\r\n    }\r\n    tiledData.texture = _curTexture;\r\n    const rd = tiledData.renderData;\r\n    rd.resize(vbCount, ibCount);\r\n    const vb = rd.chunk.vb;\r\n    vb.set(_tempBuffers.subarray(0, vbCount * 9), 0);\r\n\r\n    _fillCount = 0;\r\n    _curTexture = null;\r\n}\r\n\r\n// rowMoveDir is -1 or 1, -1 means decrease, 1 means increase\r\n// colMoveDir is -1 or 1, -1 means decrease, 1 means increase\r\nfunction traverseGrids (\r\n    leftDown: { col: number, row: number },\r\n    rightTop: { col: number, row: number },\r\n    rowMoveDir: number,\r\n    colMoveDir: number,\r\n    comp: TiledLayer,\r\n): void {\r\n    // show nothing\r\n    if (rightTop.row < 0 || rightTop.col < 0) return;\r\n\r\n    _curLayer = comp;\r\n\r\n    const matrix = comp.node.worldMatrix;\r\n    _vfOffset = 0;\r\n\r\n    const tiledTiles = comp.tiledTiles;\r\n\r\n    const texGrids = comp.texGrids!;\r\n    const tiles = comp.tiles;\r\n\r\n    const vertStep = 9;\r\n    const vertStep2 = vertStep * 2;\r\n    const vertStep3 = vertStep * 3;\r\n\r\n    const vertices = comp.vertices;\r\n    let rowData: { maxCol: number, minCol: number } & SafeRecord<number, { left: number, bottom: number; index: number }>;\r\n    let col: number;\r\n    let cols: number;\r\n    let row: number;\r\n    let rows: number;\r\n    let colData: { left: number, bottom: number, index: number };\r\n    let tileSize: Size;\r\n    let grid: TiledGrid | undefined;\r\n    let gid: MixedGID = 0 as unknown as any;\r\n    let left = 0;\r\n    let bottom = 0;\r\n    let right = 0;\r\n    let top = 0; // x, y\r\n    let tiledNode: TiledTile | null;\r\n    let colNodesCount = 0;\r\n    let isCheckColRange = true;\r\n\r\n    const diamondTile = false; // TODO:comp._diamondTile;\r\n\r\n    flipTexture = diamondTile ? _flipDiamondTileTexture : _flipTexture;\r\n\r\n    const color: Float32Array = new Float32Array(4);\r\n    color[0] = comp.color.r / 255;\r\n    color[1] = comp.color.g / 255;\r\n    color[2] = comp.color.b / 255;\r\n    color[3] = comp.color.a / 255;\r\n\r\n    if (rowMoveDir === -1) {\r\n        row = rightTop.row;\r\n        rows = leftDown.row;\r\n    } else {\r\n        row = leftDown.row;\r\n        rows = rightTop.row;\r\n    }\r\n\r\n    const _tempRows = Math.abs(leftDown.row - rightTop.row) + 1;\r\n    const _tempClos = Math.abs(rightTop.col - leftDown.col) + 1;\r\n    _tempBuffers = new Float32Array(_tempRows * _tempClos * 9 * 4);\r\n    _fillCount = 0;\r\n    const vertexBuf = _tempBuffers;\r\n    // traverse row\r\n    for (; (rows - row) * rowMoveDir >= 0; row += rowMoveDir) {\r\n        rowData = vertices[row]!;\r\n        colNodesCount = comp.getNodesCountByRow(row);\r\n        isCheckColRange = rowData && colNodesCount === 0;\r\n\r\n        // limit min col and max col\r\n        if (colMoveDir === 1) {\r\n            col = isCheckColRange && leftDown.col < rowData.minCol ? rowData.minCol : leftDown.col;\r\n            cols = isCheckColRange && rightTop.col > rowData.maxCol ? rowData.maxCol : rightTop.col;\r\n        } else {\r\n            col = isCheckColRange && rightTop.col > rowData.maxCol ? rowData.maxCol : rightTop.col;\r\n            cols = isCheckColRange && leftDown.col < rowData.minCol ? rowData.minCol : leftDown.col;\r\n        }\r\n\r\n        // traverse col\r\n        for (; (cols - col) * colMoveDir >= 0; col += colMoveDir) {\r\n            colData = rowData && rowData[col]!;\r\n\r\n            if (colNodesCount > 0) {\r\n                packRenderData();\r\n                const nodes = comp.requestSubNodesData();\r\n                const celData = comp.getNodesByRowCol(row, col);\r\n                if (celData && celData.count > 0) {\r\n                    nodes.subNodes = celData.list;\r\n                }\r\n            }\r\n\r\n            if (!colData) {\r\n                // only render users nodes because map data is empty\r\n                continue;\r\n            }\r\n\r\n            gid = tiles[colData.index];\r\n            grid = texGrids.get((((gid as unknown as number) & TileFlag.FLIPPED_MASK) >>> 0) as unknown as GID);\r\n            if (!grid) continue;\r\n\r\n            // check init or new material\r\n            if (_curTexture !== grid.texture) {\r\n                packRenderData();\r\n                _curTexture = grid.texture;\r\n            }\r\n\r\n            tileSize = grid.tileset._tileSize;\r\n\r\n            // calc rect vertex\r\n            left = colData.left - _moveX;\r\n            bottom = colData.bottom - _moveY;\r\n            right = left + tileSize.width;\r\n            top = bottom + tileSize.height;\r\n\r\n            // begin to fill vertex buffer\r\n            tiledNode = tiledTiles[colData.index];\r\n\r\n            _vfOffset = _fillCount * 4 * 9;\r\n\r\n            if (!tiledNode) {\r\n                if (diamondTile) {\r\n                    const centerX = (left + right) / 2;\r\n                    const centerY = (top + bottom) / 2;\r\n                    // ct\r\n                    vec3_temps[0].x = centerX;\r\n                    vec3_temps[0].y = top;\r\n\r\n                    // lc\r\n                    vec3_temps[1].x = left;\r\n                    vec3_temps[1].y = centerY;\r\n\r\n                    // rc\r\n                    vec3_temps[2].x = right;\r\n                    vec3_temps[2].y = centerY;\r\n\r\n                    // cb\r\n                    vec3_temps[3].x = centerX;\r\n                    vec3_temps[3].y = bottom;\r\n                } else {\r\n                    // lt\r\n                    vec3_temps[0].x = left;\r\n                    vec3_temps[0].y = top;\r\n\r\n                    // lb\r\n                    vec3_temps[1].x = left;\r\n                    vec3_temps[1].y = bottom;\r\n\r\n                    // rt\r\n                    vec3_temps[2].x = right;\r\n                    vec3_temps[2].y = top;\r\n\r\n                    // rb\r\n                    vec3_temps[3].x = right;\r\n                    vec3_temps[3].y = bottom;\r\n                }\r\n\r\n                vec3_temps[0].transformMat4(matrix);\r\n                vertexBuf[_vfOffset] = vec3_temps[0].x;\r\n                vertexBuf[_vfOffset + 1] = vec3_temps[0].y;\r\n                vertexBuf[_vfOffset + 2] = vec3_temps[0].z;\r\n\r\n                vec3_temps[1].transformMat4(matrix);\r\n                vertexBuf[_vfOffset + vertStep] = vec3_temps[1].x;\r\n                vertexBuf[_vfOffset + vertStep + 1] = vec3_temps[1].y;\r\n                vertexBuf[_vfOffset + vertStep + 2] = vec3_temps[1].z;\r\n\r\n                vec3_temps[2].transformMat4(matrix);\r\n                vertexBuf[_vfOffset + vertStep2] = vec3_temps[2].x;\r\n                vertexBuf[_vfOffset + vertStep2 + 1] = vec3_temps[2].y;\r\n                vertexBuf[_vfOffset + vertStep2 + 2] = vec3_temps[2].z;\r\n\r\n                vec3_temps[3].transformMat4(matrix);\r\n                vertexBuf[_vfOffset + vertStep3] = vec3_temps[3].x;\r\n                vertexBuf[_vfOffset + vertStep3 + 1] = vec3_temps[3].y;\r\n                vertexBuf[_vfOffset + vertStep3 + 2] = vec3_temps[3].z;\r\n\r\n                vertexBuf.set(color, _vfOffset + 5);\r\n                vertexBuf.set(color, _vfOffset + vertStep + 5);\r\n                vertexBuf.set(color, _vfOffset + vertStep2 + 5);\r\n                vertexBuf.set(color, _vfOffset + vertStep3 + 5);\r\n            } else if (tiledNode.node.active) {\r\n                fillByTiledNode(tiledNode.node, color, vertexBuf, left, right, top, bottom, diamondTile);\r\n            }\r\n\r\n            flipTexture(grid, gid);\r\n\r\n            // lt/ct -> a\r\n            vertexBuf[_vfOffset + 3] = _uva.x;\r\n            vertexBuf[_vfOffset + 4] = _uva.y;\r\n\r\n            // lb/lc -> b\r\n            vertexBuf[_vfOffset + vertStep + 3] = _uvb.x;\r\n            vertexBuf[_vfOffset + vertStep + 4] = _uvb.y;\r\n\r\n            // rt/rc -> c\r\n            vertexBuf[_vfOffset + vertStep2 + 3] = _uvc.x;\r\n            vertexBuf[_vfOffset + vertStep2 + 4] = _uvc.y;\r\n\r\n            // rt/cb -> d\r\n            vertexBuf[_vfOffset + vertStep3 + 3] = _uvd.x;\r\n            vertexBuf[_vfOffset + vertStep3 + 4] = _uvd.y;\r\n\r\n            _fillCount++;\r\n\r\n            // vertices count exceed 66635, buffer must be switched\r\n            if (_fillCount >= MaxGridsLimit) {\r\n                packRenderData();\r\n            }\r\n        }\r\n    }\r\n    packRenderData();\r\n}\r\n\r\nfunction fillByTiledNode (\r\n    tiledNode: Node,\r\n    color: Float32Array,\r\n    vbuf: Float32Array,\r\n    left: number,\r\n    right: number,\r\n    top: number,\r\n    bottom: number,\r\n    diamondTile: boolean,\r\n): void {\r\n    const vertStep = 9;\r\n    const vertStep2 = vertStep * 2;\r\n    const vertStep3 = vertStep * 3;\r\n\r\n    tiledNode.updateWorldTransform();\r\n    Mat4.fromRTS(_mat4_temp, tiledNode.rotation, tiledNode.position, tiledNode.scale);\r\n    Vec3.set(_vec3u_temp, -(left + _moveX), -(bottom + _moveY), 0);\r\n    Mat4.transform(_mat4_temp, _mat4_temp, _vec3u_temp);\r\n    Mat4.multiply(_mat4_temp, tiledNode.parent!.worldMatrix, _mat4_temp);\r\n\r\n    const m = _mat4_temp;\r\n    const tx = m.m12;\r\n    const ty = m.m13;\r\n\r\n    const a = m.m00;\r\n    const b = m.m01;\r\n    const c = m.m04;\r\n    const d = m.m05;\r\n\r\n    const justTranslate = a === 1 && b === 0 && c === 0 && d === 1;\r\n\r\n    if (diamondTile) {\r\n        const centerX = (left + right) / 2;\r\n        const centerY = (top + bottom) / 2;\r\n        if (justTranslate) {\r\n            // ct\r\n            vbuf[_vfOffset] = centerX + tx;\r\n            vbuf[_vfOffset + 1] = top + ty;\r\n\r\n            // lc\r\n            vbuf[_vfOffset + vertStep] = left + tx;\r\n            vbuf[_vfOffset + vertStep + 1] = centerY + ty;\r\n\r\n            // rc\r\n            vbuf[_vfOffset + vertStep2] = right + tx;\r\n            vbuf[_vfOffset + vertStep2 + 1] = centerY + ty;\r\n\r\n            // cb\r\n            vbuf[_vfOffset + vertStep3] = centerX + tx;\r\n            vbuf[_vfOffset + vertStep3 + 1] = bottom + ty;\r\n        } else {\r\n            // ct\r\n            vbuf[_vfOffset] = centerX * a + top * c + tx;\r\n            vbuf[_vfOffset + 1] = centerX * b + top * d + ty;\r\n\r\n            // lc\r\n            vbuf[_vfOffset + vertStep] = left * a + centerY * c + tx;\r\n            vbuf[_vfOffset + vertStep + 1] = left * b + centerY * d + ty;\r\n\r\n            // rc\r\n            vbuf[_vfOffset + vertStep2] = right * a + centerY * c + tx;\r\n            vbuf[_vfOffset + vertStep2 + 1] = right * b + centerY * d + ty;\r\n\r\n            // cb\r\n            vbuf[_vfOffset + vertStep3] = centerX * a + bottom * c + tx;\r\n            vbuf[_vfOffset + vertStep3 + 1] = centerX * b + bottom * d + ty;\r\n        }\r\n    } else if (justTranslate) {\r\n        vbuf[_vfOffset] = left + tx;\r\n        vbuf[_vfOffset + 1] = top + ty;\r\n\r\n        vbuf[_vfOffset + vertStep] = left + tx;\r\n        vbuf[_vfOffset + vertStep + 1] = bottom + ty;\r\n\r\n        vbuf[_vfOffset + vertStep2] = right + tx;\r\n        vbuf[_vfOffset + vertStep2 + 1] = top + ty;\r\n\r\n        vbuf[_vfOffset + vertStep3] = right + tx;\r\n        vbuf[_vfOffset + vertStep3 + 1] = bottom + ty;\r\n    } else {\r\n        // lt\r\n        vbuf[_vfOffset] = left * a + top * c + tx;\r\n        vbuf[_vfOffset + 1] = left * b + top * d + ty;\r\n\r\n        // lb\r\n        vbuf[_vfOffset + vertStep] = left * a + bottom * c + tx;\r\n        vbuf[_vfOffset + vertStep + 1] = left * b + bottom * d + ty;\r\n\r\n        // rt\r\n        vbuf[_vfOffset + vertStep2] = right * a + top * c + tx;\r\n        vbuf[_vfOffset + vertStep2 + 1] = right * b + top * d + ty;\r\n\r\n        // rb\r\n        vbuf[_vfOffset + vertStep3] = right * a + bottom * c + tx;\r\n        vbuf[_vfOffset + vertStep3 + 1] = right * b + bottom * d + ty;\r\n    }\r\n\r\n    vbuf.set(color, _vfOffset + 5);\r\n    vbuf.set(color, _vfOffset + vertStep + 5);\r\n    vbuf.set(color, _vfOffset + vertStep2 + 5);\r\n    vbuf.set(color, _vfOffset + vertStep3 + 5);\r\n}\r\n","/*\r\n Copyright (c) 2016 Chukong Technologies Inc.\r\n Copyright (c) 2017-2023 Xiamen Yaji Software Co., Ltd.\r\n\r\n https://www.cocos.com/\r\n\r\n Permission is hereby granted, free of charge, to any person obtaining a copy\r\n of this software and associated documentation files (the \"Software\"), to deal\r\n in the Software without restriction, including without limitation the rights to\r\n use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\r\n of the Software, and to permit persons to whom the Software is furnished to do so,\r\n subject to the following conditions:\r\n\r\n The above copyright notice and this permission notice shall be included in\r\n all copies or substantial portions of the Software.\r\n\r\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n THE SOFTWARE.\r\n*/\r\n\r\nimport { ccclass, help, type, requireComponent } from 'cc.decorator';\r\nimport { Component } from '../scene-graph/component';\r\nimport { Sprite } from '../2d/components/sprite';\r\nimport { Label } from '../2d/components/label';\r\nimport { BlendFactor } from '../gfx';\r\n\r\nimport { TMXMapInfo } from './tmx-xml-parser';\r\nimport { TiledTextureGrids, GID, TileFlag, Orientation, StaggerAxis, TMXObjectType, PropertiesInfo, TiledAnimationType, TMXObject, TMXObjectGroupInfo } from './tiled-types';\r\nimport { UITransform } from '../2d/framework/ui-transform';\r\nimport { CCBoolean, Vec2, Color, CCObjectFlags } from '../core';\r\nimport { SpriteFrame } from '../2d/assets';\r\nimport { Node } from '../scene-graph/node';\r\n\r\n/**\r\n * @en Renders the TMX object group.\r\n * @zh 渲染 tmx object group。\r\n * @class TiledObjectGroup\r\n * @extends Component\r\n */\r\n@ccclass('cc.TiledObjectGroup')\r\n@help('i18n:cc.TiledObjectGroup')\r\n@requireComponent(UITransform)\r\nexport class TiledObjectGroup extends Component {\r\n    protected _premultiplyAlpha = false;\r\n\r\n    constructor () {\r\n        super();\r\n    }\r\n\r\n    @type(CCBoolean)\r\n    get premultiplyAlpha (): boolean {\r\n        return this._premultiplyAlpha;\r\n    }\r\n    set premultiplyAlpha (value: boolean) {\r\n        this._premultiplyAlpha = value;\r\n    }\r\n\r\n    /**\r\n     * @en Offset position of child objects.\r\n     * @zh 获取子对象的偏移位置。\r\n     * @method getPositionOffset\r\n     * @return {Vec2}\r\n     * @example\r\n     * let offset = tMXObjectGroup.getPositionOffset();\r\n     */\r\n    public getPositionOffset (): Vec2 | undefined {\r\n        return this._positionOffset;\r\n    }\r\n\r\n    /**\r\n     * @en List of properties stored in a dictionary.\r\n     * @zh 以映射的形式获取属性列表。\r\n     * @method getProperties\r\n     * @return {Object}\r\n     * @example\r\n     * let offset = tMXObjectGroup.getProperties();\r\n     */\r\n    public getProperties (): PropertiesInfo | undefined {\r\n        return this._properties;\r\n    }\r\n\r\n    /**\r\n     * @en Gets the Group name.\r\n     * @zh 获取组名称。\r\n     * @method getGroupName\r\n     * @return {String}\r\n     * @example\r\n     * let groupName = tMXObjectGroup.getGroupName;\r\n     */\r\n    public getGroupName (): string | undefined {\r\n        return this._groupName;\r\n    }\r\n\r\n    /**\r\n     * Return the value for the specific property name\r\n     * @param {String} propertyName\r\n     * @return {Object}\r\n     */\r\n    public getProperty (propertyName: { toString (): string } | string): string | number {\r\n        return this._properties![propertyName.toString()];\r\n    }\r\n\r\n    /**\r\n     * @en\r\n     * Return the object for the specific object name. <br />\r\n     * It will return the 1st object found on the array for the given name.\r\n     * @zh 获取指定的对象。\r\n     * @method getObject\r\n     * @param {String} objectName\r\n     * @return {Object|Null}\r\n     * @example\r\n     * let object = tMXObjectGroup.getObject(\"Group\");\r\n     */\r\n    public getObject (objectName: string): TMXObject | null {\r\n        for (let i = 0, len = this._objects.length; i < len; i++) {\r\n            const obj = this._objects[i];\r\n            if (obj && obj.name === objectName) {\r\n                return obj;\r\n            }\r\n        }\r\n        // object not found\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * @en Gets the objects.\r\n     * @zh 获取对象数组。\r\n     * @method getObjects\r\n     * @return {Array}\r\n     * @example\r\n     * let objects = tMXObjectGroup.getObjects();\r\n     */\r\n    public getObjects (): TMXObject[] {\r\n        return this._objects;\r\n    }\r\n\r\n    protected _groupName?: string;\r\n    protected _positionOffset?: Vec2;\r\n    protected _mapInfo?: TMXMapInfo;\r\n    protected _properties?: PropertiesInfo;\r\n    protected _offset?: Vec2;\r\n    get offset (): Vec2 { return this._offset!; }\r\n    protected _opacity?: number;\r\n    protected _tintColor: Color | null = null;\r\n\r\n    protected _animations?: TiledAnimationType;\r\n    protected _hasAniObj?: boolean;\r\n    protected _texGrids?: TiledTextureGrids;\r\n    protected aniObjects?: {\r\n        object: TMXObject,\r\n        imgNode: Node,\r\n        gridGID: GID\r\n    }[];\r\n    protected _objects: TMXObject[] = [];\r\n\r\n    /**\r\n     * @deprecated since v3.5.0, this is an engine private interface that will be removed in the future.\r\n     */\r\n    public _init (groupInfo: TMXObjectGroupInfo, mapInfo: TMXMapInfo, texGrids: TiledTextureGrids): void {\r\n        const FLIPPED_MASK = TileFlag.FLIPPED_MASK;\r\n        const FLAG_HORIZONTAL = TileFlag.HORIZONTAL;\r\n        const FLAG_VERTICAL = TileFlag.VERTICAL;\r\n\r\n        this._groupName = groupInfo.name;\r\n        this._positionOffset = groupInfo.offset;\r\n        this._mapInfo = mapInfo;\r\n        this._properties = groupInfo.getProperties();\r\n        this._offset = new Vec2(groupInfo.offset.x, -groupInfo.offset.y);\r\n        this._opacity = groupInfo.opacity;\r\n\r\n        if (groupInfo.tintColor) {\r\n            this._tintColor = groupInfo.tintColor;\r\n        }\r\n\r\n        this._texGrids = texGrids;\r\n        this._animations = mapInfo.getTileAnimations();\r\n        this.aniObjects = [];\r\n        this._hasAniObj = false;\r\n\r\n        const mapSize = mapInfo.mapSize;\r\n        const tileSize = mapInfo.tileSize;\r\n        let width = 0;\r\n        let height = 0;\r\n        const colorVal = new Color();\r\n\r\n        const iso = Orientation.ISO === mapInfo.orientation;\r\n\r\n        if (mapInfo.orientation === Orientation.HEX) {\r\n            if (mapInfo.getStaggerAxis() === StaggerAxis.STAGGERAXIS_X) {\r\n                height = tileSize.height * (mapSize.height + 0.5);\r\n                width = (tileSize.width + mapInfo.getHexSideLength()) * Math.floor(mapSize.width / 2) + tileSize.width * (mapSize.width % 2);\r\n            } else {\r\n                width = tileSize.width * (mapSize.width + 0.5);\r\n                height = (tileSize.height + mapInfo.getHexSideLength()) * Math.floor(mapSize.height / 2) + tileSize.height * (mapSize.height % 2);\r\n            }\r\n        } else if (iso) {\r\n            const wh = mapSize.width + mapSize.height;\r\n            width = tileSize.width * 0.5 * wh;\r\n            height = tileSize.height * 0.5 * wh;\r\n        } else {\r\n            width = mapSize.width * tileSize.width;\r\n            height = mapSize.height * tileSize.height;\r\n        }\r\n\r\n        const transComp = this.node._getUITransformComp()!;\r\n        transComp.setContentSize(width, height);\r\n\r\n        const leftTopX = width * transComp.anchorX;\r\n        const leftTopY = height * (1 - transComp.anchorY);\r\n\r\n        const objects = groupInfo.objects;\r\n        const aliveNodes = {};\r\n        for (let i = 0, l = objects.length; i < l; i++) {\r\n            const object = objects[i];\r\n            const objType = object.type;\r\n            object.offset = new Vec2(object.x, object.y);\r\n\r\n            const points = object.points || object.polylinePoints;\r\n            if (points) {\r\n                for (let pi = 0; pi < points.length; pi++) {\r\n                    points[pi].y *= -1;\r\n                }\r\n            }\r\n\r\n            if (iso) {\r\n                const posIdxX = object.x / tileSize.height;\r\n                const posIdxY = object.y / tileSize.height;\r\n                object.x = tileSize.width * 0.5 * (mapSize.height + posIdxX - posIdxY);\r\n                object.y = tileSize.height * 0.5 * (mapSize.width + mapSize.height - posIdxX - posIdxY);\r\n            } else {\r\n                object.y = height - object.y;\r\n            }\r\n\r\n            if (objType === TMXObjectType.TEXT) {\r\n                const textName = `text${object.id}`;\r\n                aliveNodes[textName] = true;\r\n\r\n                let textNode = this.node.getChildByName(textName);\r\n                if (!textNode) {\r\n                    textNode = new Node();\r\n                }\r\n\r\n                textNode.setRotationFromEuler(0, 0, -object.rotation);\r\n                textNode.setPosition(object.x - leftTopX, object.y - leftTopY);\r\n                textNode.name = textName;\r\n                textNode.parent = this.node;\r\n                textNode.setSiblingIndex(i);\r\n                textNode.layer = this.node.layer;\r\n\r\n                let label = textNode.getComponent(Label);\r\n                if (!label) {\r\n                    label = textNode.addComponent(Label);\r\n                }\r\n\r\n                const textTransComp = textNode._getUITransformComp()!;\r\n                textNode.active = object.visible;\r\n                textTransComp.anchorX = 0;\r\n                textTransComp.anchorY = 1;\r\n\r\n                if (this._tintColor) {\r\n                    colorVal.set(this._tintColor);\r\n                    colorVal.a *= this._opacity / 255;\r\n                    label.color.set(colorVal);\r\n                } else {\r\n                    const c = label.color as Color;\r\n                    c.a *= this._opacity / 255;\r\n                }\r\n\r\n                label.overflow = Label.Overflow.SHRINK;\r\n                label.lineHeight = object.height;\r\n                label.string = object.text;\r\n                label.horizontalAlign = object.halign;\r\n                label.verticalAlign = object.valign;\r\n                label.fontSize = object.pixelsize;\r\n\r\n                textTransComp.setContentSize(object.width, object.height);\r\n            } else if (objType === TMXObjectType.IMAGE) {\r\n                const gid = object.gid;\r\n                const gridGID: GID = (((gid as unknown as number) & FLIPPED_MASK) >>> 0) as any;\r\n                const grid = texGrids.get(gridGID);\r\n                if (!grid) continue;\r\n                const tileset = grid.tileset;\r\n                const imgName = `img${object.id}`;\r\n                aliveNodes[imgName] = true;\r\n                let imgNode = this.node.getChildByName(imgName);\r\n                object.width = object.width || grid.width;\r\n                object.height = object.height || grid.height;\r\n\r\n                // Delete image nodes implemented as private nodes\r\n                // Use cc.Node to implement node-level requirements\r\n                if (imgNode && (imgNode._objFlags & CCObjectFlags.HideInHierarchy)) {\r\n                    imgNode.removeFromParent();\r\n                    imgNode.hideFlags |= CCObjectFlags.DontSave;\r\n                    imgNode.destroy();\r\n                    imgNode = null;\r\n                }\r\n\r\n                if (!imgNode) {\r\n                    imgNode = new Node();\r\n                }\r\n\r\n                if (this._animations.get(gridGID)) {\r\n                    this.aniObjects.push({\r\n                        object,\r\n                        imgNode,\r\n                        gridGID,\r\n                    });\r\n                    this._hasAniObj = true;\r\n                }\r\n\r\n                const tileOffsetX = tileset.tileOffset.x;\r\n                const tileOffsetY = tileset.tileOffset.y;\r\n                imgNode.active = object.visible;\r\n                imgNode.setRotationFromEuler(0, 0, -object.rotation);\r\n                imgNode.setPosition(object.x - leftTopX, object.y - leftTopY);\r\n                imgNode.name = imgName;\r\n                imgNode.parent = this.node;\r\n                imgNode.setSiblingIndex(i);\r\n                imgNode.layer = this.node.layer;\r\n\r\n                let sprite = imgNode.getComponent(Sprite);\r\n                if (!sprite) {\r\n                    sprite = imgNode.addComponent(Sprite);\r\n                }\r\n\r\n                const imgTrans = imgNode._getUITransformComp()!;\r\n                if (iso) {\r\n                    imgTrans.anchorX = 0.5 + tileOffsetX / object.width;\r\n                    imgTrans.anchorY = tileOffsetY / object.height;\r\n                } else {\r\n                    imgTrans.anchorX = tileOffsetX / object.width;\r\n                    imgTrans.anchorY = tileOffsetY / object.height;\r\n                }\r\n\r\n                if (this._tintColor) {\r\n                    colorVal.set(this._tintColor);\r\n                    colorVal.a *= this._opacity / 255;\r\n                    sprite.color.set(colorVal);\r\n                } else {\r\n                    const c = sprite.color as Color;\r\n                    c.a *= this._opacity / 255;\r\n                }\r\n\r\n                sprite.sizeMode = Sprite.SizeMode.CUSTOM;\r\n\r\n                // HACK: we should support _premultiplyAlpha when group had material\r\n                const srcBlendFactor = this._premultiplyAlpha ? BlendFactor.ONE : BlendFactor.SRC_ALPHA;\r\n                if (sprite.srcBlendFactor !== srcBlendFactor) {\r\n                    sprite.srcBlendFactor = srcBlendFactor;\r\n                    if (sprite.material) {\r\n                        sprite._updateBlendFunc();\r\n                    }\r\n                }\r\n\r\n                let spf = grid.spriteFrame;\r\n                if (!spf) {\r\n                    spf = new SpriteFrame();\r\n                } else {\r\n                    spf = spf.clone();\r\n                }\r\n                if (((gid as unknown as number) & FLAG_HORIZONTAL) >>> 0) {\r\n                    spf.flipUVX = !spf.flipUVX;\r\n                }\r\n                if (((gid as unknown as number) & FLAG_VERTICAL) >>> 0) {\r\n                    spf.flipUVY = !spf.flipUVY;\r\n                }\r\n                spf.rotated = grid._rotated!;\r\n                spf.rect = grid._rect!;\r\n                sprite.spriteFrame = spf;\r\n\r\n                imgTrans.setContentSize(object.width, object.height);\r\n\r\n                sprite._markForUpdateRenderData();\r\n            }\r\n        }\r\n        this._objects = objects;\r\n\r\n        // destroy useless node\r\n        const children = this.node.children;\r\n        const uselessExp = /^(?:img|text)\\d+$/;\r\n        for (let i = 0, n = children.length; i < n; i++) {\r\n            const c = children[i];\r\n            const cName = c.name;\r\n            const isUseless = uselessExp.test(cName);\r\n            if (isUseless && !aliveNodes[cName]) c.destroy();\r\n        }\r\n    }\r\n\r\n    public update (dt: number): void {\r\n        if (!this._hasAniObj) {\r\n            return;\r\n        }\r\n\r\n        const aniObjects = this.aniObjects!;\r\n        const _texGrids = this._texGrids!;\r\n        const iso = Orientation.ISO === this._mapInfo!.orientation;\r\n\r\n        for (let i = 0, len = aniObjects.length; i < len; i++) {\r\n            const aniObj = aniObjects[i];\r\n            const gridGID = aniObj.gridGID;\r\n            const grid = _texGrids.get(gridGID);\r\n            if (!grid) {\r\n                continue;\r\n            }\r\n\r\n            const tileset = grid.tileset;\r\n            const object = aniObj.object;\r\n            const imgNode: Node = aniObj.imgNode;\r\n\r\n            const tileOffsetX = tileset.tileOffset.x;\r\n            const tileOffsetY = tileset.tileOffset.y;\r\n            const imgTrans = imgNode._getUITransformComp()!;\r\n            if (iso) {\r\n                imgTrans.anchorX = 0.5 + tileOffsetX / object.width;\r\n                imgTrans.anchorY = tileOffsetY / object.height;\r\n            } else {\r\n                imgTrans.anchorX = tileOffsetX / object.width;\r\n                imgTrans.anchorY = tileOffsetY / object.height;\r\n            }\r\n\r\n            const sp = imgNode.getComponent(Sprite)!;\r\n            const spf = sp.spriteFrame!;\r\n\r\n            spf.rotated = grid._rotated!;\r\n            spf.rect = grid._rect!;\r\n\r\n            sp.spriteFrame = spf;\r\n            sp._markForUpdateRenderData();\r\n        }\r\n    }\r\n}\r\n","/*\r\n Copyright (c) 2013-2016 Chukong Technologies Inc.\r\n Copyright (c) 2017-2023 Xiamen Yaji Software Co., Ltd.\r\n\r\n https://www.cocos.com/\r\n\r\n Permission is hereby granted, free of charge, to any person obtaining a copy\r\n of this software and associated documentation files (the \"Software\"), to deal\r\n in the Software without restriction, including without limitation the rights to\r\n use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\r\n of the Software, and to permit persons to whom the Software is furnished to do so,\r\n subject to the following conditions:\r\n\r\n The above copyright notice and this permission notice shall be included in\r\n all copies or substantial portions of the Software.\r\n\r\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n THE SOFTWARE.\r\n*/\r\n\r\nimport { ccclass, type, serializable } from 'cc.decorator';\r\nimport { Asset } from '../asset/assets/asset';\r\nimport { CCString, Size } from '../core';\r\nimport { SpriteFrame } from '../2d/assets';\r\nimport { TextAsset } from '../asset/assets';\r\n\r\n/**\r\n * @en\r\n * Class for tiled map asset handling.\r\n * @zh\r\n * 用于获取 tiled map 资源类\r\n * @class TiledMapAsset\r\n * @extends Asset\r\n *\r\n */\r\n@ccclass('cc.TiledMapAsset')\r\nexport class TiledMapAsset extends Asset {\r\n    constructor () {\r\n        super();\r\n    }\r\n    @serializable\r\n    tmxXmlStr = '';\r\n\r\n    @serializable\r\n    @type([TextAsset])\r\n    tsxFiles: TextAsset[] = [];\r\n\r\n    @serializable\r\n    @type([CCString])\r\n    tsxFileNames: string[] = [];\r\n\r\n    /**\r\n     * @en\r\n     * SpriteFrame array\r\n     * @zh\r\n     * SpriteFrame 数组\r\n     */\r\n    @serializable\r\n    @type([SpriteFrame])\r\n    spriteFrames: SpriteFrame[] = [];\r\n\r\n    /**\r\n     * @en\r\n     * ImageLayerSpriteFrame array\r\n     * @zh\r\n     * ImageLayerSpriteFrame 数组\r\n     * @property {SpriteFrame[]} imageLayerSpriteFrame\r\n     */\r\n    @serializable\r\n    @type([SpriteFrame])\r\n    imageLayerSpriteFrame: SpriteFrame[] = [];\r\n\r\n    /**\r\n     * @en\r\n     * Name of each object in imageLayerSpriteFrame\r\n     * @zh\r\n     * 每个 imageLayerSpriteFrame 名称\r\n     * @property {String[]} imageLayerTextureNames\r\n     */\r\n    @serializable\r\n    @type([CCString])\r\n    imageLayerSpriteFrameNames: string[] = [];\r\n\r\n    /**\r\n     * @en\r\n     * Name of each object in spriteFrames\r\n     * @zh\r\n     * 每个 SpriteFrame 名称\r\n     * @property {String[]} spriteFrameNames\r\n     */\r\n    @serializable\r\n    @type([CCString])\r\n    spriteFrameNames: string[] = [];\r\n\r\n    /**\r\n     * @en\r\n     * Size of each object in spriteFrames\r\n     * @zh\r\n     * 每个 SpriteFrame 的大小\r\n     * @property {Size[]} spriteFrameSizes\r\n     */\r\n    @serializable\r\n    @type([Size])\r\n    spriteFrameSizes: Size[] = [];\r\n}\r\n","/*\r\n Copyright (c) 2020-2023 Xiamen Yaji Software Co., Ltd.\r\n\r\n https://www.cocos.com/\r\n\r\n Permission is hereby granted, free of charge, to any person obtaining a copy\r\n of this software and associated documentation files (the \"Software\"), to deal\r\n in the Software without restriction, including without limitation the rights to\r\n use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\r\n of the Software, and to permit persons to whom the Software is furnished to do so,\r\n subject to the following conditions:\r\n\r\n The above copyright notice and this permission notice shall be included in\r\n all copies or substantial portions of the Software.\r\n\r\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n THE SOFTWARE.\r\n*/\r\n\r\nimport { ccclass, displayOrder, executeInEditMode, help, menu, requireComponent, type, serializable, editable } from 'cc.decorator';\r\nimport { EDITOR, JSB } from 'internal:constants';\r\nimport { Component } from '../scene-graph/component';\r\nimport { UITransform } from '../2d/framework';\r\nimport { GID, Orientation, PropertiesInfo, Property, RenderOrder, StaggerAxis, StaggerIndex, TiledAnimationType, TiledTextureGrids, TileFlag,\r\n    TMXImageLayerInfo, TMXLayerInfo, TMXObjectGroupInfo, TMXObjectType, TMXTilesetInfo } from './tiled-types';\r\nimport { TMXMapInfo } from './tmx-xml-parser';\r\nimport { TiledLayer } from './tiled-layer';\r\nimport { TiledObjectGroup } from './tiled-object-group';\r\nimport { TiledMapAsset } from './tiled-map-asset';\r\nimport { Sprite } from '../2d/components/sprite';\r\nimport { fillTextureGrids, enableTexelOffsetUtils } from './tiled-utils';\r\nimport { Size, Vec2, logID, Color, sys, warnID } from '../core';\r\nimport { SpriteFrame } from '../2d/assets';\r\nimport { NodeEventType } from '../scene-graph/node-event';\r\nimport { Node } from '../scene-graph';\r\n\r\ninterface ImageExtendedNode extends Node {\r\n    layerInfo: TMXImageLayerInfo;\r\n    _offset: Vec2;\r\n}\r\n\r\n/**\r\n * @en Renders a TMX Tile Map in the scene.\r\n * @zh 在场景中渲染一个 tmx 格式的 Tile Map。\r\n * @class TiledMap\r\n * @extends Component\r\n */\r\n@ccclass('cc.TiledMap')\r\n@help('i18n:cc.TiledMap')\r\n@menu('TiledMap/TiledMap')\r\n@requireComponent(UITransform)\r\n@executeInEditMode\r\nexport class TiledMap extends Component {\r\n    // store all layer gid corresponding texture info, index is gid, format likes '[gid0]=tex-info,[gid1]=tex-info, ...'\r\n    _texGrids: TiledTextureGrids = new Map();\r\n    // store all tileset texture, index is tileset index, format likes '[0]=texture0, [1]=texture1, ...'\r\n    _textures: SpriteFrame[] = [];\r\n    _tilesets: TMXTilesetInfo[] = [];\r\n\r\n    _animations: TiledAnimationType = new Map();\r\n    _imageLayers: TMXImageLayerInfo[] = [];\r\n    _layers: TiledLayer[] = [];\r\n    _groups: TiledObjectGroup[] = [];\r\n    _images: ImageExtendedNode[] = [];\r\n    _properties: PropertiesInfo = {} as any;\r\n    _tileProperties: Map<GID, PropertiesInfo> = new Map();\r\n\r\n    _mapInfo: TMXMapInfo | null = null;\r\n    _mapSize: Size = new Size(0, 0);\r\n    _tileSize: Size = new Size(0, 0);\r\n\r\n    _mapOrientation = Orientation.ORTHO;\r\n\r\n    static Orientation = Orientation;\r\n    static Property = Property;\r\n    static TileFlag = TileFlag;\r\n    static StaggerAxis = StaggerAxis;\r\n    static StaggerIndex = StaggerIndex;\r\n    static TMXObjectType = TMXObjectType;\r\n    static RenderOrder = RenderOrder;\r\n\r\n    private _isApplied = false;\r\n\r\n    @serializable\r\n    _tmxFile: TiledMapAsset | null = null;\r\n    /**\r\n     * @en The TiledMap Asset.\r\n     * @zh TiledMap 资源。\r\n     * @property {TiledMapAsset} tmxAsset\r\n     * @default \"\"\r\n     */\r\n\r\n    @type(TiledMapAsset)\r\n    @displayOrder(7)\r\n    get tmxAsset (): TiledMapAsset {\r\n        return this._tmxFile!;\r\n    }\r\n\r\n    set tmxAsset (value: TiledMapAsset) {\r\n        if (this._tmxFile !== value || EDITOR) {\r\n            this._tmxFile = value;\r\n            this._applyFile();\r\n            this._isApplied = true;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @en\r\n     * Whether or not enabled tiled map auto culling. If you set the TiledMap skew or rotation, then need to manually\r\n     *  disable this, otherwise, the rendering will be wrong.\r\n     * @zh\r\n     * 是否开启瓦片地图的自动裁减功能。瓦片地图如果设置了 skew, rotation 或者采用了摄像机的话，需要手动关闭，否则渲染会出错。\r\n     */\r\n    @serializable\r\n    protected _enableCulling = true;\r\n    @editable\r\n    get enableCulling (): boolean {\r\n        return this._enableCulling;\r\n    }\r\n    set enableCulling (value) {\r\n        this._enableCulling = value;\r\n        const layers = this._layers;\r\n        for (let i = 0; i < layers.length; ++i) {\r\n            layers[i].enableCulling = value;\r\n        }\r\n    }\r\n\r\n    @serializable\r\n    protected cleanupImageCache = true;\r\n\r\n    constructor () {\r\n        super();\r\n    }\r\n\r\n    /**\r\n     * @en Gets the map size.\r\n     * @zh 获取地图大小。\r\n     * @method getMapSize\r\n     * @return {Size}\r\n     * @example\r\n     * let mapSize = tiledMap.getMapSize();\r\n     * cc.log(\"Map Size: \" + mapSize);\r\n     */\r\n    getMapSize (): Size {\r\n        return this._mapSize;\r\n    }\r\n\r\n    /**\r\n     * @en Gets the tile size.\r\n     * @zh 获取地图背景中 tile 元素的大小。\r\n     * @method getTileSize\r\n     * @return {Size}\r\n     * @example\r\n     * let tileSize = tiledMap.getTileSize();\r\n     * cc.log(\"Tile Size: \" + tileSize);\r\n     */\r\n    getTileSize (): Size {\r\n        return this._tileSize;\r\n    }\r\n\r\n    /**\r\n     * @en map orientation.\r\n     * @zh 获取地图方向。\r\n     * @method getMapOrientation\r\n     * @return {Number}\r\n     * @example\r\n     * let mapOrientation = tiledMap.getMapOrientation();\r\n     * cc.log(\"Map Orientation: \" + mapOrientation);\r\n     */\r\n    getMapOrientation (): Orientation {\r\n        return this._mapOrientation;\r\n    }\r\n\r\n    /**\r\n     * @en object groups.\r\n     * @zh 获取所有的对象层。\r\n     * @method getObjectGroups\r\n     * @return {TiledObjectGroup[]}\r\n     * @example\r\n     * let objGroups = titledMap.getObjectGroups();\r\n     * for (let i = 0; i < objGroups.length; ++i) {\r\n     *     cc.log(\"obj: \" + objGroups[i]);\r\n     * }\r\n     */\r\n    getObjectGroups (): TiledObjectGroup[] {\r\n        return this._groups;\r\n    }\r\n\r\n    /**\r\n     * @en Return the TMXObjectGroup for the specific group.\r\n     * @zh 获取指定的 TMXObjectGroup。\r\n     * @method getObjectGroup\r\n     * @param {String} groupName\r\n     * @return {TiledObjectGroup}\r\n     * @example\r\n     * let group = titledMap.getObjectGroup(\"Players\");\r\n     * cc.log(\"ObjectGroup: \" + group);\r\n     */\r\n    getObjectGroup (groupName: string): TiledObjectGroup | null {\r\n        const groups = this._groups;\r\n        for (let i = 0, l = groups.length; i < l; i++) {\r\n            const group = groups[i];\r\n            if (group && group.getGroupName() === groupName) {\r\n                return group;\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * @en Gets the map properties.\r\n     * @zh 获取地图的属性。\r\n     * @method getProperties\r\n     * @return {Object[]}\r\n     * @example\r\n     * let properties = titledMap.getProperties();\r\n     * for (let i = 0; i < properties.length; ++i) {\r\n     *     cc.log(\"Properties: \" + properties[i]);\r\n     * }\r\n     */\r\n    getProperties (): PropertiesInfo {\r\n        return this._properties;\r\n    }\r\n\r\n    /**\r\n     * @en Return All layers array.\r\n     * @zh 返回包含所有 layer 的数组。\r\n     * @method getLayers\r\n     * @returns {TiledLayer[]}\r\n     * @example\r\n     * let layers = titledMap.getLayers();\r\n     * for (let i = 0; i < layers.length; ++i) {\r\n     *     cc.log(\"Layers: \" + layers[i]);\r\n     * }\r\n     */\r\n    getLayers (): TiledLayer[] {\r\n        return this._layers;\r\n    }\r\n\r\n    /**\r\n     * @en return the cc.TiledLayer for the specific layer.\r\n     * @zh 获取指定名称的 layer。\r\n     * @method getLayer\r\n     * @param {String} layerName\r\n     * @return {TiledLayer}\r\n     * @example\r\n     * let layer = titledMap.getLayer(\"Player\");\r\n     * cc.log(layer);\r\n     */\r\n    getLayer (layerName): TiledLayer | null {\r\n        const layers = this._layers;\r\n        for (let i = 0, l = layers.length; i < l; i++) {\r\n            const layer = layers[i];\r\n            if (layer && layer.getLayerName() === layerName) {\r\n                return layer;\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    protected _changeLayer (layerName, replaceLayer): void {\r\n        const layers = this._layers;\r\n        for (let i = 0, l = layers.length; i < l; i++) {\r\n            const layer = layers[i];\r\n            if (layer && layer.getLayerName() === layerName) {\r\n                layers[i] = replaceLayer;\r\n                return;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @en Return the value for the specific property name.\r\n     * @zh 通过属性名称，获取指定的属性。\r\n     * @method getProperty\r\n     * @param {String} propertyName\r\n     * @return {String}\r\n     * @example\r\n     * let property = titledMap.getProperty(\"info\");\r\n     * cc.log(\"Property: \" + property);\r\n     */\r\n    getProperty (propertyName: string): string | number {\r\n        return this._properties[propertyName.toString()];\r\n    }\r\n\r\n    /**\r\n     * @en Return properties dictionary for tile GID.\r\n     * @zh 通过 GID ，获取指定的属性。\r\n     * @method getPropertiesForGID\r\n     * @param {Number} GID\r\n     * @return {Object}\r\n     * @example\r\n     * let properties = titledMap.getPropertiesForGID(GID);\r\n     * cc.log(\"Properties: \" + properties);\r\n     */\r\n    getPropertiesForGID (gid: GID): PropertiesInfo | undefined {\r\n        return this._tileProperties.get(gid);\r\n    }\r\n\r\n    /**\r\n     * @en Enables or disables texel offset correction to fix rendering issues like grid edge artifacts.\r\n     * This function adjusts the texture coordinates of each grid in the tilemap by applying\r\n     * a 0.5-pixel offset, ensuring that grid edges do not show black lines or artifacts caused by\r\n     * texture sampling inaccuracies. This is especially useful for tile-based rendering systems.\r\n     * @zh 启用或禁用像素偏移修正，用于修复网格边缘的渲染问题（如黑线）。此函数通过对每个 tilemap 网格的纹理坐标应用 0.5 像素\r\n     * 的偏移来调整，确保网格边缘不会出现因纹理采样不准确导致的黑线或其他伪影问题。对基于图块的渲染系统特别有用。\r\n     *\r\n     * @param enable\r\n     * @en Whether to enable (true) or disable (false) the texel offset correction.\r\n     * @zh 是否启用 (true) 或禁用 (false) 像素偏移修正。\r\n     */\r\n    enableTexelOffset (enable: boolean): void {\r\n        enableTexelOffsetUtils(enable);\r\n    }\r\n\r\n    __preload (): void {\r\n        if (!this._tmxFile) {\r\n            return;\r\n        }\r\n        if (this._isApplied === false) {\r\n            this._applyFile();\r\n            this._isApplied = true;\r\n        }\r\n    }\r\n\r\n    onEnable (): void {\r\n        this.node.on(NodeEventType.ANCHOR_CHANGED, this._syncAnchorPoint, this);\r\n    }\r\n\r\n    onDisable (): void {\r\n        this.node.off(NodeEventType.ANCHOR_CHANGED, this._syncAnchorPoint, this);\r\n    }\r\n\r\n    _applyFile (): void {\r\n        const spriteFrames: SpriteFrame[] = [];\r\n        const spriteFramesCache = {};\r\n\r\n        const file = this._tmxFile;\r\n\r\n        if (file) {\r\n            // let texValues = file.textures;\r\n            let spfNames: string[] = file.spriteFrameNames;\r\n            const spfSizes: Size[] = file.spriteFrameSizes;\r\n            const fSpriteFrames: SpriteFrame[] = file.spriteFrames;\r\n            const spfTexturesMap: { [key: string]: SpriteFrame } = {};\r\n            const spfTextureSizeMap: { [key: string]: Size } = {};\r\n\r\n            for (let i = 0; i < spfNames.length; ++i) {\r\n                const texName = spfNames[i];\r\n                // textures[texName] = texValues[i];\r\n                spfTextureSizeMap[texName] = spfSizes[i];\r\n                spriteFrames[i] = fSpriteFrames[i];\r\n                const frame = spriteFrames[i];\r\n                if (frame) {\r\n                    spriteFramesCache[frame.name] = frame;\r\n                    spfTexturesMap[texName] = frame;\r\n                }\r\n            }\r\n\r\n            const imageLayerTextures: { [key: string]: SpriteFrame } = {};\r\n            const texValues = file.imageLayerSpriteFrame;\r\n            spfNames = file.imageLayerSpriteFrameNames;\r\n            for (let i = 0; i < texValues.length; ++i) {\r\n                imageLayerTextures[spfNames[i]] = texValues[i];\r\n            }\r\n\r\n            const tsxFileNames = file.tsxFileNames;\r\n            const tsxFiles = file.tsxFiles;\r\n            const tsxContentMap: { [key: string]: string } = {};\r\n            for (let i = 0; i < tsxFileNames.length; ++i) {\r\n                if (tsxFileNames[i].length > 0) {\r\n                    tsxContentMap[tsxFileNames[i]] = tsxFiles[i].text;\r\n                }\r\n            }\r\n\r\n            const mapInfo = new TMXMapInfo(file.tmxXmlStr, tsxContentMap, spfTexturesMap, spfTextureSizeMap, imageLayerTextures);\r\n            const tilesets = mapInfo.getTilesets();\r\n            if (!tilesets || tilesets.length === 0) {\r\n                logID(7241);\r\n            }\r\n\r\n            this._buildWithMapInfo(mapInfo);\r\n        } else {\r\n            this._releaseMapInfo();\r\n        }\r\n    }\r\n\r\n    _releaseMapInfo (): void {\r\n        // remove the layers & object groups added before\r\n        const layers = this._layers;\r\n        for (let i = 0, l = layers.length; i < l; i++) {\r\n            layers[i].node.parent?.off(NodeEventType.SIZE_CHANGED, layers[i].updateCulling, layers[i]);\r\n            layers[i].node.parent?.off(NodeEventType.TRANSFORM_CHANGED, layers[i].updateCulling, layers[i]);\r\n            layers[i].node.removeFromParent();\r\n            layers[i].node.destroy();\r\n        }\r\n        layers.length = 0;\r\n\r\n        const groups = this._groups;\r\n        for (let i = 0, l = groups.length; i < l; i++) {\r\n            groups[i].node.removeFromParent();\r\n            groups[i].node.destroy();\r\n        }\r\n        groups.length = 0;\r\n\r\n        const images = this._images;\r\n        for (let i = 0, l = images.length; i < l; i++) {\r\n            images[i].removeFromParent();\r\n            images[i].destroy();\r\n        }\r\n        images.length = 0;\r\n    }\r\n\r\n    _syncAnchorPoint (): void {\r\n        const anchor = this.node._getUITransformComp()!.anchorPoint;\r\n        const leftTopX = this.node._getUITransformComp()!.width * anchor.x;\r\n        const leftTopY = this.node._getUITransformComp()!.height * (1 - anchor.y);\r\n        let i: number;\r\n        let l: number;\r\n        for (i = 0, l = this._layers.length; i < l; i++) {\r\n            const layerInfo = this._layers[i];\r\n            const layerNode = layerInfo.node;\r\n            // Tiled layer sync anchor to map because it's old behavior,\r\n            // do not change the behavior avoid influence user's existed logic.\r\n            layerNode._getUITransformComp()!.setAnchorPoint(anchor);\r\n        }\r\n\r\n        for (i = 0, l = this._groups.length; i < l; i++) {\r\n            const groupInfo = this._groups[i];\r\n            const groupNode = groupInfo.node._getUITransformComp()!;\r\n            // Group layer not sync anchor to map because it's old behavior,\r\n            // do not change the behavior avoid influence user's existing logic.\r\n            groupNode.anchorX = 0.5;\r\n            groupNode.anchorY = 0.5;\r\n            const x = groupInfo.offset.x - leftTopX + groupNode.width * groupNode.anchorX;\r\n            const y = groupInfo.offset.y + leftTopY - groupNode.height * groupNode.anchorY;\r\n            groupInfo.node.setPosition(x, y);\r\n        }\r\n\r\n        for (i = 0, l = this._images.length; i < l; i++) {\r\n            const image = this._images[i]._getUITransformComp()!;\r\n            image.anchorX = 0.5;\r\n            image.anchorY = 0.5;\r\n            const x = this._images[i]._offset.x - leftTopX + image.width * image.anchorX;\r\n            const y = this._images[i]._offset.y + leftTopY - image.height * image.anchorY;\r\n            this._images[i].setPosition(x, y);\r\n        }\r\n    }\r\n\r\n    _fillAniGrids (texGrids: TiledTextureGrids, animations: TiledAnimationType): void {\r\n        for (const i of animations.keys()) {\r\n            const animation = animations.get(i);\r\n            if (!animation) continue;\r\n            const frames = animation.frames;\r\n            for (let j = 0; j < frames.length; j++) {\r\n                const frame = frames[j];\r\n                frame.grid = texGrids.get(frame.tileid)!;\r\n            }\r\n        }\r\n    }\r\n\r\n    _buildLayerAndGroup (): void {\r\n        const tilesets = this._tilesets;\r\n        const texGrids = this._texGrids;\r\n        const animations = this._animations;\r\n        texGrids.clear();\r\n\r\n        for (let i = 0, l = tilesets.length; i < l; ++i) {\r\n            const tilesetInfo = tilesets[i];\r\n            if (!tilesetInfo) continue;\r\n            if (!tilesetInfo.sourceImage) {\r\n                warnID(16406, i);\r\n                continue;\r\n            }\r\n            fillTextureGrids(tilesetInfo, texGrids, tilesetInfo.sourceImage);\r\n        }\r\n        this._fillAniGrids(texGrids, animations);\r\n\r\n        let layers = this._layers;\r\n        let groups = this._groups;\r\n        let images = this._images;\r\n        const oldNodeNames: { [key: string]: boolean } = {};\r\n        for (let i = 0, n = layers.length; i < n; i++) {\r\n            oldNodeNames[layers[i].node.name] = true;\r\n        }\r\n        for (let i = 0, n = groups.length; i < n; i++) {\r\n            oldNodeNames[groups[i].node.name] = true;\r\n        }\r\n        for (let i = 0, n = images.length; i < n; i++) {\r\n            oldNodeNames[images[i].name] = true;\r\n        }\r\n\r\n        layers = this._layers = [];\r\n        groups = this._groups = [];\r\n        images = this._images = [];\r\n\r\n        const mapInfo = this._mapInfo!;\r\n        const node = this.node;\r\n        const layerInfos = mapInfo.getAllChildren();\r\n        const textures = this._textures;\r\n        let maxWidth = 0;\r\n        let maxHeight = 0;\r\n\r\n        if (layerInfos && layerInfos.length > 0) {\r\n            for (let i = 0, len = layerInfos.length; i < len; i++) {\r\n                const layerInfo = layerInfos[i];\r\n                const name = layerInfo.name;\r\n\r\n                let child: ImageExtendedNode = this.node.getChildByName(name) as any;\r\n                oldNodeNames[name] = false;\r\n\r\n                if (!child) {\r\n                    child = (new Node()) as unknown as any;\r\n                    child.name = name;\r\n                    child.layer = node.layer;\r\n                    node.addChild(child);\r\n                }\r\n\r\n                child.setSiblingIndex(i);\r\n                child.active = layerInfo.visible;\r\n\r\n                if (layerInfo instanceof TMXLayerInfo) {\r\n                    let layer = child.getComponent(TiledLayer);\r\n                    if (!layer) {\r\n                        layer = child.addComponent(TiledLayer);\r\n                    }\r\n\r\n                    layer.init(layerInfo, mapInfo, tilesets, textures, texGrids);\r\n                    layer.enableCulling = this._enableCulling;\r\n\r\n                    // tell the layerinfo to release the ownership of the tiles map.\r\n                    layerInfo.ownTiles = false;\r\n                    layers.push(layer);\r\n                } else if (layerInfo instanceof TMXObjectGroupInfo) {\r\n                    let group = child.getComponent(TiledObjectGroup);\r\n                    if (!group) {\r\n                        group = child.addComponent(TiledObjectGroup);\r\n                    }\r\n                    group._init(layerInfo, mapInfo, texGrids);\r\n                    groups.push(group);\r\n                } else if (layerInfo instanceof TMXImageLayerInfo) {\r\n                    const spriteFrame = layerInfo.sourceImage;\r\n\r\n                    child.layerInfo = layerInfo;\r\n                    child._offset = new Vec2(layerInfo.offset.x, -layerInfo.offset.y);\r\n\r\n                    let image = child.getComponent(Sprite);\r\n                    if (!image) {\r\n                        image = child.addComponent(Sprite);\r\n                    }\r\n\r\n                    const color = image.color as Color;\r\n                    color.a *= layerInfo.opacity;\r\n\r\n                    image.spriteFrame = spriteFrame!;\r\n                    let width = spriteFrame!.width;\r\n                    let height = spriteFrame!.height;\r\n                    if (spriteFrame!.original) {\r\n                        width = spriteFrame!.originalSize.width;\r\n                        height = spriteFrame!.originalSize.height;\r\n                    }\r\n\r\n                    child._getUITransformComp()!.setContentSize(width, height);\r\n                    images.push(child);\r\n                }\r\n\r\n                maxWidth = Math.max(maxWidth, child._getUITransformComp()!.width);\r\n                maxHeight = Math.max(maxHeight, child._getUITransformComp()!.height);\r\n            }\r\n        }\r\n\r\n        const children = node.children;\r\n        for (let i = 0, n = children.length; i < n; i++) {\r\n            const c = children[i];\r\n            if (oldNodeNames[c.name]) {\r\n                c.destroy();\r\n            }\r\n        }\r\n\r\n        this.node._getUITransformComp()!.setContentSize(maxWidth, maxHeight);\r\n        this._syncAnchorPoint();\r\n    }\r\n\r\n    protected _buildWithMapInfo (mapInfo: TMXMapInfo): void {\r\n        this._mapInfo = mapInfo;\r\n        this._mapSize = mapInfo.getMapSize();\r\n        this._tileSize = mapInfo.getTileSize();\r\n        this._mapOrientation = mapInfo.orientation!;\r\n        this._properties = mapInfo.properties;\r\n        this._tileProperties = mapInfo.getTileProperties();\r\n        this._imageLayers = mapInfo.getImageLayers();\r\n        this._animations = mapInfo.getTileAnimations();\r\n        this._tilesets = mapInfo.getTilesets();\r\n\r\n        const tilesets = this._tilesets;\r\n        this._textures.length = 0;\r\n\r\n        const totalTextures: SpriteFrame[] = [];\r\n        for (let i = 0, l = tilesets.length; i < l; ++i) {\r\n            const tilesetInfo = tilesets[i];\r\n            if (!tilesetInfo || !tilesetInfo.sourceImage) continue;\r\n            this._textures[i] = tilesetInfo.sourceImage;\r\n            totalTextures.push(tilesetInfo.sourceImage);\r\n        }\r\n\r\n        for (let i = 0; i < this._imageLayers.length; i++) {\r\n            const imageLayer = this._imageLayers[i];\r\n            if (!imageLayer || !imageLayer.sourceImage) continue;\r\n            totalTextures.push(imageLayer.sourceImage);\r\n        }\r\n\r\n        this._buildLayerAndGroup();\r\n        if (this.cleanupImageCache) {\r\n            this._textures.forEach((tex) => {\r\n                this.doCleanupImageCache(tex);\r\n            });\r\n        }\r\n    }\r\n\r\n    doCleanupImageCache (texture): void {\r\n        if (texture._image instanceof HTMLImageElement) {\r\n            texture._image.src = '';\r\n            if (JSB) texture._image.destroy();\r\n        } else if (sys.hasFeature(sys.Feature.IMAGE_BITMAP) && texture._image instanceof ImageBitmap) {\r\n            if (texture._image.close) texture._image.close();\r\n        }\r\n        texture._image = null;\r\n    }\r\n\r\n    lateUpdate (dt: number): void {\r\n        const animations = this._animations;\r\n        const texGrids = this._texGrids;\r\n        for (const aniGID of animations.keys()) {\r\n            const animation = animations.get(aniGID)!;\r\n            const frames = animation.frames;\r\n            let frame = frames[animation.frameIdx];\r\n            animation.dt += dt;\r\n            if (frame.duration < animation.dt) {\r\n                animation.dt = 0;\r\n                animation.frameIdx++;\r\n                if (animation.frameIdx >= frames.length) {\r\n                    animation.frameIdx = 0;\r\n                }\r\n                frame = frames[animation.frameIdx];\r\n            }\r\n            texGrids.set(aniGID, frame.grid!);\r\n        }\r\n        const layers = this.getLayers();\r\n        for (let i = 0, l = layers.length; i < l; i++) {\r\n            const layer = layers[i];\r\n            if (layer.hasAnimation() || layer.node.hasChangedFlags) {\r\n                layer._markForUpdateRenderData();\r\n            }\r\n        }\r\n    }\r\n}\r\n","/*\r\n Copyright (c) 2017-2023 Xiamen Yaji Software Co., Ltd.\r\n\r\n http://www.cocos.com\r\n\r\n Permission is hereby granted, free of charge, to any person obtaining a copy\r\n of this software and associated documentation files (the \"Software\"), to deal\r\n in the Software without restriction, including without limitation the rights to\r\n use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\r\n of the Software, and to permit persons to whom the Software is furnished to do so,\r\n subject to the following conditions:\r\n\r\n The above copyright notice and this permission notice shall be included in\r\n all copies or substantial portions of the Software.\r\n\r\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n THE SOFTWARE.\r\n*/\r\n\r\nimport { IAssemblerManager } from '../../2d/renderer/base';\r\nimport { TiledLayer } from '../tiled-layer';\r\nimport { simple } from './simple';\r\n\r\n// Inline all type switch to avoid jit deoptimization during inlined function change\r\n\r\nconst tiledLayerAssembler: IAssemblerManager = {\r\n    getAssembler () {\r\n        return simple;\r\n    },\r\n};\r\n\r\nTiledLayer.Assembler = tiledLayerAssembler;\r\n\r\nexport {\r\n    tiledLayerAssembler,\r\n};\r\n"],"names":["Orientation","Property","TileFlag","StaggerAxis","StaggerIndex","RenderOrder","TMXObjectType","ccenum","TMXTilesetInfo","this","name","firstGid","spacing","margin","sourceImage","imageName","imageOffset","imageSize","Size","tileOffset","Vec2","_tileSize","collection","prototype","rectForGID","gid_","result","rect","Rect","width","height","gid","FLIPPED_MASK","x","y","max_x","Math","floor","round","TMXObjectGroupInfo","properties","objects","visible","opacity","color","Color","offset","draworder","tintColor","_proto2","getProperties","setProperties","value","TMXLayerInfo","layerSize","tiles","ownTiles","minGID","maxGID","_proto3","ATTRIB_NONE","ATTRIB_BASE64","ATTRIB_GZIP","ATTRIB_ZLIB","TMXImageLayerInfo","trans","uint8ArrayToUint32Array","uint8Arr","length","arrLen","retArr","window","Uint32Array","i","strToHAlign","hAlign","Label","HorizontalAlign","CENTER","RIGHT","LEFT","strToVAlign","vAlign","VerticalAlign","BOTTOM","TOP","strToColor","indexOf","substring","a","parseInt","substr","r","g","b","getPropertyList","node","map","res","Array","from","getElementsByTagName","filter","element","parentNode","property","j","push","getAttribute","type","parseFloat","TMXMapInfo","tmxFile","tsxContentMap","spfTexturesMap","textureSizes","imageLayerTextures","orientation","parentElement","parentGID","layerAttrs","storingCharacters","currentString","renderOrder","RightDown","_supportVersion","_objectGroups","_allChildren","_mapSize","_layers","_tilesets","_imageLayers","_tileProperties","Map","_tileAnimations","_tsxContentMap","_spriteFrameMap","_spfSizeMap","_staggerAxis","_staggerIndex","_hexSideLength","_imageLayerSPF","initWithXML","_proto","getOrientation","setOrientation","getStaggerAxis","setStaggerAxis","getStaggerIndex","setStaggerIndex","getHexSideLength","setHexSideLength","getMapSize","setMapSize","getTileSize","setTileSize","getLayers","setLayers","getImageLayers","setImageLayers","getTilesets","setTilesets","getObjectGroups","setObjectGroups","getAllChildren","getParentElement","setParentElement","getParentGID","setParentGID","getLayerAttribs","setLayerAttribs","getStoringCharacters","setStoringCharacters","tmxString","tsxMap","spfTextureMap","parseXMLString","xmlStr","tilesetFirstGid","SAXParser","parse","documentElement","orientationStr","staggerAxisStr","staggerIndexStr","hexSideLengthStr","renderorderStr","version","nodeName","versionArr","split","supportVersion","v","logID","ORTHO","ISO","HEX","RightUp","LeftUp","LeftDown","STAGGERAXIS_X","STAGGERAXIS_Y","STAGGERINDEX_ODD","STAGGERINDEX_EVEN","mapSize","tilesets","curTileset","tsxName","currentFirstGID","tsxXmlString","images","firstImage","firstImageName","replace","tileCount","tile","tilesetName","tilesetSpacing","tilesetMargin","fgid","tilesetSize","curTileOffset","tileOffsetX","tileOffsetY","tileset","tileIdx","curImage","curImageName","nameWithPostfix","getNameWithPostfix","shortName","getShortName","error","Object","keys","join","errorID","warn","tileImages","hasAttribute","hastilesize","image","pid","set","animations","framesData","animationProp","frames","dt","frameIdx","frame","tileid","duration","grid","childNodes","childNode","_shouldIgnoreNode","imageLayer","_parseImageLayer","layer","_parseLayer","objectGroup","_parseObjectGroup","nodeType","selLayer","datas","data","source","nodeValue","trim","compression","encoding","codec","unzipBase64AsArray","zlib","Inflate","Base64","decodeAsArray","decompress","csvTiles","csvIdx","selDataTiles","xmlIdx","selGroup","fromHEX","selObj","objectProp","id","rotation","visibleAttr","texts","text","TEXT","wrap","halign","valign","pixelsize","IMAGE","ellipse","ELLIPSE","polygonProps","POLYGON","selPgPointStr","points","_parsePointsString","polylineProps","POLYLINE","selPlPointStr","polylinePoints","RECT","sort","pointsString","pointsStr","selPointStr","setTileAnimations","getTileAnimations","getTileProperties","setTileProperties","tileProperties","getCurrentString","setCurrentString","slashIndex","lastIndexOf","strLen","dotIndex","_createClass","key","get","TiledTile","exports","_dec","ccclass","_dec2","requireComponent","UITransform","_dec3","CCInteger","_dec4","_dec5","_dec6","_dec7","_class","_class2","_Component","_this","call","_layer","_x","_initializer","_y","_initializer2","_inheritsLoose","onEnable","parent","getComponent","on","NodeEventType","TRANSFORM_CHANGED","_updatePosition","SIZE_CHANGED","_resetTile","updateInfo","onDisable","off","getTiledTileAt","setTiledTileAt","p","getPositionAt","setPosition","_markForUpdateRenderData","isInvalidPosition","getTileGIDAt","setTileGIDAt","Component","_applyDecoratedInitializer","_applyDecoratedDescriptor","getOwnPropertyDescriptor","_enableTexelOffset","enableTexelOffsetUtils","enable","fillTextureGrids","texGrids","spFrame","spf","tex","texture","imageWidth","imageHeight","tw","th","texWidth","texHeight","count","cols","rows","max","override","maxGid","t","l","cx","cy","offsetX","offsetY","rotated","spriteFrame","_name","lm","unbiasUV","bm","_rect","_rotated","getRect","_mat4_temp","Mat4","_vec2_temp","_vec3_temp","Vec3","_vec3_temp2","_tempRowCol","row","col","isTiledSubNodeData","TiledUserNodeData","_index","_row","_col","_tiledLayer","TiledLayer","_class3","_UIRenderer","_this2","_userNodeGrid","_userNodeMap","_userNodeDirty","tiledTiles","_viewPort","_cullingRect","leftDown","rightTop","_cullingDirty","_rightTop","_layerInfo","_mapInfo","_topOffset","_downOffset","_leftOffset","_rightOffset","vertices","_verticesDirty","_layerName","_layerSize","_minGID","_maxGID","_layerOrientation","_opacity","_tintColor","_textures","_leftDownToCenterX","_leftDownToCenterY","_hasTiledNodeGrid","_hasAniGrid","_animations","_enableCulling","colorChanged","_properties","_mapTileSize","_odd_even","_diffX1","_diffY1","_useAutomaticVertexZ","_vertexZvalue","_offset","_tiledDataArray","_cameraNode","_drawInfoList","_tiledDataArrayIdx","requestDrawInfo","idx","RenderDrawInfo","setDrawInfoType","RenderDrawInfoType","MIDDLEWARE","hasTiledNode","hasAnimation","addUserNode","dataComp","warnID","addComponent","uuid","_nodeLocalPosToLayerPos","getPosition","_positionToRowCol","_addUserNodeToGrid","_updateCullingOffsetByUserNode","_userNodePosChange","_userNodeSizeChange","removeUserNode","_removeUserNodeFromGrid","_removeComponent","destroy","removeFromParent","destroyUserNode","nodePos","out","getNodesByRowCol","rowData","getNodesCountByRow","_updateAllUserNode","dataId","node_","_getUITransformComp","contentSize","self","_limitInLayer","index","colData","list","rowCol","tempRowCol","isUserNodeDirty","setUserNodeDirty","_reinstallCamera","camera","director","root","batcher2D","getFirstRenderCamera","cameraNode","_uninstallCamera","updateCulling","ANCHOR_CHANGED","_syncAnchorPoint","View","instance","_resize","screenAdapter","scheduleOnce","bind","_this$node$parent","_this$node$parent2","scale","getScale","anchorX","anchorY","getLayerName","setLayerName","layerName","getProperty","propertyName","pos","undefined","_positionForOrthoAt","_positionForIsoAt","_positionForHexAt","gidAndFlags","tileWidth","tileHeight","odd_even","diffX","diffY","setTilesGIDAt","gids","beginCol","beginRow","totalCols","gidsIdx","endCol","_updateTileForGID","flags","ugid","Error","_updateVertex","getTileFlagsAt","FLIPPED_ALL","setCullingDirty","isCullingDirty","updateViewPort","reserveLine","vpx","vpy","leftDownX","leftDownY","rightTopX","rightTopY","maptw","mapth","maptw2","mapth2","diffX2","diffY2","axis","updateWorldTransform","invert","getWorldMatrix","z","screenToWorld","transformMat4","getLayerOrientation","layerOrientation","diffX1","diffY1","grids","left","bottom","gridGID","downBorder","leftBorder","cullingCol","cullingRow","topBorder","rightBorder","minCol","maxCol","_updateVertices","forceCreate","Node","tiledTile","some","tiledNode","getTexture","getTextures","setTexture","setTextures","textures","getLayerSize","getMapTileSize","getTileSet","getTileSets","setTileSet","setTileSets","clear","tilesetInfo","_prepareToRender","init","layerInfo","mapInfo","size","layerW","layerH","uiTransformComp","setContentSize","wh","requestTiledRenderData","arr","subNodes","pop","last","renderData","vertexCount","comb","requestSubNodesData","destroyRenderData","forEach","rd","RenderData","remove","_flushAssembler","assembler","Assembler","getAssembler","_assembler","createData","_updateColor","_render","ui","m","c","walk","td","commitComp","_static","createRenderEntity","RenderEntity","RenderEntityType","CROSSED","fillIndicesBuffer","drawInfo","iBuf","chunk","meshBuffer","iData","vertexId","vertexOffset","quadCount","indexOffset","setIndexOffset","setIBCount","prepareDrawData","_this3","entity","renderEntity","clearDynamicRenderDrawInfos","tiledDataArray","SUB_NODE","setSubNode","setDynamicRenderDrawInfo","fillDrawInfoAttributes","getGFXTexture","setSampler","getGFXSampler","setMaterial","getRenderMaterial","UIRenderer","TiledObjectGroup","CCBoolean","_premultiplyAlpha","_groupName","_positionOffset","_hasAniObj","_texGrids","aniObjects","_objects","getPositionOffset","getGroupName","toString","getObject","objectName","len","obj","getObjects","_init","groupInfo","FLAG_HORIZONTAL","HORIZONTAL","FLAG_VERTICAL","VERTICAL","tileSize","colorVal","iso","transComp","leftTopX","leftTopY","aliveNodes","object","objType","pi","posIdxX","posIdxY","textName","textNode","getChildByName","setRotationFromEuler","setSiblingIndex","label","textTransComp","active","overflow","Overflow","SHRINK","lineHeight","string","horizontalAlign","verticalAlign","fontSize","imgName","imgNode","_objFlags","CCObjectFlags","HideInHierarchy","hideFlags","DontSave","sprite","Sprite","imgTrans","sizeMode","SizeMode","CUSTOM","srcBlendFactor","BlendFactor","ONE","SRC_ALPHA","material","_updateBlendFunc","clone","SpriteFrame","flipUVX","flipUVY","children","uselessExp","n","cName","test","update","aniObj","sp","TiledMapAsset","TextAsset","CCString","_Asset","tmxXmlStr","tsxFiles","tsxFileNames","_initializer3","spriteFrames","_initializer4","imageLayerSpriteFrame","_initializer5","imageLayerSpriteFrameNames","_initializer6","spriteFrameNames","_initializer7","spriteFrameSizes","_initializer8","Asset","serializable","_dec8","MaxGridsLimit","TiledMap","_groups","_images","_mapOrientation","_isApplied","_tmxFile","cleanupImageCache","getMapOrientation","getObjectGroup","groupName","groups","group","getLayer","layers","_changeLayer","replaceLayer","getPropertiesForGID","enableTexelOffset","__preload","_applyFile","spriteFramesCache","file","spfNames","spfSizes","fSpriteFrames","spfTextureSizeMap","texName","texValues","_buildWithMapInfo","_releaseMapInfo","_layers$i$node$parent","_layers$i$node$parent2","anchor","anchorPoint","setAnchorPoint","groupNode","_fillAniGrids","_step","_iterator","_createForOfIteratorHelperLoose","done","animation","_buildLayerAndGroup","oldNodeNames","layerInfos","maxWidth","maxHeight","child","addChild","enableCulling","original","originalSize","totalTextures","doCleanupImageCache","_image","HTMLImageElement","src","sys","hasFeature","Feature","IMAGE_BITMAP","ImageBitmap","close","lateUpdate","_step2","_iterator2","aniGID","hasChangedFlags","EDITOR","ceil","vec3_temps","_tempBuffers","_curLayer","flipTexture","_vec3u_temp","_leftDown","_uva","_uvb","_uvc","_uvd","_vfOffset","_moveX","_moveY","_fillCount","_curTexture","_accessor","simple","Simple","ensureAccessor","device","StaticVBAccessor","vfmtPosUvColor","fillBuffers","updateRenderData","comp","leftDownToCenterX","leftDownToCenterY","cullingRect","traverseGrids","updateColor","tiled","colorV","Float32Array","rs","vs","vData","vertexStart","_flipTexture","inGrid","tempVal","DIAGONAL","packRenderData","vbCount","ibCount","tiledData","add","resize","vb","subarray","rowMoveDir","colMoveDir","matrix","worldMatrix","vertStep2","vertStep","vertStep3","right","top","colNodesCount","isCheckColRange","_tempRows","abs","_tempClos","vertexBuf","nodes","celData","fillByTiledNode","vbuf","fromRTS","position","transform","multiply","tx","m12","ty","m13","m00","m01","m04","d","m05","tiledLayerAssembler"],"mappings":"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"}